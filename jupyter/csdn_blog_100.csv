321	 WhatisthenextBIGthing?	internet  产品  apple  blackberry  nokia  服务器  	1081489020	2088	superyan	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <div class="title">What is the next BIG thing?</div><span class="author">Submitted by <a href="http://www.hi-pda.com/drupal//?q=user/view/3" title="View user profile.">UGlee</a> on Mon, 04/05/2004 - 16:25.</span> <span class="taxonomy"></span><div class="content"><b>本文已为纸媒体发表，某某在线和某某家请勿转载</b><br/><br/>在去年的10月7日，加州Mountain View新开张的计算机历史博物馆内，一些在硅谷打拼的、令人尊敬的遗老遗少们在热烈的讨论着一个难以承受的话题：<br/><br/><b>What is the Next Big Thing?</b><br/><br/>在过去的30年中，硅谷创造了三个奇迹：70年代的半导体技术，80年代的个人计算机，和90年代的Internet。那么硅谷的下一个十年在哪里呢？The Churchill Club和Garage Technology Ventures把这些昔日英雄们撮集在一起探讨这个话题。<br/><br/>而事实上，这个史称<a href="http://www.siliconvalley4.com/">Silicon Valley 4.0</a>的大事件，并未挤出什么令人激动的前景，除了在网站上15美元一份的录音在发售之外，鲜见媒体的关注与报到。<br/><br/>***************************************************************************************<br/><br/>在拉登本先生倡导的全球经济萎缩背景下，IT工业没能卓尔不群。众多的工业巨子拥挤在一座岌岌可危的古堡里，每一个可能的出口都拥挤着很多神色狐疑蓄势待冲的人－尽管眼前的景况对不少人来说仍然小康，但谁也不知道明天的大饼从哪里来。<br/><br/>下面我们来简单回顾一下2003年里发生在每个领域的里的故事。<br/><br/><b>1、个人通讯</b><br/><br/>这是少有的几个仍然很滋润的方向之一，但是2003年的通讯产业未带来太多惊喜。3G的技术前景变得扑朔迷离，网络的巨大投资让运营商望而却步，整个行业苦思冥想也没有找到梦中的Killer App，无论是MMS，还是Web/Email/IM，都没能抗起重担充当救星。而在设备端，先后登场的O2 XDA/II，Orange SPV/2，Treo 180/270/300/600，Sony-Ericsson P800/900，都是叫好不叫座。只有Nokia的76xx, 36xx走向了主流市场，但却没有如预期的点燃MMS业务。<br/><br/>整个行业的最大亮点仍然是<a href="http://www.rim.com/">RIM</a>－一家依靠完美的Pushmail后台服务来销售硬件能力低下又价格昂贵的<a href="http://www.blackberry.com/">Blackberry</a> email终端的小公司。而业界领袖<a href="http://news.com.com/2100-1040_3-965041.html?tag=st_rn">Nokia也最终授权了RIM的Blackberry技术</a>准备在这个领域大干一场。<br/><br/>尽管有<a href="http://www.theage.com.au/articles/2003/10/24/1066631610060.html">Gartner的数据强力支持</a>，也尽管有RIM的大获成功，企业的Email/Web应用就真的能成为Smartphone乃至整个移动通讯产业的救星吗？这里至少还有两个让人气馁的地方：<br/><br/>1。RIM的实际市场容量拿到通讯产业来还不值一提。<br/>2。手机平台缺乏触屏和拇指键盘的设计也让Messaging应用的易用性大打折扣。从这个意义而言，最好的Email/Web终端是Treo的设计（TouchScreen + Qwerty KB），其次是Blackberry和Sidekick（Qwerty KB），再次是SE P800/900和Pocket PC Phone（TouchScreen），而Series 60和MS Smartphone都是最糟糕的交互方式：只有Num Keypad。<br/><br/>在进入中国市场的时候，可能还要加上一条更令人气馁的：<br/><br/>3。中国的Email应用市场远没有北美大。中国的SMS才是大头，而北美完全相反。<br/><br/><b>2、PC工业</b><br/><br/><a href="http://www.pcmag.com/article2/0,4149,1386933,00.asp">2003的PC Magzine Technolody Excellence Award</a>里面，把PC和PC Component两个奖项分别授予了来自Apple的PowerMac G5和AMD的Opteron。个人而言，我很喜欢Apple和AMD这两家顽强的创新技术的公司，但是这两个奖项都被非业界领袖的公司拿走，是不是说明在这个领域，业界的导航者已经失去了动力呢？<br/><br/>主流的PC硬件工业已经是彻底的Commodity Business了，整个2003也乏新可陈。依旧是主频加外频的提升，显卡晶体管数量的增加等等。AMD64技术，从市场的角度说，是AMD颠覆Intel在个人计算领域领先地位的起点。在64位个人计算上，由于不兼容32位x86指令，Itanium的前景相当难堪。不过，无论是IA64，还是AMD64，在进入消费市场的时候都面临一个很严峻的问题：缺乏软件的支持。这不难理解。事实上，正如Dell所说，在个人计算领域，消费者对64位技术的需求并不强烈。在服务器领域却是另外一番风景。<a href="">2003年的服务器市场有着相当不俗的表现</a>。从技术上看，这得益于IA构架的服务器产品价格的下降。HP，IBM，和Dell都推出了大量的IA构架低端服务器产品线，而且取得了不俗的成绩；而服务器市场的另一个巨头SUN，动作慢了半拍，错过了大好机会，并且它的Blade技术也有些生不逢时。服务器市场的增长得益于Internet产业的复苏，确切的说，是各种在线服务业务的迅猛发展，包括各种Media的下载服务，在线游戏业务的迅猛发展，以及越来越多的中小企业提高信息化运作程度。<br/><br/>在软件方面，微软继“你该抱着笔记本电脑使用”理念失败之后，打出了“你该买两台家用电脑”的理念。Windows Media Center版的推出立刻得到了Dell和SONY的鼎立支持。现在有超过40个PC制造商推出了基于MC版Windows的PC产品，但是，正如<a href="http://news.com.com/2010-1040-5085941.html">Cooper所言</a>：“Stuffing a bunch of existing technologies into a computer box hardly classifies as the last word in convergence. Even wall-to-wall advertising can't change that reality. ”（把一堆已经存在的技术塞入机箱根本算不上融合，即使墙上到处都是广告也改变不了这个事实。）<br/><br/>Media Center算不上什么新概念。早在2001年Apple就在捣鼓它的Digital Hub Strategy。如果精于此道的Apple都失败了，我想不出有什么理会让Microsoft大获成功。至于DHS为什么失败，这里有个很有意思也流传很广的<a href="http://www.themacmind.com/modules.php?op=modload&amp;name=News&amp;file=article&amp;sid=112&amp;mode=thread&amp;order=0&amp;thold=0">讨论</a>。<br/><br/>上面的讨论中给出一个很有意思的数据：<b>美国家庭的电视机平均每天使用7小时40分钟！</b>也许正是受到这一启发，合并Compaq的HP高举大旗准备进军<a href="http://www.digitalfernsehen.de/news/news_3214.html">Digital TV</a>。不过Digital TV是否能如计算工业所愿和PC纠缠在一起，只有市场能来回答这个问题吧。<br/><br/><b>3、PDA</b><br/><br/>2003年的PDA市场在一片哀鸣声中顽强的存活了下来。这一年的大事件包括MS Windows Mobile 2003的推出，PalmOne和PalmSource的分拆，以及PalmOne合并Handspring走上Smartphone的不归路。<br/><br/>尽管和前一年相比，全球PDA出货稍有下降，但是实际上这应该看成HP和PalmOne的成功。HP在第三季度一口气推出7款产品，力挽了PDA市场的颓势；而PalmOne也一改原来的沉稳作风，快速的硬件升级，高性价比的Tungsten E，偏重娱乐型产品的Zire71，使出了浑身解数力保了全球出货量与去年持平。<br/><br/>尽管有被Smartphone吃掉市场的危言耸听论调，从实际的市场销量来看，PDA仍然有一席之地。不过如果我们回到计算设备的起点来审视近一年来的PDA发展，就会有一种迷失方向的感觉。一个消费级的计算设备应该有的必备因素是：交互方式（显示和输入），计算能力（CPU，内存），连接性（设备和网络），存储能力（容量与媒介的交换）。目前的PDA产品，无论是Palm还是Pocket PC，其计算能力都超过了应用的需求，但是在存储和连接能力上的欠缺极大的限制了其功能。2003年的无线数据网络（GPRS/CDMA）发展很快，但可惜的是蓝牙手机的普及和无线内容服务远没有预期的成功，这也很大程度影响了PDA产品的发展。<br/><br/>2003年PDA产品的技术亮点是GPS和Game Console。Gartner说，在欧洲iPAQ取得的大幅增长，很大一部分原因是捆绑的GPS模块；而在美国，Garmin推出的iQue 3600设备，也受到了市场的追捧。在国内，2003年出现的GPS设备的数量也有很大提升，但是无奈国内的有车一族不多，地图资源的缺乏，和城市里高架公路的影响等诸多原因，这个市场没有象欧美一样有大幅度的增长。<br/><br/>来自Tapwave的Zodiac2是2003年里最令人眼前一亮的产品。传闻说Tapwave里面有很多工程师来自当年Newton的开发队伍，实力不可小觑。在市场上，Zodiac并没有受到热捧，很大程度上是因为Tapwave没有足够的财力来支持庞大的市场推广和销售，目前还只有在线销售一种销售方式。目前，Zodiac最需要的是一个强力的品牌支持，相对与设计更好的产品而言，找到一个好的买主把自己收购是更现实的策略。在没有巨大资金和品牌的支持下，Zodiac能够走多远也让人捏一把汗。Game Console领域并非是无人关注的处女地，Nokia携着N-Gage准备打出一个新天地，Nintendo也会稍后推出一款神秘的双屏游戏手机<a href="http://www.gamespy.com/articles/january04/nintendods/">Nintendo DS</a>。而传闻很久的<a href="http://www.theregister.co.uk/content/68/33790.html">SONY Playstation Portable</a>也会在2004杀入市场。这块蛋糕看起来也不那么容易吃到。<br/><br/><b>4、数字音乐</b><br/><br/>2003是Apple的iPod大红大紫的一年。iTMS（iTunes Music Store）把iPod和99美分音乐下载服务联系在了一起，也为Apple赢得了“终于走出了商业模式的创新”之美誉。在下载服务商，Apple签约了北美的五大出版商；在软件上，Apple提供了Windows版本的iTunes，并且让Rio和Nomad都捆绑或者兼容了这个软件；在设备上，HP会发售自己品牌的iPod产品。但是如果你以为Apple势不可挡，那你就大错特错了。<a href="http://reviews.cnet.com/4521-6532_7-5021434-3.html?tag=subnav">这里</a>有一箩筐的Clone产品在准备围追堵截iPod。Apple想要成功突围也不那么容易。<br/><br/>iPod不是第一个使用大容量存储硬盘的数字音乐产品，Creative和一些日本厂商有过更早的尝试。但是没人会反对iPod是最成功的MP3产品。iTunes的软件和服务，以及Apple的良好运作是一方面；而微硬盘技术的成熟也功不可没。<br/><br/>另外一个值得关注的微硬盘产品－虽然没有使用在iPod上－也受到关注。来自Cornice的<a href="http://www.corniceco.com/products/">Cornice SE</a>产品获得了<a href="http://www.pcmag.com/article2/0,4149,1386937,00.asp">PC Magazine的Technology Excellence Awards</a>殊荣。据说Cornice是由原来Maxtor的CTO离开公司自己创建的一家小公司。Cornice SE的优点很多，包括更少的零件设计（更高的可靠性），更低的功耗，还有非常不错的价格（70美元）。在Rio的MP3播放器产品中使用的就是Cornice SE。相信不久的将来，它就会出现在PDA，DC/DV等各种数码产品中。<br/><br/><b>5、数码影像</b><br/><br/>数码相机的市场大概是近年来数字产品中增长最疯狂的了，一些乐观的预言声称，2004年的数码相机市场有超过100%的增长率。但是，这个市场的竞争也是空前惨烈的，包括传统相机生产商，传统的胶片生产商，消费电子产品制造商，各大PC厂商乃至PC外设提供商都义无反顾的进入了这个领域。<br/><br/>2003年胶片厂商受到了巨大的挑战，Kodak在大幅裁员以把业务重心转向数码影像设备。不过对于PC，尤其是打印机厂商来说，这也许是好事情。Photoshop工厂和打印的需求量会增加。Epson/Canon/HP等打印机厂商，更是推出了可以直接支持Flash卡打印的产品。<br/><br/>从技术角度说，2003的数码影像市场中最值得关注的几个产品是：Olympus率先推出了Digital SLR产品，基于新标准3/4系统的E1相机；Canon推出了体积适中价格低廉的标准DSLR相机E300D。这两款产品的推出可以说是真正为胶片相机敲响了丧钟。从来未曾推出过数码相机产品的Sigma，在2003年推出了SLR的D9，而推动这款产品诞生的是它的三层CMOS感光原件Foveon X3 5M CMOS Direct Image Sensor。这也是获得PC Magazine Technology Excellence的技术产品，你可以在它的网站上了解到更多的细节。<br/><br/>***************************************************************************************<br/><br/><b>The Next Big Chance</b><br/><br/>尽管在每个领域里都充斥着浮躁和焦虑的情绪，但至少还有一位巨人是清醒的。仔细注意一下PC Mag的众多奖项获得者，你就能发现机会将出现在哪里。<br/><br/>1。Component的Finalist里面，有一个是：Broadcom AirForce OneChip BCM4317。这是一个极有竞争力的嵌入式设备Wifi解决方案，在拇指甲大小的面积上，提供了完整的单芯片设计，并且有低功耗和低成本的优势。<br/>2。同样是Component的Finalist里面，有来自Intel的Centrino Pentium M。在2003年Wifi技术的爆炸式发展中，Intel的Centrino功不可没。<br/>3。而在Protocol里面，获奖的技术是802.11g。在下一个版本的Centrino中会有对该标准的支持。<br/><br/>Intel的目标很明确，无论是否存在64位的个人计算市场，Itanium都不适合这个领域。而强力推广无线宽带技术，在个人终端上，可以延长IA32产品的生命周期；在服务器端，可以快速推动IA64进入市场；而Intel本身也提供大量的网络芯片和网络设备解决方案。可以说它的战略已经从Power the PC转向了Power the Internet。<br/><br/>Intel的Centrino仅仅是Wireless梦想的开始，而它的下一步－<a href="http://www.wi-fiplanet.com/news/article.php/3302591">WiMax</a>－肯定会让你大吃一惊。WiMax是基于IEEE即将批准的802.16d标准，和先前的WirelessMAN(802.16)相比，WiMax把工作频率拓展到了10G到66G的高频段，Intel声称它的最终产品可以覆盖30英里的城域距离范围并实现70Mbps的速度。<br/><br/>Intel先移动运营商一步开始积极打造全新的Internet世界，并且咄咄逼人，志在必得。而来自英国，印度，香港、巴西和墨西哥的一些运营商已经开始积极的测试和评估该技术。现在还难以去估计WiFi和WiMax的普及会对整个产业产生什么样的影响－包括市话服务商，长话服务商，Internet接入商，和移动运营商－但可以肯定的是，WiMax对于那些在最后一公里接入上处于劣势的小公司可以站在更公平的起跑线上开始新一轮的业务竞争。比如：假设一个机站就可以为一个小区提供语音服务，而早先那些被当作壁垒的线路资源，很可能蜕变成为沉重的维护负担。<br/><br/><b>Last Hurdle</b><br/><br/>从某种意义上说，PC是Internet连接每个人的最终壁垒。PC的成本，学习曲线，易用性，复杂性，易维护性和便携性都使得它无法成为像手机那样的人人可用的设备。但是为什么Apple会力推Digital Hub Strategy，而微软也要效法一个Media Center呢？答案很简单：PC，或者Mac，是他们的主要利润来源。<br/><br/>包括苹果的iPod，其实你也完全可以构想另外一种工作方式：给它武装上一个简单的OS，一个Internet接入方式，可以是Ethernet底座，也可以是和手机的连接线（Sprint PCS可以提供高达100Kbps的速率），iTMS仍然可以工作－－但是在这个链条上Mac或者PC的存在就没有必要性了。<br/><br/>有相当多的应用都可以跨过PC直接去实现，包括VoIP，IM，Email，Web browsing，Content（News，ebook etc），Media（Music，Video etc），Game，乃至还有些遥远的Streaming。这里面的大部分应用也不需要你有Giga Hertz的CPU，Hundreds of Mega的RAM，GigaByte的存储能力，光学的存储器等等。一些简单的应用甚至连键盘和彩色屏幕都可以舍弃。差不多50美元的设备就可以完成一些你用500美元的PC来完成的工作。<br/><br/>事实上，已经有一些纯粹的Internet Appliance开始出现，这包括能够接入Internet对战的PS和XBox游戏机，曾经出现过但是不太成功的WebPad，一些能够直接收听Internet电台的网络收音机，包括那个Blackberry，你也可以把它看作一个Dedicated Email终端。在Wireless Anywhere的时代，这些产品无疑会有更大的目标用户群体。而未来的数字电视－可能是比较远的未来－也完全有可能通过Internet成为视频终端。iPod类的播放器，和从未取得较大成功的电子书或者电子报纸概念，也许能在Wireless时代找到一个适合自己的位置。<br/><br/>Anyway, time to leave your PC。<br/><br/><b>What's the Next Big Thing</b><br/><br/>要精确的描述这个全新的Internet大道，应该是Wireless Broadband Internet。信息产业部可能会采用“信息磁悬浮”或者“信息空中走廊”这样更加形象的字眼来命名WiFi或者WiMax标准。<br/><br/>从服务端看，如果说90年代的Dial-up/Fibre Internet是Information Network，那么Wifi和WiMax时代的Internet就应该是一个Application Internet。而从用户的角度来看，Internet从Connecting machine走向了Connecting People。<br/><br/>对于任何一个产业来说，Wireless Interent都是危险和机遇并存。危险来自于不同领域的业务融合，每个竞争者都要面对来自另外一些领域的新对手，并且可能要学会一种新的运作方式，就象胶片厂商和消费电子厂商涌入数码相机领域那样；而机遇来自于Internet的无所不在和不断提升的性能（会有Internet摩尔定律吗？），会有更多的新业务或者商业模式诞生。<br/><br/><b>PDA的未来</b><br/><br/>在这样的机遇下，你还相信PDA产品会最终消失吗？你同意通讯厂商的说法，他们能把那么多的应用都塞到一个小体积的电话里并且不牺牲易用性和舒适性吗？<br/><br/>还记得么？在MultiMedia PC之后，是Internet成为PC工业的救世主；历史就是这样惊人的相似，在MultiMedia Handheld之后，同样是Internet来拯救手持计算工业。<br/><br/>尽管开放OS的计算系统在Dedicated Device中无法体现它的软件资源优势；但是其一脉相承的交互方式、相对较低的应用开发成本、和嵌入式OS的灵活裁减能力仍然使得它相对于Proprietary OS保有一定的优势。而无论是PalmOS设备还是Pocket PC设备都应该：<br/><br/>1。脱离PC（微软可能非常不情愿走出这一步）。直接使用Internet来实现Content Distribution，或者使用类似Dock Station一样的东西用成熟且廉价的CD-ROM作为介质。使用Internet，无线连接能力（IR or BT）或者Flash卡作为数据交换方式。<br/>2。配备高速Internet接入方式，最好是Wifi，其次是Ethernet/Modem Dock。<br/>3。通过Internet提供增值服务，VoIP/Video Call，IM/Email（Qwerty KB），新闻下载，电子书下载，音乐/漫画/电影下载（最好内置Cornice SE那种大容量存储设备）。<br/><br/>移动通讯产业的从业人士经常会骄傲的说：Mobile Phone is a must-have。－－Don't believe it！这只是比较夸张的形容Mobile Phone的重要性－－但是，它肯定没有重要到必不可少的地步，不然1990年以前的人们是如何活下来的呢？PDA会能有多重要？这取决于应用。如果越来越多的重要应用来到PDA上，而且它们也易用好用，PDA也会有被形容为Must-Have的那一天。<br/><br/><b>Final - A few thoughts</b><br/><br/>差不多10年以前，有过一个维纳斯计划，其目的是在电饭煲上安装一个浏览器。那个时候的Internet是一个纯粹的信息网络，而IT产业向消费电子发动的攻势是把信息应用塞到家用电器中去。10年之后，这种Convergence的理想出现了成为现实的契机，但是却是完全相反的方式：把各种原有的应用搬到由信息技术构建的Backbone上来。这不难理解，想想我们听音乐的历史，从留声机到磁带机，再到CD机，再到MP3播放器，再到未来可以突破存储限制的Wireless Streaming。我们的应用需求从未改变过，但是技术让我们可以更加舒适更加自由更加没有约束和限制。<br/><br/>I am not a technology guy. I understand technologies, but I am not excited about technologies. I am excited about applications. It's all about applications and functionality. ---- Jeff Hawkins<br/><br/>***************************************************************************************<br/><br/>Broadband和Wireless是一对彼此依赖的孪生兄弟。前者让很多应用成为可能或者说更加实用，而后者为使用者提供了决佳的舒适性。套用一句时髦的话，这该叫做科技人性化吧。<br/><br/>***************************************************************************************<br/><br/>如果一切如预期的顺利发展，Intel将是这次WiFi/WiMax革命的最大受益者。这家伴随硅谷成长的公司，不但一直保持着半导体工艺和设计技术的领先地位，也在20年的PC革命中为产业的发展提供强大动力。而随着PC工业的规模饱和增长趋缓，IT生产力工具的重心从PC向Server迁移，Intel再次强力推动Internet应用平台的硬件发展，这种挺身而出的勇气让人再次看到Groove缔造的那种“只有偏执狂才能生存”的企业精神。<br/><br/>向Intel敬礼！</div>                </div>                    </div>
322	 关于我在中华读书报发表的文章	读书  出版  教育  设计模式  语言  java  	1081489980	2488	wangyonggang	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p>2004-04-08 6:00 PM yeka提到，我在最近一期《中华读书报》上发了一篇文章“IT教材的异化与升华”。那篇文章写得很不好，写作时的感觉非常滞涩，本来还想润色一下，因为编辑定的交稿日期已到，只好硬着头皮交了。在这里，我只提一个和文章内容关系不大的问题：</p><p>我还没有看到该文印在报纸上的效果，但从光明日报网站上发布的电子版看，《中华读书报》的编辑们非常小心地删去了拙文中的一个敏感语词。我非常非常理解编辑们的良苦用心，但在今天这个讲求科学的时代里，前些天连中央电视台都把方舟子请进了荧屏……我们的科学意识还有待提高啊！下面给出的是我的原稿：</p><p align="center" class="MsoTitle" style="margin:12pt 0cm 3pt;"><strong><font size="5"><span lang="en-us" xml:lang="en-us"><font face="Arial">IT</font></span><span style="font-family:'宋体';">教材的异化与升华</span></font></strong></p><p align="center" class="MsoNormal" style="margin:0cm 0cm 0pt;text-align:center;"><span>王咏刚，</span><span lang="en-us" xml:lang="en-us">2004</span><span>年</span><span lang="en-us" xml:lang="en-us">3</span><span>月</span></p><p class="MsoNormalIndent"><span lang="en-us" xml:lang="en-us">&lt;?xml:namespace prefix = o ns = "urn:schemas-microsoft-com:office:office" /&gt;</span></p><p> </p><p class="MsoNormalIndent"><span>闲来翻书时偶然发现，世界上最早的学校和最早的教科书，竟然都是两河流域的苏美尔人在公元前</span><span lang="en-us" xml:lang="en-us">3000</span><span>年左右创造出来的。今年是公元</span><span lang="en-us" xml:lang="en-us">2004</span><span>年，一年前的春天，当美军第三机步师在伊拉克南部长驱直入的时候，美国大兵们是否知道，就在坦克和步兵战车碾压过的土地下面，很可能埋藏着五千年前的苏美尔校园，埋藏着五千年前的朗朗读书声呢？</span></p><p class="MsoNormalIndent"><span>我羡慕苏美尔人，羡慕他们古老的文明和同样古老的教学实践。相比之下，中国人的处境多少有些不尴不尬：尽管我从小就从教科书里获悉，中国有五千年的古老文明，但直到长大成人我才赫然发现，任何一种严肃的历史文献都无法确切地告诉我们，当五千年前的苏美尔人在泥板上一笔一画地刻写楔形文字的时候，中国的古人是否已经发明了严格意义上的文字，是否也开办了学校，编写了自己的教科书。除了“上下五千年”这样缺乏科学依据的说法以外，根据网上“打假义士”方舟子的研究，国内教材中不严谨甚至不科学的地方还有不少。毫无疑问，这种极不严肃的态度会给今天的教材编撰、出版、发行和使用带来相当多的隐患。在我所关心的</span><span lang="en-us" xml:lang="en-us">IT</span><span>教材市场里，类似的隐患虽然不那么明显，但也会让人时不时有芒刺在背的感觉。</span></p><p class="MsoNormalIndent"><span>比方说，如今有很多人倾向于把</span><span lang="en-us" xml:lang="en-us">IT</span><span>教材和普通</span><span lang="en-us" xml:lang="en-us">IT</span><span>书籍混为一谈：一些出版商在“某某系列教材”的旗号下，将“</span><span lang="en-us" xml:lang="en-us">N</span><span>天学会某某”或者诸如此类的普及读物改头换面，重新出版；不少院系为学生们开列的教科书目其实只是市场上技术类书籍排行榜的翻版；许多在校学生则认为，传统意义上的教材内容老化、形式呆板，与其在课堂上听老师喋喋不休，还不如买些热门书刊自学自练。拿现代教育理论强调专业化和差异化的标准来衡量，这些做法都算不上严谨和科学，也无益于图书市场和教育行业的共同繁荣——道理非常简单：对出版商而言，在竞争越来越依赖于细分市场和特异化产品的今天，人为地消弭</span><span lang="en-us" xml:lang="en-us">IT</span><span>教材和普通</span><span lang="en-us" xml:lang="en-us">IT</span><span>书籍间的界限无异于对巨大的市场机会视而不见；对教师来说，在课堂上使用一部并非专为教学编写的书籍，这多半会为教与学的过程平添几分生涩和窒碍；至于那些孜孜不倦的学子，我想，如果专业化的教材真能起到昭示门径、答疑解惑的作用，他们也不会退而求其次，拿普通的技术书籍当入门的宝典了。</span><span lang="en-us" xml:lang="en-us"></span></p><p></p><p class="MsoNormalIndent"><span>其实，专业的</span><span lang="en-us" xml:lang="en-us">IT</span><span>教材区别于普通</span><span lang="en-us" xml:lang="en-us">IT</span><span>书籍的最大特点就是前者对目标市场和读者群的针对性更强。现在，有太多的</span><span lang="en-us" xml:lang="en-us">IT</span><span>教材标榜自己既适用于课堂教学，也可以满足</span><span lang="en-us" xml:lang="en-us">IT</span><span>从业人员参考、翻检的需要。这种说法也许只是</span><span lang="en-us" xml:lang="en-us">IT</span><span>教材出版和发行者的一种市场推广手段，但它背后的真实性和有效性是颇可怀疑的。不可否认的是，许多优秀的</span><span lang="en-us" xml:lang="en-us">IT</span><span>书籍确实在学生和工程师这两类最重要的读者群中同时赢得了不俗的口碑，但这就像</span><span lang="en-us" xml:lang="en-us">1980</span><span>年代初期</span><span lang="en-us" xml:lang="en-us">PC</span><span>市场刚刚兴起时，商用</span><span lang="en-us" xml:lang="en-us">PC</span><span>和家用</span><span lang="en-us" xml:lang="en-us">PC</span><span>之间并不存在任何差异一样，都只是细分市场尚未成熟、特性需求还不明显时的暂时现象罢了。简单地说，如果大专院校的老师们只想在传统的大课堂上对着一两百名学生照本宣科、平铺直叙，那么，使用何种图书作为课本和参考资料倒并不是一件特别重要的事情；反之，如果我们的</span><span lang="en-us" xml:lang="en-us">IT</span><span>教育工作者希望把课堂变成一个师生交流互动的舞台，把教学变成一部促进知识传递的加速器，那么，专门为师生量身定制的书籍就一定能从浩瀚的书海中脱颖而出，大显身手。</span></p><p class="MsoNormalIndent"><span>不过，我们究竟该如何在实践中凸显</span><span lang="en-us" xml:lang="en-us">IT</span><span>教材的针对性呢？这个问题实际上等价于，假如在不远的将来，</span><span lang="en-us" xml:lang="en-us">IT</span><span>图书市场上有可能浮现出一个成熟、稳定、高质量的“教材专区”，那么，该区域里的专业化教材需要具备哪些特征？</span></p><p class="MsoNormalIndent"><span>一般说来，</span><span lang="en-us" xml:lang="en-us">IT</span><span>教材比其他技术书籍更需要在内容和架构上具备足够的系统性，惟其如此，教材的使用者才能在一个完整的知识框架内准确、全面地达成知识传递的目标。而且，不同类型的教材——如教科书和教学参考资料——对系统性的要求也不尽相同。例如，像《设计模式》这样的技术专著，其编撰初衷在于发表观点，阐明理念，它不可能也不需要全面地介绍学生必须了解的背景知识（如面向对象设计和</span><span lang="en-us" xml:lang="en-us">UML</span><span>语言），或系统地总结相关领域内的主要学术观点和研究成果（如关于设计模式的正面和反面观点），类似的书籍作为面向对象课程的参考资料未为不可，但作为课堂上使用的教科书就稍嫌勉强了。</span></p><p class="MsoNormalIndent"><span>从传道授业的角度来说，</span><span lang="en-us" xml:lang="en-us">IT</span><span>教材应当更重视传授经验方法而非灌输具体的知识技能。据《北京青年报》报道，微软亚洲工程院院长张宏江因为无法招聘到足够的具备实际研发能力的毕业生而感慨说：“一些软件专业毕业生的突出问题是太功利、脱离现实。”仅从教材的角度考虑，毕业生缺乏实践能力的现象或多或少和我们的教材忽视案例教学、情景想定、项目实践、自由讨论等科学的方法训练有关。当然，侧重于方法和理念教学会增加</span><span lang="en-us" xml:lang="en-us">IT</span><span>教材的设计与编写难度。对此，有些出版商错误地认为，</span><span lang="en-us" xml:lang="en-us">IT</span><span>技术日新月异，传统的教材编撰方式无法跟上技术更新的速度，与其精心设计、规划和出版专业教材，还不如为普通的技术书籍贴上教材的标签蒙混过关——这也许是因为他们还没有意识到，技术换代并不一定意味着</span><span lang="en-us" xml:lang="en-us">IT</span><span>基本规律、基本方法的老化和过时，专业化</span><span lang="en-us" xml:lang="en-us">IT</span><span>教材在侧重介绍规律、方法的前提下，也可以在某种程度上保持稳定，不受或少受技术更新的影响。</span></p><p class="MsoNormalIndent"><span>另一方面，</span><span lang="en-us" xml:lang="en-us">IT</span><span>教材有责任也有义务引导学生完成从生疏到熟习再到举一反三的整个学习过程。是否具备指南针或引路人的功效，这也是</span><span lang="en-us" xml:lang="en-us">IT</span><span>教材区别于普通</span><span lang="en-us" xml:lang="en-us">IT</span><span>书籍的一个重要特点。举个例子，像《</span><span lang="en-us" xml:lang="en-us">C++</span><span>标准程序库》这样类似程序员手册的技术书籍并不适于在课堂上扮演教学指南的角色，其原因在于，此类书籍为了内容上的完备和写作时的方便，不大可能在讲述知识的同时兼顾使用者的学习曲线，并根据教学的普遍规律由浅入深、由易到难地安排知识讲授的顺序，确定内容覆盖的范围。类似的，一本根据学习者的思维习惯，循序渐进地讲授</span><span lang="en-us" xml:lang="en-us">Java</span><span>语言设计思想的书籍（如著名的《</span><span lang="en-us" xml:lang="en-us">Java</span><span>编程思想》）显然比一部罗列</span><span lang="en-us" xml:lang="en-us">Java</span><span>语言语法特性的标准文献（如</span><span lang="en-us" xml:lang="en-us">Sun</span><span>公司发布的《</span><span lang="en-us" xml:lang="en-us">Java</span><span>语言规范》）更能满足</span><span lang="en-us" xml:lang="en-us">IT</span><span>教学的需要。</span></p><p class="MsoNormalIndent"><span>正如一个学术观点极度偏激的教师不可能向学生揭示科学真理一样，客观和冷静也是所有优秀</span><span lang="en-us" xml:lang="en-us">IT</span><span>教材都应当持有的基本态度。在</span><span lang="en-us" xml:lang="en-us">IT</span><span>圈子里，各类技术除了发展迅猛以外，还兼有龙蛇混杂、良莠不齐的特点——我的意思是说在层出不穷的新技术和新理论中，可以作为精华留传后世的并不太多，有相当多的一部分新技术和新理论在诞生后不久就像过眼烟云一样随风飘散。在这一背景下，如果</span><span lang="en-us" xml:lang="en-us">IT</span><span>教材的编撰者比学生还容易被漂亮的广告词和时髦的技术术语迷惑，而不使用客观、冷静的眼光对相关领域里的理论和技术进行甄别和取舍，那么，</span><span lang="en-us" xml:lang="en-us">IT</span><span>教材的权威性和稳定性，还有</span><span lang="en-us" xml:lang="en-us">IT</span><span>教材市场的特异性就荡然无存了。</span></p><p class="MsoNormalIndent"><span>以上谈到的系统化程度、面向方法的教学、对学习过程的引导以及对技术的甄别和取舍等都是专业化</span><span lang="en-us" xml:lang="en-us">IT</span><span>教材应当着重考虑的问题。此外，仅就书籍的外在形式而言，</span><span lang="en-us" xml:lang="en-us">IT</span><span>教材也有足够的理由从普通的</span><span lang="en-us" xml:lang="en-us">IT</span><span>书籍中分化出来。据说，</span><span lang="en-us" xml:lang="en-us">1658</span><span>年捷克人科曼纽斯（</span><span lang="en-us" xml:lang="en-us">J. A. Comenius</span><span>）所著的《世界图画（</span><span lang="en-us" xml:lang="en-us">Orbis Sensualium Pictus</span><span>）》一书标志着现代意义上的教材形式正式诞生。无论这种说法可靠与否，科曼纽斯利用插图、评述等写作方法提高教材可读性的思路对今天的教材编撰者来说仍有相当重要的现实意义。例如，在大多数人的经验里，</span><span lang="en-us" xml:lang="en-us">IT</span><span>教材的一大特点是每章的课程之后大都附有课后习题，但只要稍加留意就能发现，在越来越多的现代教材中，课后习题正在发生重大的变革：开放式的、没有标准答案的习题已经成为了优秀教材的必备要素，传统的、仅用于重温课程内容的习题及其标准答案无法适应互动式教育模式的需要，正逐渐销声匿迹。类似的形式变革还包括：许多教材以空白表格、空白流程图、空白插页等方式为学生在课堂上动手实践预留了空间；教材正文中用不同的图示标记出每个知识点的学习难度，用不同的字体或颜色区分不同的方法体系；在每个学习阶段，教材都能随时指出读者应掌握的知识和方法要点；在前言中，针对不同类型、不同水平的读者，给出建议的学习方案；在参考资料的推介上，现代教材更注重网上资源和电子读物……还有一个颇为关键也很容易被人忽略的问题，一本好的教材，尤其是一本好的教科书最好能在出版时配有全套的辅助教学资料，这可能包括：一本用于指导和规范教学实践的教师手册，一套出色的习题库和案例集，一组配套的电子幻灯片，一个提供资料下载和技术支持的</span><span lang="en-us" xml:lang="en-us">Web</span><span>站点，等等。总而言之，活泼的语言、开放的形式、齐备的资料是专业化</span><span lang="en-us" xml:lang="en-us">IT</span><span>教材得以从</span><span lang="en-us" xml:lang="en-us">IT</span><span>书籍中“浮出海面”的关键因素，也是</span><span lang="en-us" xml:lang="en-us">IT</span><span>教育摆脱传统模式束缚，走向成熟的重要标志。</span></p><p class="MsoNormalIndent"><span>最后，还可以简单谈谈和影印版教材有关的话题。众所周知，影印版教材在国内的</span><span lang="en-us" xml:lang="en-us">IT</span><span>教材市场中占据了相当的份额，许多开展双语教学的院系也在课堂上大量选用影印版教材。这种现象没什么不好，但它的确暴露出了本土化专业教材的先天不足。事实上，我旁听过一些使用影印版教材的课程，当时，我的感觉是，这种课程在提高学生专业英语水平方面的作用要远大于其传授知识和方法的效能——如果再大胆一点，把课程的主讲人换成新东方的俞敏洪或是疯狂英语的李阳，授课效果想必还会成倍提高。我并不反对借鉴国外的先进成果，但直接引进的原文教材在教学方式和思维习惯上与国内的</span><span lang="en-us" xml:lang="en-us">IT</span><span>教育环境相距甚远，如果没有出色的讲师在授课时疏通、引导，学生们往往会听得一头雾水。这多半是一件迫不得已的事情，谁让我们的本土教材大多还停留在谭浩强版《</span><span lang="en-us" xml:lang="en-us">BASIC</span><span>语言》的层次上原地踏步呢？对于出版行业，本土优秀教材的缺失未必是一件坏事：这意味着潜在的市场机会，而细分市场上的商机又可以为特异化的产品带来巨大的发展空间。假如有识之士都能自觉地意识到这一问题的存在，并主动参与到本土化专业教材——当然也包括针对中国教育环境编写的英文教材——的开发中来，出版商、教师和学生的共同利益就可以得到更为有效的保障了。</span></p><p class="MsoNormalIndent"><span>如果说，</span><span lang="en-us" xml:lang="en-us">IT</span><span>教材和普通</span><span lang="en-us" xml:lang="en-us">IT</span><span>书籍之间的趋同会让图书市场因缺乏特色而委靡不振，让市场竞争在丧失差异优势的前提下日趋残酷，那么，</span><span lang="en-us" xml:lang="en-us">IT</span><span>教材在内容及形式上的异化和升华恐怕就是我们激活</span><span lang="en-us" xml:lang="en-us">IT</span><span>图书市场，丰富竞争环境的必然选择了。当然，完全从商业角度考虑也有舍本逐末之嫌——拿我自己来说，每每想起苏美尔人刻在泥板上的楔形文字，我就会无比坚定地认为，从根本上尊重教师和学生的使用需求，为他们提供高质量的、专业化的</span><span lang="en-us" xml:lang="en-us">IT</span><span>教材，这才是最重要和最有意义的事情。</span></p>                </div>                    </div>
638	 LaTeX常用功能	report  	1083517560	25887	Solstice	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p><font size="4">1. 段首缩进</font></p><p>　　中文习惯在段首缩进两格，在LaTeX中，<font color="#0000ff" face="Courier New">/parindent </font>表示段首缩进的长度，我们将它设置为当前字号的两个大写字母<font color="#a52a2a" face="Georgia">M</font>的宽度，大约正好是两个汉字的宽度：</p><p><font face="Courier New"><font color="#0000ff">/setlength</font>{<font color="#0000ff">/parindent</font>}{<font color="#ffa500">2em</font>}</font></p><p>LaTeX 默认每节的第一段的段首不缩进，这不符合中文排版习惯。我们希望正文的每一段都要缩进，使用<font color="#a52a2a" face="Courier New">indentfirst</font>宏包就可办到：</p><p><font face="Courier New"><font color="#0000ff">/usepackage</font>{<font color="#ffa500">indentfirst</font>}</font></p><p><font size="4">2. 段距行距</font></p><p>　　LaTeX 用<font color="#0000ff" face="Courier New">/baselineskip</font>表示当前的行距，其默认值大约是当前字号的1.2倍，如果当前字号是<font color="#a52a2a" face="Georgia">10pt</font>，那么<font color="#0000ff" face="Courier New">/baselineskip</font>是<font color="#a52a2a" face="Georgia">12pt</font>。这对英文排版是合适的，对中文就显得太拥挤了，因为英文正文多为小写字母，字高与小写的<font color="#a52a2a" face="Georgia">x</font>差不多（即<font color="#a52a2a" face="Georgia">1ex</font>）。如果字号为<font color="#a52a2a" face="Georgia">10pt</font>，那么<font color="#a52a2a" face="Georgia">1ex</font> =<font color="#a52a2a" face="Georgia">4.3pt</font>。我通常把行距设为字号的1.8倍：</p><p><font face="Courier New"><font color="#0000ff">/setlength</font>{<font color="#0000ff">/baselineskip</font>}{<font color="#ffa500">1.8em</font>}</font></p><p>这个值随时可以改，对更改点以后的文字有效。</p><p>　　LaTeX 用<font color="#0000ff" face="Courier New">/parskip</font>表示段距，我一般把它设为<font color="#a52a2a" face="Georgia">1ex</font>：</p><p><font face="Courier New"><font color="#0000ff">/setlength</font>{<font color="#0000ff">/parskip</font>}{<font color="#ffa500">1ex</font>}</font></p><p>注意这些修改长度的命令最好都放在正文区（即<font color="#0000ff" face="Courier New">/begin{document}</font>之后）。</p><p><font size="4">3. 页眉页脚</font></p><p>我通常用<font color="#a52a2a" face="Courier New">fancyhdr</font>宏包来设置页眉和页脚。</p><p><font face="Courier New"><font color="#0000ff"><font color="#000000" size="2">/documentclass[10pt, a4paper]{book}</font><br/>/usepackage</font>{<font color="#ffa500">fancyhdr</font>}</font></p><p>我们在 LaTeX 中先把 page style 设为<font color="#a52a2a" face="Courier New">fancy</font>，再设置这个style中的页眉和页脚。但是它默认每章的第一页的page style是<font color="#a52a2a" face="Courier New">plain</font>，需要单独处理。</p><p><font face="Courier New"><font color="#0000ff"><font color="#008000">% 设置 plain style 的属性<br/></font></font></font><font face="Courier New"><font color="#0000ff">/fancypagestyle</font>{<font color="#ffa500">plain</font>}{<font color="#008000">%</font><br/><font color="#0000ff">/fancyhf</font>{}                    <font color="#008000">% 清空当前设置<br/><br/>% 设置页眉 (head)</font></font><font face="Courier New"><br/><font color="#0000ff">/fancyhead</font>[RE]{<font color="#0000ff">/leftmark</font>}     <font color="#008000">% 在偶数页的右侧显示章名<br/></font><font color="#0000ff">/fancyhead</font>[LO]{<font color="#0000ff">/rightmark</font>}    <font color="#008000">% 在奇数页的左侧显示小节名<br/></font><font color="#0000ff">/fancyhead</font>[LE,RO]{~<font color="#ffa500">/thepage</font>~} <font color="#008000">% 在偶数页的左侧，奇数页的右侧显示页码<br/><br/>% 设置页脚：</font><font color="#000000"><font color="#008000">在每页的右下脚以斜体显示书名<br/></font><font color="#0000ff">/fancyfoot</font>[RO,RE]{<font color="#ff0000">/it</font> Typesetting with <font color="#0000ff">/LaTeX</font>}<br/><br/></font></font><font face="Courier New"><font color="#000000"><font color="#0000ff">/renewcommand</font>{<font color="#0000ff">/headrulewidth</font>}{<font color="#ffa500">0.7pt</font>} <font color="#008000">% 页眉与正文之间的水平线粗细</font><br/><font color="#0000ff">/renewcommand</font>{<font color="#0000ff">/footrulewidth</font>}{<font color="#ffa500">0pt</font>}<br/>}</font></font></p><p><font face="Courier New">/pagestyle{fancy}             <font color="#008000">% 选用 fancy style<br/>% 其余同 plain style</font><br/>/fancyhf{}                    <br/>/fancyhead[RE]{/leftmark}<br/>/fancyhead[LO]{/rightmark}<br/>/fancyhead[LE,RO]{~/thepage~}<br/>/fancyfoot[RO,RE]{<font color="#ff0000">/it</font> Typesetting with <font color="#0000ff">/LaTeX</font>}<br/>/renewcommand{/headrulewidth}{0.7pt}<br/>/renewcommand{/footrulewidth}{0pt}<br/></font><font face="Courier New"><br/><font color="#008000">% 设置章名和节名的显示方式</font><br/><font color="#0000ff">/renewcommand</font>{<font color="#ff0000">/chaptermark</font>}[1]{<font color="#0000ff">/markboth</font>{~第~<font color="#ffa500">/thechapter</font>~章~~~#1~}{}}<br/><font color="#0000ff">/renewcommand</font>{<font color="#ff0000">/sectionmark</font>}[1]{<font color="#0000ff">/markright</font>{~<font color="#ffa500">/thesection</font><font color="#000000">~~</font>#1~}{}}</font></p><p><font size="4">4. 章节标题</font></p><p>我通常用<font color="#a52a2a" face="Courier New">titlesec</font>宏包来设置正文中出现的章节标题的格式：</p><p><font face="Courier New"><font color="#0000ff">/usepackage</font>{<font color="#ffa500">titlesec</font>}</font></p><p>设置章名为右对齐，字号为<font color="#0000ff" face="Courier New">/Huge</font>，字型为黑体，章号用粗体，并设置间距：</p><p><font face="Courier New">/titleformat{/chapter}{/flushright/Huge/hei}{{/bf /thechapter}}{0pt}{}<br/>/titlespacing{/chapter}{0pt}{-20pt}{25pt}</font></p><p>设置节名的字号为<font color="#0000ff" face="Courier New">/Large</font>，字型为黑体，节号用粗体，并设置间距：</p><p><font face="Courier New">/titleformat{/section}{/Large /hei }{{/bf /thesection/space}}{0pt}{}<br/>/titlespacing*{/section}{0pt}{1ex plus .3ex minus .2ex}{-.2ex plus .2ex}</font></p><p><font face="Courier New">其中<font color="#0000ff">/hei</font>的定义为：</font></p><p><font face="Courier New"><font color="#0000ff">/newcommand</font>{<font color="#0000ff">/hei</font>}{<font color="#0000ff">/CJKfamily</font>{hei}}</font></p><p><font size="4">5. 纸张大小</font></p><p>毕业论文要求用b5纸，单面打印，我用<font color="#a52a2a" face="Courier New">geometry</font>宏包来设置纸张和版心大小：</p><p><font face="Courier New">/documentclass[10pt, b5paper]{report}<br/>/usepackage[body={12.6cm, 20cm}, centering, dvipdfm]{geometry}<br/><font color="#008000">% 以上将版心宽度设为 12.6cm，高度 20cm，版心居中，且自动设置PDF文件的纸张大小。</font></font><br/></p><p> </p>                </div>                    </div>
823	 成功项目的杀手：领导意志	工作  企业应用  算法  申诉  微软  浏览器  	1085755860	1011	jeanger	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p align="right" class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span style="font-family:'宋体';"><font size="4">(原载《程序员》杂志)</font></span></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><font size="4"><span style="font-family:'宋体';">项目经理最害怕的是什么？往往不是与用户交流时的需求的复杂性，甚至早期需求的频繁变更也不是他们所担忧的主要问题。他们最担忧的往往是客户方的主管领导的意志。</span><span lang="en" xml:lang="en">&lt;?xml:namespace prefix = o ns = "urn:schemas-microsoft-com:office:office" /&gt;</span></font></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><font size="4"><span style="font-family:'宋体';">大家知道，项目付款前的一项重要的工作是由主管领导参与的项目验收汇报会，项目的成败往往在此一举，所以许多软件公司一般会请对项目的细节了如指掌，操作熟练，表达能力超群的人员担任讲解员。主管领导一般对项目的细节不会去了解，当然也没有时间去了解，但他对项目却绝对具有至高无上的发言权。</span><span lang="en" xml:lang="en"></span></font></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><font size="4"><span style="font-family:'宋体';">中国的软件项目在做的过程中，往往颇具黑色幽默。项目经理们为了迎合领导的喜好，往往不得不将领导的权利延伸到软件项目中来，使得软件在开发过程中，数据逻辑和工作流陷入前所未有的困境。</span><span lang="en" xml:lang="en"></span></font></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><font size="4"><span style="font-family:'宋体';">领导参与软件的操作，往往希望自己能够为所欲为，不但要赋予他至高无上的权限，还希望他的操作不能留下任何把柄，即在系统日志中不能够有任何记录。领导的参与使用，使得项目的权限变得混乱，工作流程和规范形同虚设，更为严重的是数据的一致性往往得不到保障。</span><span lang="en" xml:lang="en"></span></font></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><font size="4"><span style="font-family:'宋体';">我曾经负责一个油田项目的开发，现在想起来还是一场恶梦！不过通过分析这个案例，我们可以知道，中国的企业应用还面临着别样的困境。</span><span lang="en" xml:lang="en"></span></font></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span style="font-family:'宋体';"><font size="4">项目背景：<span lang="en" xml:lang="en"></span></font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span style="font-family:'宋体';"><font size="4">为叙述方便，我姑且称这个油田为塔河油田（为了引起的不必要的麻烦，这当然是个化名），塔河油田的最大资源是国家的石油，关于石油有太多的工作要做，勘探，测井，钻井，固井等等。油田下面有许多部门，其中最要害的部门是油田的开发事业部，负责油田里面所有的项目的申报，招标和项目实施。油田里面的所有项目并不是由油田下属的专业公司来做（当然即便都给他们做，他们也做不完），而是面向国内外所有具有相关资质的公司公开招标。全国各地便有许多公司的许多施工队伍专门驻扎在油田，常年施工，这些施工单位统称为乙方队伍。大家知道，油田里面的项目动辄上千万，少则几十万，给那个公司做不给那个公司做完全由开发事业部决定。为了减少人为决策因素，油田开发事业部决定开发这么一套系统，能够对乙方施工队伍进行管理，考核，从而让系统提供决策依据。<span lang="en" xml:lang="en"></span></font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span style="font-family:'宋体';"><font size="4">系统方案由北京的某咨询公司提供，由几个学管理学的博士设计了对队伍进行考核的方案，算法复杂无比，在此姑且不提。<span lang="en" xml:lang="en"></span></font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span style="font-family:'宋体';"><font size="4">我们现在做的这套系统名为“塔河油田开发事业部乙方队伍管理系统”，系统除了要管理乙方队伍的相关信息以外，还要能够对乙方队伍实行初审，年审，和进行最关键的作业考核（即施工队伍的业绩考评），除此之外，系统还要能进行网上招标，系统自动推荐优秀队伍参与招标的功能（根据队伍的各项审查和考核成绩，成绩是通过一些复杂的算法得到，在此不表）。<span lang="en" xml:lang="en"></span></font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span style="font-family:'宋体';"><font size="4">大家可能已经看清楚了，考核分数直接关系到一个队伍能否承接某个项目，能否参与网上招标。那么一个队伍的分数又是如何确定的呢？按照系统方案中的设计，是由各个分管该类型队伍的专业科室通过系统提供的打分界面（浏览器）打分决定（这里的打分不是直接对某个队伍给一个<span lang="en" xml:lang="en">70，80这样的分数，而是对该队伍在各个方面（考核指标）的表现选择一个定性的描述，然后系统按照这些考核指标的权值，通过复杂的计算，得出该队伍的分数）。</span></font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span lang="en" style="font-family:'宋体';" xml:lang="en"><font size="4"> </font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span style="font-family:'宋体';"><font size="4">项目组的兄弟们苦熬数月，在项目临近验收的前夕，终于实现了全部功能。整个系统的逻辑，数据经过反复测试，真觉得天衣无缝了。这时，项目负责人（实际上是项目的联系人，我才是具体负责开发的）在验收的前夕，想先给主管领导看看。当时我在场，演示讲解了半天，反正领导就是不满意，也不说哪里有问题，害我在哪里琢磨了大半天。<span lang="en" xml:lang="en"></span></font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span lang="en" style="font-family:'宋体';" xml:lang="en"><font size="4"> </font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span style="font-family:'宋体';"><font size="4">后来下来了，项目负责人说，领导的意思是说，怎样杜绝专业科室因为收了某个队伍的好处，而给该队伍抬高分数的情况。我听了，马上傻乎乎地进行了一番辩解（因为队伍的考核分数不是由某一个专业科室完全决定的，还有安全科等其它的配套管理科室的分数也很重要，并且对评分人，系统日志中都做了详细的记录。如果发现分数与实际情况不符，如，现实中明明<span lang="en" xml:lang="en">A队伍的口碑和业绩要强于B队伍，得到的分数却比B队伍少，乙方队伍可以在线申诉，从而取消某个考核员的资格）。听了我的辩解，负责人还是笑着摇头，说你没有明白领导的意思。我马上恍然大悟了！原来我们的系统设计得太公平，过去由领导决定的事情（如决定哪些队伍参与招标，项目考核验收是否通过），现在全由机器做了，这叫他怎么受的了，怎么会满意我们的系统！</span></font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span lang="en" style="font-family:'宋体';" xml:lang="en"><font size="4"> </font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span style="font-family:'宋体';"><font size="4">问题已经出来了，怎么办？项目小组连夜召开紧急会议，答案是：改！给主管领导权限，所有的分数他想怎么改就怎么改。又经过<span lang="en" xml:lang="en">2周的艰苦奋战，总算完成了任务，此时项目已经超过了预定日期。这次，项目负责人乐滋滋地把新方案给领导看，这次领导看得笑逐颜开，非常满意。然而，然而新问题又出来了，当查询日志的时候，领导所干的哪些个昧心事儿，清清楚楚的记录在案。并且主管领导不止一位，如何平衡他们的权利。项目负责人又一次象霜打的茄子，没精打采地回来了。</span></font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span lang="en" style="font-family:'宋体';" xml:lang="en"><font size="4"> </font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span style="font-family:'宋体';"><font size="4">以后的日子，大家都已经可以猜出来了，整个项目就围绕着这些与软件和技术无关的因素展开，通过权限标志位判断，如果是主管领导，系统日志对他们做的事情也不能记录，分管领导，系统日志记录一部分信息。总之，我的感觉是，一个好端端的项目，完全变成了领导们的权利的角斗场。<span lang="en" xml:lang="en"></span></font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span style="font-family:'宋体';"><font size="4">尽管项目严重超期，但是因为所做的工作领导满意，不但没有罚钱，反而还多加了<span lang="en" xml:lang="en">10万圆的开发费和维护费。</span></font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span lang="en" style="font-family:'宋体';" xml:lang="en"><font size="4"> </font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span style="font-family:'宋体';"><font size="4">最搞笑的是，最后项目培训的时候，分<span lang="en" xml:lang="en">4批人对他们进行操作培训，所讲的内容都不一样，尽量让每一批人都感觉出他们在生活中的权利，在系统中都一样存在和拥有。油田领导还要求公司对培训内容严格保密，否则将处以重罚！</span></font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span lang="en" style="font-family:'宋体';" xml:lang="en"><font size="4"> </font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span style="font-family:'宋体';"><font size="4">在我看来，这个项目如果不进行后期的修改，将是一个非常成功的项目（所以我一直保留的是第一版的源代码，对后面版本的源代码我认为几乎是垃圾），因为它达到了企业开发此项目的根本目的，即减少人为因素对队伍评价，考核以及项目招标的影响。<span lang="en" xml:lang="en"></span></font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span lang="en" style="font-family:'宋体';" xml:lang="en"><font size="4"> </font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span style="font-family:'宋体';"><font size="4">我们知道，企业信息化的根本目的除了减少各部门之间的通讯费用，提高办事效率以外，还有一个重要的因素就是能够提供一个相对公开公平的办公环境，尽量减少暗箱操作。然而，这样一个成功的项目，因为领导意志的干预，最后变成了一个看似对乙方队伍公平，实则是将这种不公平更加隐蔽化的，与企业信息化的目的背道而驰的权利的角斗场。这样一个案例不能不引起我们的深思和玩味。<span lang="en" xml:lang="en"></span></font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span style="font-family:'宋体';"><font size="4">项目经理们经常在一起笑谈，我们其实是在面向领导开发，而不是面向最终用户。（当然领导也是用户），只有领导满意的项目才是成功的项目啊！<span lang="en" xml:lang="en"></span></font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en" style="font-family:'宋体';" xml:lang="en"><font size="4"> </font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span style="font-family:'宋体';"><font size="4">软件公司一般都会拼命想法满足企业用户的需求，而决不会因为这个软件本身违反了某些公正性或道德而拒绝实施。只要企业愿意出钱，什么样的违法乱纪的功能都可以给你做出来，这就涉及到了一个新的课题，软件伦理或软件道德的问题，国内软件道德的话题还仅仅停留在软件的非法使用的层面，还没有关注到软件本身。假设一个软件本身是用来达到某种不可告人的目的或卑鄙的企图，这样的软件我们究竟做还是不做？这是摆在我们所有软件公司和从业人员面前的问题。<span lang="en" xml:lang="en"></span></font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span lang="en" style="font-family:'宋体';" xml:lang="en"><font size="4"> </font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span style="font-family:'宋体';"><font size="4">做完这个项目，我觉得自己成了一个无耻的程序员，干了一件为虎作伥的事情。程序员是不是只应该关注技术问题，而不用考虑其它的道德问题特别是软件本身的道德问题呢？我想大多数程序员会说，我管其它的东东干什么，我考虑的只有两个字，“实现”。<span lang="en" xml:lang="en"></span></font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span lang="en" style="font-family:'宋体';" xml:lang="en"><font size="4"> </font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span style="font-family:'宋体';"><font size="4">就像微软，在操作系统中留有后门（未经证实）的情况，人们纷纷谴责微软违背了软件道德一样。软件本身的道德问题有何办法约束和保证呢？当然，我们绝不可能指望软件公司高风亮节，在利益面前不为所动，义正言辞地拒绝这类软件方案的实施。<span lang="en" xml:lang="en"></span></font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span lang="en" style="font-family:'宋体';" xml:lang="en"><font size="4"> </font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span style="font-family:'宋体';"><font size="4">我想起了“电脑算命”的例子，明明是迷信，非要披上高科技的外衣。而我所做的这个项目，尽管为公司赢得了不菲的利润，但和电脑算命不是有着共通之处吗？本来是为了杜绝人为因素或腐败，然而却使腐败行为和人为因素隐藏得更深，领导可以堂而皇之的说是系统确定的招标队伍。<span lang="en" xml:lang="en"></span></font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span lang="en" style="font-family:'宋体';" xml:lang="en"><font size="4"> </font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span style="font-family:'宋体';"><font size="4">我们不妨往深里面思考一下，为什么那么多好的<span lang="en" xml:lang="en">ERP项目在中国得不到很好的实施？为什么市场上那么多依照工作流的，非常规范的财务，管理软件，许多企业就是不愿意花钱购买？而听任企业停留在人为因素极大的管理模式之下。</span></font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span lang="en" style="font-family:'宋体';" xml:lang="en"><font size="4"> </font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span style="font-family:'宋体';"><font size="4">下面是另一个与此相关的故事，某大型电力公司为了加速企业信息化，从德国一家大型软件公司（该公司提供大型电力企业<span lang="en" xml:lang="en">ERP解决方案）购买部署了一套系统，在试用阶段使用以后大家都不满意，觉得不符合“中国的国情”（我对“中国的国情”这一提法，一直抱有轻蔑和疑问，不明白中国究竟有什么特别之处，无法接纳人家先进的管理思想和技术！这一名词在今天也变成了许多人拒绝和世界接轨的挡箭牌！），于是，向德国公司提了一系列的修改方案和建议（只要修改，还同意在原软件价格的基础上加一部分费用）。然而出人意料的是，德国公司拒绝修改，你可以不买我的产品,我不会破坏软件的工作流和规范的逻辑。因为这样的工作流规范几乎运用在欧洲所有的电厂。最后该电力公司领导竟然放弃了这套软件，转而找某电力大学开发了一套“中国特色”的ERP系统。</span></font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span lang="en" style="font-family:'宋体';" xml:lang="en"><font size="4"> </font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span style="font-family:'宋体';"><font size="4">我们知道，软件决不仅仅是日常工作的电脑化操作，还承担着规范人们和企业经营行为的重任，关键在于领导是否有决心和信心真正想提高企业的管理决策水平，舍得放弃一些个人权利和利益。<span lang="en" xml:lang="en"></span></font></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span lang="en" style="font-family:'宋体';" xml:lang="en"><font size="4"> </font></span></p><p></p><span style="font-size:10.5pt;font-family:'宋体';"><font size="4">所以说，领导的权利意志，往往是中国企业信息化的过程中最大的障碍。也是成功软件项目的最大杀手！</font></span>                </div>                    </div>
1690	 腾讯上市马化腾6年创业身家9亿	腾讯  创业  qq  互联网  网络  游戏  	1087666800	4172	zdg	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span style="font-size:9pt;color:#990000;font-family:'宋体';">【</span><span lang="en" style="font-size:9pt;color:#990000;" xml:lang="en">2004.06.17 </span><span style="font-size:9pt;color:#990000;font-family:'宋体';">】</span><span lang="en" style="font-size:9pt;color:#990000;" xml:lang="en">21</span><span style="font-size:9pt;color:#990000;font-family:'宋体';">世纪经济报道</span><span lang="en" style="font-size:9pt;color:#FF0000;" xml:lang="en"> &lt;?xml:namespace prefix = o ns = "urn:schemas-microsoft-com:office:office" /&gt;</span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;"><strong><span lang="en" xml:lang="en"></span></strong></p><p><strong> </strong></p><strong></strong> <p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt;line-height:15pt;text-align:left;"><span style="font-family:'宋体';">网络造富神话再次显现。这一次，轮到了</span><span lang="en" xml:lang="en">QQ</span><span style="font-family:'宋体';">的主人腾讯。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　</span><span lang="en" xml:lang="en">6</span><span style="font-family:'宋体';">月</span><span lang="en" xml:lang="en">16</span><span style="font-family:'宋体';">日，腾讯控股</span><span lang="en" xml:lang="en">(700.HK)</span><span style="font-family:'宋体';">在香港联交所正式挂牌交易。根据其每股</span><span lang="en" xml:lang="en">3.70</span><span style="font-family:'宋体';">美元的发行价计算，腾讯拥有</span><span lang="en" xml:lang="en">62.2</span><span style="font-family:'宋体';">亿港元的市值。</span><span> <span lang="en" xml:lang="en"> <script src="http://www.homeway.com.cn/ad/news/pic.js" type="text/javascript"><!--//--><![CDATA[//><!--//--><!]]></script></span></span></p><p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span style="font-family:'宋体';">　　斯次上市，腾讯造就了</span><span lang="en" xml:lang="en">5</span><span style="font-family:'宋体';">个亿万富翁，</span><span lang="en" xml:lang="en">7</span><span style="font-family:'宋体';">个千万富翁。根据持股比例，马化腾因持有</span><span lang="en" xml:lang="en">14.43%</span><span style="font-family:'宋体';">的股权，账面财富是</span><span lang="en" xml:lang="en">8.98</span><span style="font-family:'宋体';">亿港元；张志东拥有</span><span lang="en" xml:lang="en">6.43%</span><span style="font-family:'宋体';">的股权，账面财富为</span><span lang="en" xml:lang="en">4</span><span style="font-family:'宋体';">亿港元；另外三位高层曾李青、许晨晔、陈一丹共持有</span><span lang="en" xml:lang="en">9.87%</span><span style="font-family:'宋体';">的股权，三人的财富合约</span><span lang="en" xml:lang="en">6.14</span><span style="font-family:'宋体';">亿港元。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　此外，腾讯的其他</span><span lang="en" xml:lang="en">7</span><span style="font-family:'宋体';">位高层拥有着另外的</span><span lang="en" xml:lang="en">6.77%</span><span style="font-family:'宋体';">股权，</span><span lang="en" xml:lang="en">7</span><span style="font-family:'宋体';">人共有财富</span><span lang="en" xml:lang="en">4.22</span><span style="font-family:'宋体';">亿港元。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　腾讯最大的股东</span><span lang="en" xml:lang="en">MIH</span><span style="font-family:'宋体';">集团</span><span lang="en" xml:lang="en">(</span><span style="font-family:'宋体';">米拉德国际控股集团公司</span><span lang="en" xml:lang="en">)</span><span style="font-family:'宋体';">更是大获其利。</span><span lang="en" xml:lang="en">MIH</span><span style="font-family:'宋体';">为纳斯达克和阿姆斯特丹两地上市公司，最主要的业务在南非，是南非最大的付费电视运营商。</span><span lang="en" xml:lang="en">MIH</span><span style="font-family:'宋体';">在</span><span lang="en" xml:lang="en">2001</span><span style="font-family:'宋体';">年</span><span lang="en" xml:lang="en">6</span><span style="font-family:'宋体';">月接手腾讯</span><span lang="en" xml:lang="en">46.5%</span><span style="font-family:'宋体';">的股权。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　根据</span><span lang="en" xml:lang="en">MIH</span><span style="font-family:'宋体';">的财务报告，</span><span lang="en" xml:lang="en">MIH</span><span style="font-family:'宋体';">从盈科数码、</span><span lang="en" xml:lang="en">IDG</span><span style="font-family:'宋体';">、以及管理层手中收购腾讯</span><span lang="en" xml:lang="en">46.5%</span><span style="font-family:'宋体';">的股份，花费</span><span lang="en" xml:lang="en">3200</span><span style="font-family:'宋体';">万美元，其中向盈科数码支付</span><span lang="en" xml:lang="en">1260</span><span style="font-family:'宋体';">万美金。收购后，腾讯管理层持股</span><span lang="en" xml:lang="en">46.5%</span><span style="font-family:'宋体';">，</span><span lang="en" xml:lang="en">IDG</span><span style="font-family:'宋体';">持股</span><span lang="en" xml:lang="en">7%</span><span style="font-family:'宋体';">。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　即使后来</span><span lang="en" xml:lang="en">IDG</span><span style="font-family:'宋体';">持有</span><span lang="en" xml:lang="en">7%</span><span style="font-family:'宋体';">的股权被平分为二卖给了管理层和</span><span lang="en" xml:lang="en">MIH</span><span style="font-family:'宋体';">，</span><span lang="en" xml:lang="en">MIH</span><span style="font-family:'宋体';">可能为此又付出了几百万美元。也就是说，</span><span lang="en" xml:lang="en">MIH</span><span style="font-family:'宋体';">的总投资超过</span><span lang="en" xml:lang="en">4000</span><span style="font-family:'宋体';">万美元。但如今，</span><span lang="en" xml:lang="en">MIH</span><span style="font-family:'宋体';">拥有的腾讯市值却高达</span><span lang="en" xml:lang="en">23.33</span><span style="font-family:'宋体';">亿港元，</span><span lang="en" xml:lang="en">3</span><span style="font-family:'宋体';">年时间，</span><span lang="en" xml:lang="en">MIH</span><span style="font-family:'宋体';">的投资获得了</span><span lang="en" xml:lang="en">7</span><span style="font-family:'宋体';">倍的升值。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　如果假设当初</span><span lang="en" xml:lang="en">IDG</span><span style="font-family:'宋体';">和盈科持有的股份到现在都不卖出，那么两者获得的投资收益将会高达</span><span lang="en" xml:lang="en">70</span><span style="font-family:'宋体';">倍。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　<strong>寻找盈利模式</strong></span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　然而，历史不能假设。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　其实，在腾讯</span><span lang="en" xml:lang="en">5</span><span style="font-family:'宋体';">岁半的生命中，曾经有一半时间在找不到赚钱的盈利模式中挣扎，谁又能想到后来它竟</span><span lang="en" xml:lang="en">“</span><span style="font-family:'宋体';">日进斗金</span><span lang="en" xml:lang="en">”</span><span style="font-family:'宋体';">？</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　</span><span lang="en" xml:lang="en">1998</span><span style="font-family:'宋体';">年</span><span lang="en" xml:lang="en">11</span><span style="font-family:'宋体';">月，同为大学同学的马化腾和张志东决定下海做生意，于是，创建腾讯。最初业务是为一些寻呼台做系统集成。两人既当销售，又做工程师，而后来风靡全国的</span><span lang="en" xml:lang="en">QQ</span><span style="font-family:'宋体';">软件在当年竟是随项目赠送的副产品。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　</span><span lang="en" xml:lang="en">QQ</span><span style="font-family:'宋体';">因而被最早命名为</span><span lang="en" xml:lang="en">“</span><span style="font-family:'宋体';">网上中文寻呼机</span><span lang="en" xml:lang="en">”</span><span style="font-family:'宋体';">，简称</span><span lang="en" xml:lang="en">OICQ</span><span style="font-family:'宋体';">。无论从各方面看，</span><span lang="en" xml:lang="en">OICQ</span><span style="font-family:'宋体';">都是当年马化腾模仿</span><span lang="en" xml:lang="en">ICQ</span><span style="font-family:'宋体';">的一个随兴之作。当年的</span><span lang="en" xml:lang="en">ICQ</span><span style="font-family:'宋体';">已经席卷全球，但却没有中文版，</span><span lang="en" xml:lang="en">PICQ</span><span style="font-family:'宋体';">、</span><span lang="en" xml:lang="en">CICQ</span><span style="font-family:'宋体';">等中文即时通信软件已经出现，但却没有有效打开市场。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　确切的原因已经不可知，也许是马化腾看到了</span><span lang="en" xml:lang="en">ICQ</span><span style="font-family:'宋体';">以</span><span lang="en" xml:lang="en">2.87</span><span style="font-family:'宋体';">亿美元的</span><span lang="en" xml:lang="en">“</span><span style="font-family:'宋体';">天价</span><span lang="en" xml:lang="en">”</span><span style="font-family:'宋体';">从以色列卖到美国，也许是看到了高喊免费的</span><span lang="en" xml:lang="en">.com</span><span style="font-family:'宋体';">公司在大洋彼岸掀起的股市高潮，也许是看到了中国第一批网络英雄们的风起云涌，在</span><span lang="en" xml:lang="en">1999</span><span style="font-family:'宋体';">年初的某一天，</span><span lang="en" xml:lang="en">OICQ</span><span style="font-family:'宋体';">软件忽然被挂在了网上，由定向赠送变成了免费下载。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　凭借其简洁、实用的风格以及诸项细心的设计，</span><span lang="en" xml:lang="en">OICQ</span><span style="font-family:'宋体';">首先在高校一炮打响，然后凭借高校为中心，以令人吃惊的速度传播开来。</span><span lang="en" xml:lang="en">PICQ</span><span style="font-family:'宋体';">、</span><span lang="en" xml:lang="en">CICQ</span><span style="font-family:'宋体';">等对手几乎不堪一击。这时的腾讯，一边继续开发着项目，一边用赚来的钱养活着</span><span lang="en" xml:lang="en">OICQ</span><span style="font-family:'宋体';">。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　然而，</span><span lang="en" xml:lang="en">OICQ</span><span style="font-family:'宋体';">的用户数的几何级增长，让是否能养活</span><span lang="en" xml:lang="en">OICQ</span><span style="font-family:'宋体';">的问题变得严峻起来，每月以几何级增长的服务器托管费用也让腾讯不堪承受。马化腾后来回忆起当时的情景时说，想卖掉</span><span lang="en" xml:lang="en">OICQ</span><span style="font-family:'宋体';">，卖了好多次没卖掉，只能另谋生计。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　这个计策即是融资。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　</span><span lang="en" xml:lang="en">2000</span><span style="font-family:'宋体';">年初，凭借</span><span lang="en" xml:lang="en">OICQ</span><span style="font-family:'宋体';">仅半年就占领的市场地位，腾讯幸运地拉来</span><span lang="en" xml:lang="en">IDG</span><span style="font-family:'宋体';">和李泽楷旗下盈科数码</span><span lang="en" xml:lang="en">220</span><span style="font-family:'宋体';">万美元的投资，占股</span><span lang="en" xml:lang="en">40%</span><span style="font-family:'宋体';">。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　尽管有了一笔钱，暂时没有生死存亡的忧虑。但是，</span><span lang="en" xml:lang="en">OICQ</span><span style="font-family:'宋体';">的注册人数继续以陡峭的曲线疯长，</span><span lang="en" xml:lang="en">OICQ</span><span style="font-family:'宋体';">的盈利模式却依然找不着，实际上</span><span lang="en" xml:lang="en">OICQ</span><span style="font-family:'宋体';">的先驱</span><span lang="en" xml:lang="en">ICQ</span><span style="font-family:'宋体';">也一直都没有盈利模式。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　腾讯探寻</span><span lang="en" xml:lang="en">OICQ</span><span style="font-family:'宋体';">的盈利模式从网络广告开始，在</span><span lang="en" xml:lang="en">2000</span><span style="font-family:'宋体';">年</span><span lang="en" xml:lang="en">7</span><span style="font-family:'宋体';">月</span><span lang="en" xml:lang="en">25</span><span style="font-family:'宋体';">日的新一版软件中，一个</span><span lang="en" xml:lang="en">BANNER</span><span style="font-family:'宋体';">广告条被塞在消息接收端中。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　尽管腾讯的网络广告销售开展得很不错，曾经在《网络广告先锋》的调查中排第三位，紧跟新浪搜狐之后。但是，相对于每天新增注册用户几十万</span><span lang="en" xml:lang="en">(</span><span style="font-family:'宋体';">最高时每天新增用户曾达</span><span lang="en" xml:lang="en">80</span><span style="font-family:'宋体';">万</span><span lang="en" xml:lang="en">)</span><span style="font-family:'宋体';">、一个月就要新加两台服务器的投入而言，网络广告有点杯水车薪。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　整个</span><span lang="en" xml:lang="en">2000</span><span style="font-family:'宋体';">年，腾讯都在两个传言中度过：传言之一是腾讯将要全面收费；传言之二是腾讯要被卖掉，收购方是</span><span lang="en" xml:lang="en">TOM</span><span style="font-family:'宋体';">或脉搏网。这两个传言都和腾讯</span><span lang="en" xml:lang="en">“</span><span style="font-family:'宋体';">快没钱了</span><span lang="en" xml:lang="en">”</span><span style="font-family:'宋体';">有关，并且，对</span><span lang="en" xml:lang="en">“</span><span style="font-family:'宋体';">快没钱了</span><span lang="en" xml:lang="en">”</span><span style="font-family:'宋体';">的佐证是，</span><span lang="en" xml:lang="en">OICQ</span><span style="font-family:'宋体';">软件停止了免费的新用户注册。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　<strong>移动梦网带来的价值突围</strong></span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　</span><span lang="en" xml:lang="en">2000</span><span style="font-family:'宋体';">年底中国移动推出</span><span lang="en" xml:lang="en">“</span><span style="font-family:'宋体';">移动梦网</span><span lang="en" xml:lang="en">”</span><span style="font-family:'宋体';">的一瞬，它也许不知道，这一创新性的价值链条会挽救一批互联网公司。腾讯就在这批名单的前列。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　当时，腾讯的情况是，拥有逼近亿级的互联网注册用户量，而且这些用户中是含有大量的消费诉求的，但是，腾讯却苦于没有收费的渠道。然而，移动梦网通过手机代收费的</span><span lang="en" xml:lang="en">“</span><span style="font-family:'宋体';">二八分账</span><span lang="en" xml:lang="en">”</span><span style="font-family:'宋体';">协议</span><span lang="en" xml:lang="en">(</span><span style="font-family:'宋体';">运营商分二成、</span><span lang="en" xml:lang="en">SP</span><span style="font-family:'宋体';">分八成</span><span lang="en" xml:lang="en">)</span><span style="font-family:'宋体';">，犹如一道闪电，惊醒蛰伏的腾讯。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　腾讯迅速开展了收费会员业务，限制页面注册，并开展了移动</span><span lang="en" xml:lang="en">QQ</span><span style="font-family:'宋体';">业务，一时间，腾讯成了移动梦网的骨干，在移动梦网中的份额最高时占据了七成。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　腾讯赚钱的速度和它当初注册用户的疯长一样，仅到</span><span lang="en" xml:lang="en">2001</span><span style="font-family:'宋体';">年</span><span lang="en" xml:lang="en">7</span><span style="font-family:'宋体';">月，腾讯就实现了正现金流，到</span><span lang="en" xml:lang="en">2001</span><span style="font-family:'宋体';">年年底，腾讯实现了</span><span lang="en" xml:lang="en">1022</span><span style="font-family:'宋体';">万人民币的纯利润。其间，在</span><span lang="en" xml:lang="en">2001</span><span style="font-family:'宋体';">年</span><span lang="en" xml:lang="en">3</span><span style="font-family:'宋体';">月份，腾讯为了应付</span><span lang="en" xml:lang="en">ICQ</span><span style="font-family:'宋体';">的版权官司，将软件名称改为了</span><span lang="en" xml:lang="en">QQ</span><span style="font-family:'宋体';">。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　腾讯业绩的增长速度在</span><span lang="en" xml:lang="en">2002</span><span style="font-family:'宋体';">年和</span><span lang="en" xml:lang="en">2003</span><span style="font-family:'宋体';">年开始令人炫目，这两年腾讯一方面推出</span><span lang="en" xml:lang="en">QQ</span><span style="font-family:'宋体';">行、</span><span lang="en" xml:lang="en">QQ</span><span style="font-family:'宋体';">秀等一些新业务，另一方面又不断学习，比如学着新浪推短信和铃声、学着网易推出交友业务</span><span lang="en" xml:lang="en">QQ</span><span style="font-family:'宋体';">男女、学着盛大开展网络游戏。在</span><span lang="en" xml:lang="en">2002</span><span style="font-family:'宋体';">年，腾讯净利润是</span><span lang="en" xml:lang="en">1.44</span><span style="font-family:'宋体';">亿，比上一年增长</span><span lang="en" xml:lang="en">10</span><span style="font-family:'宋体';">倍之多；</span><span lang="en" xml:lang="en">2003</span><span style="font-family:'宋体';">年，腾讯净利润为</span><span lang="en" xml:lang="en">3.38</span><span style="font-family:'宋体';">亿，比</span><span lang="en" xml:lang="en">2002</span><span style="font-family:'宋体';">年又翻了近一倍。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　据腾讯的《招股说明书》显示，目前腾讯的主要盈利被划分成了三部分，即互联网增值服务</span><span lang="en" xml:lang="en">(</span><span style="font-family:'宋体';">包括会员服务、社区服务、游戏娱乐服务</span><span lang="en" xml:lang="en">)</span><span style="font-family:'宋体';">、移动及通信增值服务</span><span lang="en" xml:lang="en">(</span><span style="font-family:'宋体';">包括移动聊天、语音聊天、短信铃声等</span><span lang="en" xml:lang="en">)</span><span style="font-family:'宋体';">和网络广告。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　截至</span><span lang="en" xml:lang="en">2004</span><span style="font-family:'宋体';">年前三个月，前两部分的收入占据了腾讯总收入的</span><span lang="en" xml:lang="en">96.1%</span><span style="font-family:'宋体';">。因此，从广义的角度上讲，腾讯是一家</span><span lang="en" xml:lang="en">SP(</span><span style="font-family:'宋体';">内容提供商，目前确切的涵义外延有待确定</span><span lang="en" xml:lang="en">)</span><span style="font-family:'宋体';">，因为前两部分的收钱方式大多都是通过移动梦网的分成。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　腾讯的投资总监苏丽芬拒绝透露来自移动梦网的收入占总收入的比例，尽管腾讯有着一部分的会员卡和在线游戏点卡通过一些书摊、便利店来销售，但业内人士指出，九成以上的用户收费是通过移动梦网代收费。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　今年第一季度的数据统计显示，腾讯拥有</span><span lang="en" xml:lang="en">730</span><span style="font-family:'宋体';">万收费会员，其中高级会员每月向腾讯贡献</span><span lang="en" xml:lang="en">10</span><span style="font-family:'宋体';">元人民币，</span><span lang="en" xml:lang="en">“QQ</span><span style="font-family:'宋体';">行</span><span lang="en" xml:lang="en">”</span><span style="font-family:'宋体';">会员每月贡献</span><span lang="en" xml:lang="en">2</span><span style="font-family:'宋体';">元人民币；同时，腾讯拥有</span><span lang="en" xml:lang="en">1310</span><span style="font-family:'宋体';">万的注册短信用户。另外，非常</span><span lang="en" xml:lang="en">QQ</span><span style="font-family:'宋体';">男女、彩铃、图片等短信服务以各种形式获取利润。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　腾讯还有意参与</span><span lang="en" xml:lang="en">“</span><span style="font-family:'宋体';">互联星空</span><span lang="en" xml:lang="en">”</span><span style="font-family:'宋体';">这样的分成计划，通过视频</span><span lang="en" xml:lang="en">QQ</span><span style="font-family:'宋体';">或者</span><span lang="en" xml:lang="en">QQ</span><span style="font-family:'宋体';">游戏，腾讯可以从宽带运营商那里分得一部分收入。另外，腾讯企业</span><span lang="en" xml:lang="en">QQ</span><span style="font-family:'宋体';">是其另一雄心所在，通过定制运用企业</span><span lang="en" xml:lang="en">QQ</span><span style="font-family:'宋体';">，腾讯渴望来自企业的收入。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　腾讯还把</span><span lang="en" xml:lang="en">QQ</span><span style="font-family:'宋体';">的品牌</span><span lang="en" xml:lang="en">“</span><span style="font-family:'宋体';">租赁</span><span lang="en" xml:lang="en">”</span><span style="font-family:'宋体';">给了一家玩具企业，生产</span><span lang="en" xml:lang="en">QQ</span><span style="font-family:'宋体';">玩具，每年，腾讯为此获得固定收益。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　</span><strong><span lang="en" xml:lang="en">QQ</span><span style="font-family:'宋体';">未来：与所有的</span><span lang="en" xml:lang="en">.com</span><span style="font-family:'宋体';">们为敌？</span></strong><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　如果从狭义</span><span lang="en" xml:lang="en">SP</span><span style="font-family:'宋体';">的角度，即只去看移动增值服务，占腾讯总收入的比例却在逐步缩小。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　腾讯移动及通信增值服务部分的收入占总收入的比例</span><span lang="en" xml:lang="en">2002</span><span style="font-family:'宋体';">年为</span><span lang="en" xml:lang="en">75.6%</span><span style="font-family:'宋体';">，</span><span lang="en" xml:lang="en">2003</span><span style="font-family:'宋体';">年为</span><span lang="en" xml:lang="en">63.6%</span><span style="font-family:'宋体';">，到今年前三月，这一比例稳步下降到</span><span lang="en" xml:lang="en">55.5%</span><span style="font-family:'宋体';">，腾讯开始从</span><span lang="en" xml:lang="en">“</span><span style="font-family:'宋体';">纯</span><span lang="en" xml:lang="en">SP”</span><span style="font-family:'宋体';">的定位中脱身；同时，来自互联网增值服务的收入大幅上升，从</span><span lang="en" xml:lang="en">2001</span><span style="font-family:'宋体';">年占</span><span lang="en" xml:lang="en">15.5%</span><span style="font-family:'宋体';">的收入比例上升到今年前三月的</span><span lang="en" xml:lang="en">40.6%</span><span style="font-family:'宋体';">，其中来自网络游戏方面的收入应该功不可没。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　很早之前，马化腾就表示过</span><span lang="en" xml:lang="en">“</span><span style="font-family:'宋体';">移动业务只能体现我们核心价值的周边部分，基于</span><span lang="en" xml:lang="en">PC</span><span style="font-family:'宋体';">的增值服务才是我们的核心价值</span><span lang="en" xml:lang="en">”</span><span style="font-family:'宋体';">，那么，财务数据显示的腾讯盈利模式变动正印证着马化腾的这一说法。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　</span><span lang="en" xml:lang="en">“</span><span style="font-family:'宋体';">跟一般的短信</span><span lang="en" xml:lang="en">SP</span><span style="font-family:'宋体';">比较，腾讯最大的优势是在桌面上的垄断，那是命脉所在，也是核心竞争力。</span><span lang="en" xml:lang="en">”</span><span style="font-family:'宋体';">市场分析人士汉景奎说，汉</span><span lang="en" xml:lang="en">4</span><span style="font-family:'宋体';">年多来一直在关注腾讯的发展，并与包括马化腾在内的多位高层有过多次沟通。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　在此观点上分析，目前被誉为高风险的</span><span lang="en" xml:lang="en">SP</span><span style="font-family:'宋体';">，腾讯可能会离之越来越远，相反，就像财务报表中体现的，在互联网增值服务上的收入会越来越多。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　而在互联网增值服务上，</span><span lang="en" xml:lang="en">“</span><span style="font-family:'宋体';">腾讯未来可能会继续使用跟随战略。</span><span lang="en" xml:lang="en">”</span><span style="font-family:'宋体';">汉景奎对本报记者说，</span><span lang="en" xml:lang="en">“</span><span style="font-family:'宋体';">腾讯有点儿像是微软，掌握了巨量的用户资源。</span><span lang="en" xml:lang="en">”<br/><br/></span><span style="font-family:'宋体';">　　目前，</span><span lang="en" xml:lang="en">QQ</span><span style="font-family:'宋体';">有着</span><span lang="en" xml:lang="en">2.9</span><span style="font-family:'宋体';">亿的超大注册用户量，在此基础上，完全可以看到别人的成功后再去跟随，因为新开拓业务的成本会比较低。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　一个可以证明的例子就是</span><span lang="en" xml:lang="en">QQ</span><span style="font-family:'宋体';">游戏，从去年中期运营到现在</span><span lang="en" xml:lang="en">1</span><span style="font-family:'宋体';">年不到，投入资金并不多，但是由于和</span><span lang="en" xml:lang="en">QQ</span><span style="font-family:'宋体';">社区捆绑，一年不到便取得了和联众游戏近乎相当的规模量，这就是跟随战略的体现。另外，像过去开拓的铃声、短信、交友、校友录等服务，莫不是跟随战略的结果。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　而使用跟随战略的后果是，</span><span lang="en" xml:lang="en">“</span><span style="font-family:'宋体';">腾讯可能会与所有的</span><span lang="en" xml:lang="en">.COM</span><span style="font-family:'宋体';">为敌</span><span lang="en" xml:lang="en">”</span><span style="font-family:'宋体';">，</span><span lang="en" xml:lang="en">“</span><span style="font-family:'宋体';">因为腾讯的用户群和</span><span lang="en" xml:lang="en">.COM</span><span style="font-family:'宋体';">的用户群重合度很大</span><span lang="en" xml:lang="en">”</span><span style="font-family:'宋体';">。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　据《招股说明书》显示，此次腾讯</span><span lang="en" xml:lang="en">IPO</span><span style="font-family:'宋体';">，募集的超过</span><span lang="en" xml:lang="en">15</span><span style="font-family:'宋体';">亿的资金中的</span><span lang="en" xml:lang="en">2</span><span style="font-family:'宋体';">／</span><span lang="en" xml:lang="en">3</span><span style="font-family:'宋体';">将被用来拓展新业务。《招股说明书》中同时列举了新拓展业务的方向，其中的关键就是在互联网业务方面，这也暗合了分析人士对未来腾讯战略的看法。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　腾讯提到自己未来的互联网业务核心包括拓展</span><span lang="en" xml:lang="en">QQ</span><span style="font-family:'宋体';">游戏的门户网站、建立在线交友社区和建立垂直资讯网站；更加值得一提的是，腾讯提到了未来会参与到</span><span lang="en" xml:lang="en">“</span><span style="font-family:'宋体';">商业广告排名技术</span><span lang="en" xml:lang="en">”</span><span style="font-family:'宋体';">中去，联系到一直捆绑于</span><span lang="en" xml:lang="en">QQ</span><span style="font-family:'宋体';">的腾讯浏览器，腾讯要与</span><span lang="en" xml:lang="en">3721</span><span style="font-family:'宋体';">、百度这样的互联网公司一决雌雄的野心昭然若揭。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　通过免费注册获得大量用户，通过手机收费实现利润，然后进入其它赚钱的网络业务领域，这似乎是腾讯的发展逻辑。然而这一逻辑的基础还是活跃的巨量注册的用户。面对</span><span lang="en" xml:lang="en">QQ</span><span style="font-family:'宋体';">的收费，另一至今依然免费的即时通服务</span><span lang="en" xml:lang="en">——</span><span style="font-family:'宋体';">微软</span><span lang="en" xml:lang="en">MSN messager</span><span style="font-family:'宋体';">不能不成为</span><span lang="en" xml:lang="en">QQ</span><span style="font-family:'宋体';">的劲敌。</span><span lang="en" xml:lang="en"><br/><br/></span><span style="font-family:'宋体';">　　记者试图向马化腾本人求证腾讯发展策略，但拨通手机后，马婉拒了采访要求。</span></p>                </div>                    </div>
1796	 医院信息化发展调查研究报告（来自赛迪）	医疗  服务器  技术人  网络  产品  internet  	977117400	3332	jiangtao	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <strong>医院信息化发展调查研究报告（来自赛迪）<br/></strong>　医院信息化发展调查研究报告 <br/>（ 作者：赛迪顾问　2000年12月05日 11:52 ） <br/><br/>　　信息技术的应用对医疗卫生行业来说并不是新事物，特别是我国1995年开始的“金卫工程”推动了医疗卫生行业信息化的建设，提高了医务人员的工作效率，加快了病人就诊的速度，根除了“三长一短”（挂号、收费、取药时间长、医生看病时间短）的弊病，有效地解决了看病难的问题，堵住了收费、药品管理中的漏洞。使医院医疗质量随着信息化程度的提高得到了前所未有的进步，同时也为全国大中小型医院的信息化建设创造了良好的市场环境。在未来的“十五”期间，医疗服务和医疗管理在信息产业中被业界人士普遍看好，相信，随着医疗体制改革的进一步深化，医院信息化建设将得到快速发展。 <br/><br/>　　最近，赛迪信息顾问有限公司就当前医院信息化建设情况对全国50家大中小型综合医院、专科医院及行业医院进行了专项调查。 <br/><br/>　　一、 国内医院信息化发展现状 <br/>　　我国医院信息系统大体经历了以下四个阶段： <br/><br/>　　1．单机应用：始于七十年代末八十年代初，主要用于门诊收费、住院病人费用管理、药库管理等。 <br/><br/>　　2．部门级局域网：八十年代中期，代表性的应用系统主要有住院病人管理系统、门诊计价及收费发药系统、药品管理系统等。 <br/><br/>　　3．完整的医院信息系统：九十年代初开始，一些大医院相继在100M快速以太网上建立了较为完整的医院信息系统。 <br/><br/>　　4．远程医疗：随着互联网络的兴起，在一些大医院开始了对远程医疗的研究和实施，通过Internet传输射线、MRI、CT等影像。 <br/><br/>　　总体说来，自90年代起，我国医院信息化建设有了长足发展，在全国500多家（三级甲）大型综合医院及1000多家县市以上二级医院中，有近九百家大中小医院已经实施或正在实施医院信息系统。赛迪信息顾问有限公司的抽样调查显示，目前我国医院信息化建设具有以下特点： <br/><br/>　　◆ 经济发达地区医院的信息化程度相对较高。被调查的50家医院中，发达地区、省会城市医院无论在信息系统设计、开发、应用还是信息系统维护及系统升级能力等方面都具有较高的水平。 <br/><br/>　　◆ 经济相对落后地区信息系统建设比较简单，技术水平低，局限在单一的门诊收费及药房管理上，但有很大市场发展潜力。 <br/><br/>　　◆ 大型综合医院的医院信息系统投资规模在1000万元以上，技术人员中62%以上是大学本科生，医生、护士上岗培训人数达到95%。 <br/><br/>　　二、医院信息系统建设特点 <br/>　　通过对50家医院抽样调查结果进行分析，我们可以总结出医院信息系统建设具有以下特点： <br/><br/>　　1． 体系结构： <br/><br/>　　多数医院信息系统建设选用Client/Server体系结构和10M/100M主交换网。但是随着医院信息系统功能的不断增加，需求的不断提高，有3%-5%左右的医院已经着手对现有系统进行改造。 <br/><br/>　　2．网络设备的选型： <br/><br/>　　调查中发现，医院对网络建设、产品选型非常慎重，具体表现为： <br/><br/>　　◆ 网络具有良好的可扩充性，系统易于升级； <br/><br/>　　◆ 网络具有开放性，支持异种网络互联； <br/><br/>　　◆ 先进的网管系统，具有数据流量分析、系统故障及运行状态检测和虚拟网络管理功能； <br/><br/>　　◆ 确保网络的安全性和保密性。 <br/><br/>　　调查结果显示，超过1/3的医院选用了3Com的交换机，Intel交换机紧随其后，占23%左右，其余的市场份额则由Cisco、北电网络、AMP产品分享。Cisco产品由于受到医院投资所限，在早期选型中受到一定的影响，不过，在近期的医院信息系统改造项目和新上项目中有上好的表现。 <br/><br/>　　3．服务器的选型： <br/><br/>　　在医院信息系统建设中，服务器作为网络的核心，总的市场规模、用户需求量呈明显上升趋势。 <br/><br/>　　◆ 中小型医院信息系统典型配置是2-3台PC服务器，1台用于数据库管理，1台为WEB服务器，1台作为备份服务器； <br/><br/>　　◆ 大型医院信息系统典型配置是4-6台小型机或PC服务器，增加的服务器为应用服务器、知识库管理服务器、远程备份服务器； <br/><br/>　　◆ 在服务器选型上，医院CIO们普遍认为：稳定、可靠、适用是关键。各医院主管部门大都有自己的设备选型范围。 <br/><br/>　　◆ 小型机中，IBM、HP、Compaq、Sun占据了主要市场份额。 <br/><br/><br/><br/>　　图1 服务器总体市场分析 <br/><br/>　　数据来源：CCID <br/><br/>　　◆ 服务器总体市场为Compaq、HP、IBM、Sun占据了主要市场份额。国产品牌的PC服务器份额比例较少，主要原因与前几年国产PC服务器市场的大环境有关，相信在今后的医疗改革和医疗保险等项目上，国产PC服务器会有良好的表现，特别是在中小型医院信息系统建设中将显示出强有力的竞争实力。调查结果如图1所示。 <br/><br/>　　◆ PC机市场则是国产品牌占据了领先地位，联想、方正、清华同方、同创、实达、ACER等PC机受到用户的青睐，联想的产品和服务为广大的用户认可并在医疗行业处于明显优势，方正、同创紧随其后。调查结果如图2所示。 <br/><br/><br/><br/>　　图2 PC机市场分布 <br/><br/>　　数据来源：CCID <br/><br/>　　◆ PC服务器在医院卫生行业中潜力很大，增长幅度快，竞争也将会更加激烈。 <br/><br/>　　4．应用软件： <br/><br/>　　医院信息系统是一个复杂的、涉及广泛的应用系统，因此，系统的开发是量体裁衣的过程。调查发现，不少医院或多或少根据自身条件选择一种或几种开发方式，如下表所示： <br/><br/>产品形式 投入 开发周期 维护 实用性 通用性 <br/>商业软件 不一定 短 依赖开发者 差 强 <br/>自行开发 少 长 自行更新 强 差 <br/>合作开发 适中 不等 视双方实力 强 差 <br/>委托开发 大 不等 困难 强 差 <br/>　　三、 医院信息化考虑因素 <br/>　　在被调查的医院中，大型医院的系统维护情况良好，而中小型医院的系统维护往往是托管给合作的公司，因此，整个医院信息系统的稳定性、可靠性、安全性、标准化是医院信息化建设首先考虑的因素。 <br/><br/>　　1．医院信息系统是一个真正的365×24小时的实时系统，病人的信息必须准确无误地传送到医生手中，因此系统一旦投入使用，就不允许停机，更不能退回手工操作。在被调查的医院中，CIO们最强调也是最重视的是系统的稳定性，一般系统宕机时间不得超出5分钟。 <br/><br/>　　2．医院信息系统的最大特点就是计算机终端设置在各个不同的科室，点多，面广，多人操作，而且工作点间联系密切，信息要相互调用，资料要随时更新保存，此外，病人的医疗信息涉及到个人隐私，医院有责任为所有病人保守秘密，因此与其它行业相比较，医院信息系统建设对系统的可靠性、安全性要求更高。 <br/><br/>　　3．在被调查的50家医院中，CIO们关心和正着手解决的是系统标准化问题。如果系统标准化问题解决得不好，医院间的信息沟通不仅是纸上谈兵，医院内部不同部门间的信息交换也只是梦想。 <br/><br/>　　四、 与国外的差距 <br/>　　1．投资规模差距明显： <br/><br/>　　我国医院信息化建设起步虽然较早，但是由于受到各方面因素的影响，发展不是很快，这其中资金问题是主要制约因素。我国医院在信息技术上投入较低，这不仅指投入占利润总值的比例低，绝对值也与国外有很大的差距，一家典型的美国城市医院每年在信息技术上的投资约为200万美元，而中国一家三级医院的年投入不超过20万美元。 <br/><br/>　　2．技术人员比例差距明显： <br/><br/>　　在采访中，我们提出医院信息系统是否可以服务外包，众多CIO们认为，医院信息系统服务外包可能性甚小，主要原因是医院信息系统实时性非常强，出现问题必须在几分钟内解决，因此，CIO们对目前医院技术人员短缺现象十分担扰。抽样调查显示，配置800个工作站的医院，计算机技术人员总数最多的一家医院是16人；300个工作站的医院，计算机技术人员只有3－4人，远远满足不了日常系统维护和系统培训的需求。相反，在国外医院，每20个工作站点就有1个技术人员进行系统维护。培养一支稳定的、高素质的人才队伍将是医院信息化建设的关键。 <br/><br/>　　五、 “十五”期间市场趋势 <br/>　　“十五”期间全国各大医院正在或准备投入资金建设新系统或改造原有的旧系统，以适应即将实施的医疗改革。 <br/><br/>　　调查表明，医院信息系统“十五”期间将在以下几个方面加大投资力度： <br/><br/>　　1．以电子病历为中心的新一代医院信息系统 <br/><br/>　　2．基于Internet网络的集成化医疗护理网络 <br/><br/>　　3．医疗卡将成为投资焦点 <br/><br/>　　4．远程医学教育将得到长足的发展 <br/><br/>　　医院将进一步加大远程医疗的投资力度，投资规模在200-300万元之间不等。 <br/><br/>　　医疗行业是关系人类健康的重要事业，医院信息系统是医疗保险体制的信息源头，因此，医院的信息化建设不仅是今后医院发展的重要方向，也将是IT界关注的领域。预测2000-2001年，我国将有70%-80%的医院实现信息化管理，市场总量将达到200多亿元人民币。 <br/>                </div>                    </div>
1823	 华为的冬天(任正非）	华为  工作  生活  报表  数据库  制造  	985154280	2721	jiangtao	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                          公司所有员工是否考虑过，如果有一天，公司销售额下滑、利润下滑甚至会破产，我们怎么办？我们公司的太平时间太长了，在和平时期升的官太多了，这也许就是我们的灾难。泰坦尼克号也是在一片欢呼声中出的海。而且我相信，这一天一定会到来。面对这样的未来，我们怎样来处理，我们是不是思考过。我们好多员工盲目自豪，盲目乐观，如果想过的人太少，也许就快来临了。居安思危，不是危言耸听。<br/>    我到德国考察时，看到第二次世界大战后德国恢复得这么快，当时很感动。他们当时的工人团结起来，提出要降工资，不增工资，从而加快经济建设，所以战后德国经济增长很快。如果华为公司真的危机到来了，是不是员工工资减一半，大家靠一点白菜、南瓜过日子，就能行？或者我们就裁掉一半人是否就能救公司。如果是这样就行的话，危险就不危险了。因为，危险一过去，我们可以逐步将工资补回来。或者销售增长，将被迫裁掉的人请回来。这算不了什么危机。如果两者同时都进行，都不能挽救公司，想过没有。<br/>    十年来我天天思考的都是失败，对成功视而不见，也没有什么荣誉感、自豪感，而是危机感。也许是这样才存活了十年。我们大家要一起来想，怎样才能活下去，也许才能存活得久一些。失败这一天是一定会到来，大家要准备迎接，这是我从不动摇的看法，这是历史规律。<br/>    目前情况下，我认为我们公司从上到下，还没有真正认识到危机，那么当危机来临的时刻，我们可能是措手不及的。我们是不是已经麻木，是不是头脑里已经没有危机这根弦了，是不是已经没有自我批判能力或者已经很少了。那么，如果四面出现危机时，那我们可能是真没有办法了。那我们只能说“你们别罢工了，我们本来就准备不上班了，快关了机器，还能省点电。”如果我们现在不能研究出现危机时的应对方法和措施来，我们就不可能持续活下去。<br/>    这三年来的管理要点讲的都是人均效益问题。不抓人均效益增长，管理就不会进步。因此一个企业最重要、最核心的就是追求长远地、持续地实现人均效益增长。当然，这不仅仅是当前财务指标的人均贡献率，而且也包含了人均潜力的增长。企业不是要大，也不是要强，短时间的强，而是要有持续活下去的能力与适应力。我们有一位员工写了一篇文章《还能改进吗？还能改进吗？》，只有不断改进，我们才有希望。但是华为公司有多少员工在本职岗位上在改进，有多少人在研究还能再改进。我们的干部述职报告所有指标都是人均效益指标。人均效益指标降低了，我们就坚定不移地降工资。如果你连降工资都不能接受，我认为你就没有必要再留在华为公司奋斗了。一个部门领导没有犯过什么错误，但人均效益没有增长，他应下台了。另一个部门的领导犯过一些错误，当然不是品德错误，是大胆工作，大胆承担责任，缺经验而产生的错误，而人均效益增长，他应受到重视。若他犯的错误，是集体讨论过的，错了以后又及时改正了，他应受到提拔。各级干部部门，要防止明哲保身的干部被晋升。在一个系统中，人均效益的指标连续不增长，那么主要部门领导与干部部门的人，应全部集体辞职。因为，人是他们?<br/>〉模×诵┦裁慈恕?<br/>    在当前情况下，我们一定要居安思危，一定要看到可能要出现的危机。大家知道，有个是世界上第一流的公司，确实了不起，但去年说下来就下来了，眨眼之间这个公司就几乎崩溃了。当然，他们有很好的基础研究，有良好的技术储备，他们还能东山再起。最多这两年衰退一下，过两年又会世界领先。而华为有什么呢？我们没有人家雄厚的基础，如果华为再没有良好的管理，那么真正的崩溃后，将来就会一无所有，再也不能复活。<br/>    华为公司老喊狼来了，喊多了，大家有些不信了。但狼真的会来了。今年我们要广泛展开对危机的讨论，讨论华为有什么危机，你的部门有什么危机，你的科室有什么危机，你的流程的那一点有什么危机。还能改进吗？还能改进吗？还能提高人均效益吗？如果讨论清楚了，那我们可能就不死，就延续了我们的生命。怎样提高管理效率，我们每年都写了一些管理要点，这些要点能不能对你的工作有些改进，如果改进一点，我们就前进了。<br/><br/>    一、均衡发展，就是抓短的一块木板<br/>    我们怎样才能活下来。同志们，你们要想一想，如果每一年你们的人均产量增加百分之十五，你可能仅仅保持住工资不变或者还可能略略下降。电子产品价格下降幅度 一年还不止只百分之十五吧。我们卖的越来越多，而利润却越来越少，如果我们不多干一点，我们可能保不住今天，更别说涨工资。不能靠没完没了的加班，所以一定要改进我们的管理。在管理改进中，一定要强调改进我们木板最短的那一块。各部门、各科室、各流程主要领导都要抓薄弱环节。要坚持均衡发展，不断地强化以流程型和时效型为主导的管理体系的建设，在符合公司整体核心竞争力提升的条件下，不断优化你的工作，提高贡献率。为什么要解决短木板呢？公司从上到下都重视研发、营销，但不重视理货系统、中央收发系统、出纳系统、订单系统……等很多系统，这些不被重视的系统就是短木板，前面干得再好，后娣⒉怀龌酰故堑扔诿桓伞Ｒ虼巳疽欢ㄒ⑵鹜骋坏募壑灯兰厶逑担骋坏目计捞逑担拍苁谷嗽痹谀诓苛鞫推胶獬晌赡堋１热缬腥怂滴腋阊蟹⒋葱潞芾骱Γ葱碌募壑等绾翁逑郑葱卤匦胪ü涑缮唐罚拍懿壑怠Ｎ颐侵厥蛹际酢⒅厥佑庖坏阄也⒉环炊裕恳桓隽刺醵际呛苤匾摹６?<br/>研发相对用服来说，同等级别的一个用服工程师可能要比研发人员综合处理能力还强一些。所以如果我们对售后服务体系不给认同，那么这体系就永远不是由优秀的人来组成的。不是由优秀的人来组织，就是高成本的组织。因为他飞过去修机器，去一趟修不好，又飞过去修不好，又飞过去又修不好。我们把工资全都赞助给民航了。如果我们一次就能修好，甚至根本不用过去，用远程指导就能修好，我们将省了多少成本啊！因此，我们要强调均衡发展，不能老是强调某一方面。比如，我们公司老发错货，发到国外的货又发回来了，发错货运费、货款利息不也要计成本吗？因此要建立起一个均衡的考核体系，才能使全公司短木板变成长木板，桶装水才会更多。<br/>    我们这几年来研究了很多产品，但IBM还有许多西方公司到我们公司来参观时就笑话我们浪费很大，因为我们研究了很多好东西就是卖不出去，这实际上就是浪费。我们不重视体系的建设，就会造成资源上的浪费。要减少木桶的短木板，就要建立均衡的价值体系，要强调公司整体核心竞争力的提升。<br/><br/>    二、对事负责制，与对人负责制是有本质区别的，一个是扩张体系，一个是收敛体系。<br/>    为什么我们要强调以流程型和时效型为主导的体系呢？现在流程上运作的干部，他们还习惯于事事都请示上级。这是错的，已经有规定，或者成为惯例的东西，不必请示，应快速让它通过去。执行流程的人，是对事情负责，这就是对事负责制。事事请示，就是对人负责制，它是收敛的。我们要减化不必要确认的东西，要减少在管理中不必要、不重要的环节，否则公司怎么能高效运行呢？现在我们机关有相当的部门，以及相当的编制，在制造垃圾，然后这些垃圾又进入分捡、清理，制造一些人的工作机会。制造这些复杂的文件，搞了一些复杂的程序，以及不必要的报表、文件，来养活一些不必要养活的机关干部。机关干部是不能产生增值行为的。我们一定要在监控有效的条件下，尽力精简机关。秘书有权对例行的管理工作进行处理，经理主要对例外事件，以及判别不清的重要例行事件作出处理。例行越多，经理就越少，成本就越低。一定要减少编制，我们的机关编制是过于庞大的。在同等条件下，机关干部是越少越好，当然不能少得一个也没有。因此我们一定坚定不移地要把一部分机关干部派到直接产生增值的岗位上去。机关的考评，应由直接服务部门进行打分，它要与机关的工资、奖金的组织得分挂勾?<br/>Ｕ庖彩强突У枷颍诓靠突б彩强突А?<br/>    市场部机关是无能的。每天的纸片如雪花一样飞啊，每天都向办事处要报表，今天要这个报表，明天要那个报表，这是无能的机关干部。办事处每一个月把所有的数据填一个表，放到数据库里，机关要数据就到数据库里找。从明天开始，市场部把多余的干部组成一个数据库小组，所有数据只能向这个小组要，不能向办事处要，办事处一定要给机关打分，你们不要给他们打那么好的分，让他们吃一点亏，否则他们不会明白这个道理，就不会服务于你们，使你作战有力。庞大的机关一定要消肿。在这个变革过程中，会触及到许多人的利益，也会碰到许多矛盾，领导干部要起模范作用。要有人敢于承担责任，不敢承担责任的人就不能当干部。当工程师也很光荣嘛。<br/>    在本职工作中，我们一定要敢于负责任，使流程速度加快。对明哲保身的人一定要清除。华为给了员工很好的利益，于是有人说千万不要丢了这个位子，千万不要丢掉这个利益。凡是要保自己利益的人，要免除他的职务，他已经是变革的绊脚石。在去年的一年里，如果没有改进行为的，甚至一次错误也没犯过，工作也没有改进的，是不是可以就地免除他的职务。他的部门的人均效益没提高，他这个科长就不能当了。他说他也没有犯错啊，没犯错就可以当干部吗？有些人没犯过一次错误，因为他一件事情都没做。而有些人在工作中犯了一些错误，但他管理的部门人均效益提升很大，我认为这种干部就要用。对既没犯过错误，又没有改进的干部可以就地免职。<br/><br/>    三、自我批判，是思想、品德、素质、技能创新的优良工具<br/>    我们一定要推行以自我批判为中心的组织改造和优化活动。自我批判不是为批判而批判，也不是为全面否定而批判，而是为优化和建设而批判。总的目标是要提升公司整体核心竞争力。为什么要强调自我批判？我们倡导自我批判，但不提倡相互批评，因为批评不好把握适度，如果批判火药味很浓，就容易造成队伍之间的矛盾。而自己批判自己呢，人们不会自己下猛力，对自己都会手下留情。即使用鸡毛掸子轻轻打一下，也比不打好，多打几年，你就会百炼成钢了。自我批判不光是个人进行自我批判，组织也要对自己进行自我批判。通过自我批判，各级骨干要努力塑造自己，逐步走向职业化，走向国际化。只有认真地自我批判，才能在实践中不断吸收先进，优化自己。公司认为自我批判是个人进步的好方法，还不能掌握这个武器的员工，希望各级部门不要对他们再提拔了。两年后，还不能掌握和使用这个武器的干部要降低使用。在职在位的干部要奋斗不息、进取不止。干部要有敬业精神、献身精神、责任心、使命感。我们对普通员工不作献身精神要求，他们应该对自己付出的劳动<br/>，取得合理报酬。只对有献身精神的员工作要求，将他们培养成干部。另外，我们对高级干部实行严要求，不对一般干部实施严要求。因为都实施严要求，我们管理成本就太高了。因为管他也要花钱的呀，不打粮食的事我们要少干。因此我们对不同级别的干部有不同的要求，凡是不能使用自我批判这个武器的干部都不能提拔。自我批判从高级干部开始，高级干部每年都有民主生活会，民主生活会上提的问题是非常尖锐的。有人听了以后认为公司内部斗争真激烈，你看他们说起问题来很尖锐，但是说完他们不又握着手打仗去了吗？我希望这种精神一直能往下传，下面也要有民主生活会，一定要相互提意见，相互提意见时一定要和风细雨。我认为，批评别人应该是请客吃饭，应该是绘画、绣花，要温良恭让。一定不要把内部的民主生活会变成了有火药味的会议，高级干部尖锐一些，是他们素质高，越到基层应越温和。事情不能指望一次说完，一年不行，二年也可以，三年进步也不迟。我希望各级干部在组织自我批判的民主生活会议上，千万要把握尺度。我认为人是怕痛的，太痛了也不太好，象绘画，绣花一样，细细致致地帮人家分析他的缺点，提出改进措施来，和风细雨式最好。我相信只要我们持续下去，这比?<br/>侵直┓缂庇晔降母锩行Ч?<br/><br/>    四、任职资格及虚拟利润法是推进公司合理评价干部的有序、有效的制度。<br/>    我们要坚定不移地继续推行任职资格管理制度。只有这样才能改变过去的评价蒙估状态。才会使有贡献、有责任心的人尽快成长起来。激励机制要有利于公司核心竞争力战略的全面展开，也要有利于近期核心竞争力的不断增长。<br/>    什么叫领导？什么叫做政客？这次以色列的选举，让我们看到了犹太人的短视。拉宾意识到以色列一个小国，处在几亿阿拉伯人的包围中，尽管几次中东战争以色列都战胜了。但不能说50年、100年以后，阿拉伯人不会发展起来，今天不以土地换和平、划定边界，与周边和平相处，那么一旦阿拉伯人强大起来，他们又会重新流离失所。要是这样犹太人再过2000年还回不回得来，就不一定了。而大多数人，只看重眼前的利益，沙龙是强硬派，会为犹太人争得近期利益，人们拥护了他。我终于看到一次犹太人也象我们一样的短视。我们的领导都不要迎合群众，但推进组织目的，要注意工作方法。一时牺牲的是眼前的利益，但换来的是长远的发展。<br/>    我曾经在与一个世界著名公司，也是我司全方位的竞争对手的合作时讲过，我是拉宾的学生，我们一定要互补、互助，共同生存。我只是就崇敬拉宾，来比喻与竞争对手的长期战略关系。<br/>    如何掌握任职资格的应用，是对各级干部的考验。我们公司在推行激励机制时，不要有短期行为，我们要强调可持续发展。既要看到他的短期贡献，也要看到组织的长期需求。不要对立起来，不要完全短期化，也不要完全长期化。<br/>    同时，我们要推行以正向考核为主，但要抓住关键事件逆向考事，事就是事情的事。对每一件错误要逆向去查，找出根本原因，以改进。并从中发现优良的干部。我认为正向考核很重要，逆向的考事也很重要。要从目标决策管理的成功，特别是成功的过程中发现和培养各级领导干部。在失败的项目中，我们要善于总结，其中有不少好干部也应得到重视。要避免考绩绝对化、形而上学。特别是要从有实践经验、有责任心、有技能，且本职工作做得十分优秀的员工中选拔和培养骨干。<br/>    干部要有敬业精心、献身精神、责任心和使命感。区别一个干部是不是一个好干部，是不是忠臣，标准有四个：第一，你有没有敬业精神，对工作是否认真，改进了，还能改进吗？还能再改进吗？这就是你的工作敬业精神。第二，你有没有献身精神，不要斤斤计较，我们的价值评价体系不可能做到绝对公平。如果用曹冲称象的方法来进行任职资格来评价的话，那肯定是公平的。但如果用精密天平来评价，那肯定公平不了。我们要想做到绝对公平是不可能的。我认为献身精神是考核干部的一个很重要因素。一个干部如果过于斤斤计较，这个干部绝对做不好，你手下有很多兵，你自私、斤斤计较，你的手下能和你合作很好吗？没有献身精神的人不要做干部，做干部的一定要有献身精神。第三点和第四点，就是要有责任心和使命感。我们的员工是不是都有责任心和使命感？如果没有责任心和使命感，为什么还想要当干部。如果你觉得还是你有一点责任心和使命感的，赶快改进，否则最终还是要把你免下去的。<br/><br/>    五、不盲目创新，才能缩小庞大的机关。<br/>    庙小一点，方丈减几个，和尚少一点，机关的改革就是这样。总的原则是我们一定要压缩机关，为什么？因为我们建设了IT。为什么要建设IT？道路设计时要博士，炼钢制轨要硕士，铺路要本科生。但是道路修好了扳岔道就不要这么高的学历了，否则谁也坐不起这个火车。因此当我们公司组织体系和流程体系建设起来的时候，就不要这么多的高级别干部，方丈就少了。建立流程的目的就是要提高单位生产效率，减掉一批干部。如果一层一层都减少一批干部，我们的成本下降很快。规范化的格式与标准化的语言，使每一位管理者的管理范围与内容更加扩大。信息越来越发达，管理的层次就越来越少，维持这些层级管理的官员就会越来越少，成本就下降了。要保证IT能实施，一定要有一个稳定的组织结构，稳定的流程。盲目创新只会破坏这种效率。<br/>    我们不要把创新炒得太热。我们希望不要随便创新，要保持稳定的流程。 要处理好管理创新与稳定流程的关系。尽管我们要管理创新、制度创新，但对一个正常的公司来说，频繁地变革，内外秩序就很难安定地保障和延续。不变革又不能提升我们的整体核心竞争力与岗位工作效率。变革，究竟变什么？这是严肃的问题，各级部门切忌草率。一个有效的流程应长期稳定运行，不因有一点问题就常去改动它，改动的成本会抵消改进的效益。已经证明是稳定的流程，尽管发现它的效率不是很高，除非我们整体设计或大流程设计时发现缺陷，而且这个缺陷非改不可，其它时候就不要改了。今年所有的改革必须经过严格的审批、证实，不能随意去创新和改革，这样创新和改革的成本太高。我们要坚持“小改进，大奖励”。“小改进、大奖励”是我们长期坚持不懈的改良方针。应在小改进的基础上，不断归纳，综合分析。研究其与公司总体目标流程的符合，与周边流程的和谐，要简化、化、再固化。这个流程是否先进，要以贡献率的提高来评价。我年轻时就知道华罗庚的一句话，“神奇化易是坦途，易化神奇不足提”。我们有些员工，交给他一件事，他能干出十件事来，这种创新就不需要，是无能的表现。这是制造!<br/>垃圾，这类员工要降低使用。所以今年有很多变革项目，但每个变革项目都要以贡献率来考核。 既要实现高速增长，又要同时展开各项管理变革，错综复杂，步履艰难，任重而道远。各级干部要有崇高的使命感和责任意识，要热烈而镇定，紧张而有秩序。“治大国如烹小鲜”，我们做任何小事情都要小心谨慎，不要随意把流程破坏了，发生连锁错误。大家在处理相互之间的人际关系上也要保持冷静，稍不冷静就惹麻烦。千万不要有浮躁的情绪，戒骄戒躁，收敛自我，少一些冲动，多一些理智。<br/>    我们要坚决反对形而上学、幼稚浮躁、机械教条和唯心主义。在管理进步中一定要实事求是，特别要反对形左实右。表面上去做得很正确，其实效率是很低的。<br/><br/>    六、规范化管理本身已含监控，它的目的是有效、快速的服务业务需要。<br/>    我们要继续坚持业务为主导，会计为监督的宏观管理方法与体系的建设。什么叫业务为主导，就是要敢于创造和引导需求，取得“机会窗”的利润。也要善于抓住机会，缩小差距，使公司同步于世界而得以生存。什么叫会计为监督，就是为保障业务实现提供规范化的财经服务，规范化就可以快捷、准确和有序，使帐务维护成本低。规范化是一把筛子，在服务的过程中也完成了监督。要把服务与监控融进全流程。我们也要推行逆向审计，追溯责任，从中发现优秀的干部，铲除沉淀层。以业务为主导，会计为监督的管理模式，就是要为推行区域、业务的行政管理与统一财务服务的行政管理相分离做准备（财务IT，将实行全国、全球统一管理）。<br/><br/>    七、面对变革要有一颗平常心，要有承受变革的心理素质。<br/>    我们要以正确的心态面对变革。什么是变革？就是利益的重新分配。利益重新分配是大事，不是小事。这时候必须有一个强有力的管理机构，才能进行利益的重新分配，改革才能运行。在改革的过程中，从利益分配的旧平衡逐步走向新的利益分配平衡。这种平衡的循环过程，是促使企业核心竞争力提升与效益增长的必须。但利益分配永远是不平衡的。我们在进行岗位变革也是有利益重新分配的，比如大方丈变成了小方丈，你的庙被拆除了，不管叫什么，都要有一个正确的心态来对待。如果没有一个正确的心态，我们的改革是不可以成功的，不可能被接受的。特别是随着IT体系的逐步建成，以前的多层行政传递与管理的体系将更加扁平化。伴随中间层的消失，一大批干部将成为富余，各大部门要将富余的干部及时输送至新的工作岗位上去，及时地疏导，才会避免以后的过度裁员。<br/>&amp;nbsp                </div>                    </div>
1826	 软件公司创业完全手册[一]	创业  工作  生活  融资  平台  	985418640	5152	jiangtao	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        作者按： <br/>您说您已经厌倦了朝九晚五、平平淡淡的生活！ <br/>您说您渴望的不是港湾的风平浪静，而是勇立潮头的波涛汹涌！ <br/>您说生命的意义在于过程，而不是结局！只要曾奋斗过，今生便无怨无悔！ <br/>您说人应该是一颗流星，在激烈的奋争中才会闪耀出夺目的人生曲线！ <br/>您说这话时，每一句，便是一口酒！ <br/>您从不喝酒，但这次却喝了，而且不少！ <br/>太阳终于升起，您的脸也像一颗炽热的太阳！ <br/>身影被扯得老长，头发在风中就像猎猎舞动的旌旗！ <br/>极目四顾，海阔天空 <br/>您大踏步地走向前去，前面通往未来之路！ <br/><br/>　　<br/>　　<br/>　　<br/>　　<br/>　　<br/>　　<br/>　　<br/>　　<br/>　　 前 言 <br/><br/><br/>　　创业，一个令人兴奋的话题。 <br/><br/>　　每个人都希望主宰自己的命运，从这个意义上说，创业是最好的生存之道。因创业难于上青天而让很多人怯步；又因创业是诱人的而让有些涉世不深的人忽略了创业的艰辛和其中的高度智慧。创业真的那么难吗？其实，打工也并不容易，我们曾经到处流浪，我们曾经到处找工作，我们曾经在他人的强迫下忍气吞声地做着不情愿做的工作，更伤心的是，很多年下来我们仍一无所有。难道我们的命运不能改变？我们不愿在青春消耗殆尽时才考虑这些问题，最要紧的是当前。创业不但可让我们摆脱受剥削的被动局面，而且可以最大限度地实现自我价值，更重要的是，创业可让我们为社会做出较大的贡献。一个国家有没有希望是看创业的人多不多，一个国家强不强大是看创业成功的人多不多。无论是风风火火的创业大赛，还是高校关于允许在校生停学创业的政策；无论是年内创业板的即将开放，还是孵化器的星火燎原，所有的这些都说明了整个社会对创业的关注和支持！总之，我们有一万零一个理由——必须创业！ <br/><br/>　　为什么选择软件业作为切入点？ <br/><br/>　　有这么一个故事：有三兄弟，老大苦心精营一家饭店，由于经营有方，规模不断扩大，饭店逐渐发展成为一家酒店，资产也由几万达到几百万，这个过程花了几十年；老二毕业后分配在一家工厂，由于工作出色，职位不断上升，接着工厂改组成股份制，按照他的职位，分配到的股份如果套现的话也有几百万，到这一步，他花了几年；老三搞软件，由于方向对头，引起风险投资的关注，并在公司成立的第九个月成功在海外上市，资产同样达到几百万。 <br/><br/>　　同样是几百万，三兄弟花了不同的时间。这说明了什么问题？现在，我们应该将目光更多地投向那些发展速度超过收入速度的创新型小企业，而不是传统的经验型、有长时间积累的企业。这是一个快鱼吃慢鱼的时代，大者通吃开始让位于快者通吃或者说快者“同”吃。软件业便能提供一个这样的发展平台。 <br/><br/>　　以上只是一个故事，让我们看一些确却的数据： <br/><br/>　　1994年我国的软件市场销售额为40亿元，到2000年则超过230亿元，年平均增长达24.67%。信息产部预测今年我国软件市场销售额约为315亿元，将比去年增长34%左右。而我国目前计算机普及率仅为0.80%(发达国家为30%-40%)，据专家估算，假设十年后普及率达到20%，软硬比达到1：2，则软件市场的销售潜力可达到1万亿以上。从这些数字可以看出，中国软件产业发展速度惊人，产业规模不断扩大，市场前景非常看好。 <br/><br/>　　国家大力扶持软件产业。近年来我国对软件业的发展高度重视，国务院关于《鼓励软件产业和集成电路产业发展的若干政策》等一系列政策和措施的相继出台，从投资、融资、税收、产业技术、出口以及收入分配等方面给出了良好的外部环境，规范了行业组织及其管理行为，软件业获得了越来越多的优惠政策。政府已经在全国设立了15个软件产业园区，在园区内为软件企业提供优越的基础设施和优惠政策，为软件科技人才提供了良好的工作和生活条件，在集中资源推动软件产业发展方面起到了非常重要的作用。 <br/><br/>　　这一切都为软件创业创造了良好的氛围，然面成功现在便可手到擒来吗？ <br/><br/>　　创业，不只是发明、生产，不只是推广、销售。它不是一篇论文而遭就束之高阁；它不是一时的冲动，那只是瞬时的灵感闪现；它不是一项科研成果只停留在实验室的温订；它是一种思想，它的价值在于最大限度的认同；它不仅需要瞬时的激情，更需要恒久的坚忍；它是一项魔术，一个从无到有的嬗变过程，但这个过程的载体是汗水、意志的结晶。 <br/><br/>　　无论是刀耕火种的原始社会，还是比特大行其道的信息时代，天上都不会掉陷饼。成功必须付出相当大的代价。据有关统计，创业成功的比率一般为2%。但机遇与风险并存，成功与挑战同在！“人生能有几回搏”，即便失败了又何妨！人生的意义在于过程，而不是结局！ <br/><br/>　　本文是作者在参与创办软件公司的一点心得，不敢言对大家有何教益，只希望能引来金玉良言，起到抛砖引玉的效果。（待续）<br/><br/>                </div>                    </div>
1834	 J2ME (Java 2 Micro Edition) 简介	java  j2me  嵌入式  平台  j2se  linux  	987125940	3572	jiangtao	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p>■前言  <br/>   <br/> 如果您曾经到<a href="http://www.javasoft.com">http://www.javasoft.com</a> 网站上查询有关Java 2 Micro <br/>Edition 的资料，十之八九会被一大堆的技术名词搞的一头雾水。什么 K<br/>VM ，什么CLDC 、CDC 、MIDP ，後面还冒出了Personal Java 、Embedde<br/> d Java以及JES 等名词。虽然名为Java 的微小版本，可是它的世界可真<br/>是不小，让我们满肚子「见山不是山，见水不是水」的疑惑。的确，在我<br/>刚开始接触 Java 2 Micro Edition 的时候，就感觉到这个玩意儿实在越<br/>看越让人摸不著头绪。因此在本章中，我舍弃了技术上的细节，希望带大<br/>家从巨观的角度来看待 Java 2 Micro Edition 的世界。希望读过本章之<br/>後，可以使大家体验「见山是山，见水是水」，一切豁然开朗的感觉。首<br/>先，我们必须先对Java 2 Micro Edition 在整个Java 技术之中的定位做<br/>个了解。  <br/>   <br/>  ■各种不同版本之Java 程序的开发 <br/>   <br/> 如前面所说，各种不同的Java 版本，在其支援的核心类别函式库之完整<br/>性以及所支援的 Java 基本型别这两件事情上都有所差异，也就是说，不<br/>管您开发的是企业所使用的Java 程序、嵌入式装置上执行的Java 程序、<br/>浏览器上执行的Applet ，或是在PC 上执行的应用程序。您都必须在您的<br/>电脑上先安装 J2SE ，然後再安装各种版本的核心类别函式库以及额外的<br/>扩充类别函式库，如此才能成功地开发各种不同目的的Java 程序。J2SE <br/>所提供的Java 编译器(javac.exe)可以帮助我们编译各种不同平台上的Ja<br/>va 程序，而J2SE 所提供的Java 虚拟机器(java.exe)则可以帮助我们在P<br/> C 上先行测试这些程序执行结果的正确与否。另外，Java 编译器并不会<br/>帮您检查您的程序是否符合各种平台上所支援的核心类别函式库与 Java <br/>基本型别。举例来说，虽然我们在前面说过，Smart Card 版本并不支援b<br/>oolean 、byte 以外的Java 基本型别，而且该平台也只支援java.lang.*<br/>核心类别，可是当我们在撰写 Smart Card 平台上的程序时，就算在程序<br/>码里头用了boolean 或byte 以外的Java 基本型别，或者使用了java.lan<br/> g.*之外的其他核心类别，编译器仍然可以照常帮您编译出类别档。这个<br/>时候大家一定开始产生疑惑 --那么这些程序如果放到Smart Card 上头执<br/>行的时候，出了问题怎么办 ? 难道不会造成Smart Card 上的虚拟机器执<br/>行时发生错误吗 ? 针对这个可能发生的潜在问题，Sun Microsystems 在<br/>各种不同版本的开发套件中，有些会内附检查器 (checker)或者预先审核<br/>器 (preverifier)，这两个工具可以帮助您在将程序放到目标平台之前先<br/>做好检查和预先审核的工作。检查器会帮您找出类别档之中不合目标平台<br/>规格的部分，并提醒你这些地方可能无法在目标平台上执行。因此只要有<br/>检查器的协助，您大致上可以确定您的程序可以符合目标平台的规定并顺<br/>利执行。 Java Card 的开发套件中就附有检查器。 <br/>   <br/>  而某些平台的开发套件则附有预先审核器，预先审核器除了做检查器做<br/>的工作之外，还有一项额外的工作，就是减轻目标平台上虚拟机器的负担<br/>，要解释预先审核器这个额外的工作，在传统的 Java 程序之中，为了安<br/>全上的考量，任何进入执行环境的类别档 (不管该类别档是来自本机或是<br/>远端机器 )，都必须先经过Byte Code 审核器(Byte code verifier)的验<br/>证，以防止程序在传送途中遭到恶意的修改，而使得 Java 程序在执行时<br/>对系统有不良影响。经过审核之後，该类别档才能开始被J 虚拟机器所执<br/>行。如果这个审核的动作在一般的 PC 上执行，速度倒是还能够接受，可<br/>是一旦放到如 Palm 或是手机这些CPU 较慢、记忆体也比较少的机器上面<br/>就显得十分吃力了。为了节省宝贵的 CPU 运算时间(既能省电又能够加速<br/>程序执行 )，因此，在程序设计师产生能够让某些特定平台执行的类别档<br/>之前，程序设计师必须先在 PC 上使用预先审核器做一些前置的审核工作<br/>，预先审核器会在类别档之中加入一些特殊标记或符号。如此一来，当这<br/>些程序放到目标平台上执行时，就可以大幅减少在目标平台上做审核时的<br/>时间，藉而加速程序的的启动及执行速度。因此在J2ME 之下的程序(Spot<br/>let 、MIDlet)，其执行步骤变成因为预先审核的关系，执行时Byte Code<br/>  审核器的工作就变少了，也因此从程序载入到开始执行之间的时间因而<br/>缩短。 CLDC标准实作和MIDP 参考实作之中就附有预先审核器。 <br/>   <br/>  ■Java 版本的演进 <br/>   <br/>  相信熟悉Java 演进历史的人或多或少都听说过，Java 技术一开始并非<br/>就叫做 Java ，而是叫做OAK ，而且最早的时候就是为了嵌入式系统而设<br/>计的一项产品。後来因为网际网路的发达，而OAK 的诸多特性刚好又适合<br/>用在网路上(例如可移植性、编译後程序码很小)，因为商标已被注册的关<br/>系，因此 OAK 被改名成Java ，从此因缘际会地成了网路上的闪亮巨星，<br/>并随著时间越来越成熟，也慢慢地产生了许多非原本预期中的相关运用。<br/>虽然 Java 已经被用到许多企业级软体上，可是其实骨子里面还是非常适<br/>合用在嵌入式系统之中。  <br/>   <br/>  虽然从Java 1.0 发表之後，Java 就被广泛地使用在桌上型应用程序以<br/>及Applet 的开发上，但是，从Java 1.1 开始，Java又回到了它一开始的<br/>老路--也就是嵌入式系统方面的应用，在当时Sun Microsystems 发表了E<br/>mbedded Java 与Personal Java(也有人简称为PJava)这两项规格。其中E<br/> mbedded Java 是为了资源十分有限，而且没有显示设备的嵌入式装置而<br/>设计；  Personal Java 则是为了在能够与网际网路连线、并拥有显示系<br/>统(例如彩色LCD)的消费性电子装置而设计。接著Java 的版本演进到Java<br/> 2 ，这时为了再明显区分各种Java 的应用，所以分割出了J2EE 、J2SE <br/>、以及 J2ME 三种版本。这三种版本的各种特性我们已经在前面已经详细<br/>地描述，在此不再赘述。不过请大家记住，由於 Java 2将Java 的应用区<br/>分成三大块，使得 Java 程序语言的发展不会再像Java 1.1时如树枝状般<br/>扩散出去，这么一来有助於大家对 Java 各种应用的??清，而不会造成今<br/>後越发展下去越不可收拾的混乱局面。额外向大家一提的是，後来Person<br/> al Java 发展到1.2 版的时候，也采用了一些Java 2 平台上与安全性有<br/>关的设计。  <br/>   <br/>  ■Java 2 Micro Edition 概观 <br/>   <br/> J2ME 在设计其规格的时候，遵循著「对於各种不同的装置而造出一个单<br/>一的开发系统是没有意义的事」这个基本原则。於是 J2ME 先将所有的嵌<br/>入式装置大体上区分为两种 :一种是运算功能有限、电力供应也有限的嵌<br/>入式装置(比方说PDA 、手机)；另外一种则是运算能力相对较佳、并请在<br/>电力供应上相对比较充足的嵌入式装置 (比方说冷气机、电冰箱、电视机<br/>上盒 (set-top box))。因为这两种型态的嵌入式装置，所以Java 引入了<br/>一个叫做Configuration 的概念，然後把上述运算功能有限、电力有限的<br/>嵌入式装置定义在Connected Limited Device Configuration(CLDC)规格<br/>之中；而另外一种装置则规范为 Connected Device Configuration(CDC)<br/>规格。也就是说， J2ME 先把所有的嵌入式装置利用Configuration 的概<br/>念区隔成两种抽象的型态。  <br/>   <br/> 其实在这里大家可以把Configuration 当作是J2ME 对於两种类型嵌入式<br/>装置的规格，而这些规格之中定义了这些装置至少要符合的运算能力、供<br/>电能力、记忆体大小等规范，同时也定了一组在这些装置上执行的 Java <br/>程序所能使用的类别函式库、这些规范之中所定义的类别函式库为 Java <br/>标准核心类别函式库的子集合以及与该型态装置特性相符的扩充类别函式<br/>库。比方就CLDC 的规范来说，可以支援的核心类别函式库为java.lang.*<br/>、java.io.*、java.util.*，而支援的扩充类别函式库为java.microedit<br/>ion.io.*。区分出两种主要的Configuration 之後，J2ME 接著在定义出P<br/>rofile的概念。Profile 是架构在Configuration 之上的规格。之所以有<br/>Profile的概念，是为了要更明确地区分出各种嵌入式装置上Java 程序该<br/>如何开发以及它们应该具有哪些功能。因此Profile 之中定义了与特定嵌<br/>入式装置非常相关的扩充类别函式库，而 Java 程序在各种嵌入式装置上<br/>的使用者介面该如何呈现就是定义在Profile 里头。Profile 之中所定义<br/>的扩充类别函式库是根据底层Configuration 内所定义的核心类别函式库<br/>所建立。  <br/>   <br/>  ■Java 在嵌入式系统上的应用 <br/>   <br/> 由於Java 本身最初的设计理念即是针对嵌入式系统，因此将他用在嵌入<br/>式系统上真可谓如鱼得水。在这个Linux 开始兴起的时空交会点，网路上<br/>出现了一篇关於嵌入式 Linux 与Java 互相配合以造就双赢局面的相关报<br/>导，这是由 LinuxDevices.com 的专栏作家 Randy Rorden 所发表的一篇<br/>白皮书，名为「 Java 与嵌入式 Linux 合作」。 在这篇文章里头，作者<br/>对嵌入式Linux与Java 个别的优点提出他的看法，同时也提出了Java-Lin<br/> ux 平台的构想。有兴趣的读者可以到到下列几个网站参考相关新闻与资<br/>料。  <br/>   <br/>  1. Java 与嵌入式 Linux 合作白皮书 <br/>     <a href="http://www.ctech.com.tw/d-news/news/linux/89090208.asp">http://www.ctech.com.tw/d-news/news/linux/89090208.asp</a> <br/>  2. Java 及嵌入式Linux 合作 <br/>     <a href="http://www.linuxdevices.com/news/NS5973673868.html">http://www.linuxdevices.com/news/NS5973673868.html</a> <br/>  3. 即将来临的Java-Linux 结合 <br/>     <a href="http://www.linuxdevices.com/articles/AT7102892618.html">http://www.linuxdevices.com/articles/AT7102892618.html</a> <br/>   <br/>  ■为何要用Java 撰写PDA 上的应用程序? <br/>   <br/>  由於预期到今後行动通讯时代的来临，所以通讯相关行业变的前景可期<br/>，而除了达成行动通讯的主要工具 -- 手机月来越精巧之外，有更多的厂<br/>商相继投入PDA 的生产与开发。本来PDA 主要的平台有PalmOS 、Windows<br/> CE 以及EPOC ，也不知道曾几何时，开始一大堆公司投入embedded linu<br/>x 的研发，其中包括国内资策会自己开发的 @ViS 作业系统，互慧科技也<br/>有自己的嵌入式作业系统，当然更不用说大陆厂商与韩国厂商了。 喔喔!<br/>这些作业平台的数量比起 PC 来说真不知道要复杂上几倍。对一般使用者<br/>来说当然影响比较小，可是对於程序开发者来说，看到这么多不同的程序<br/>发展平台，真是让人望之却步。如果每个平台都有自己的程序写法以及函<br/>式库，那么光是看上面这些平台至少就要学习五种以上程序的写法。当然<br/>，只专精一种平台当然是很好的事情。可是程序设计师不禁要说 :”如果<br/>我们写出来的软体可以在不经过修改原始码的情况下就能够在这些平台上<br/>执行，那不是更完美吗?” 对程序开发者来说，这样的投资报酬率当然是<br/>最大的。  <br/>   <br/>  要在那么多平台上开发程序，对程序设计师来说的确是一个很大的挑战<br/>，如果要把所有的时间和精力放在软体的可用性上，那么相对地很多时候<br/>我们根本没有那么多时间撰写各种平台的程序。要解决这个问题，一般来<br/>说程序设计师会选用一个可以跨平台的Framework 来达成至少source cod<br/> e level 的跨平台(例入Qt 就能做到)。不过在本篇文章中我们要介绍的<br/>则是更终极的解决方案 –Java ，利用Java 的”write once, run anywh<br/> ere”特性，我们可以真正达到程序只要写一次，拿到任何平台上都可以<br/>执行(当然前提是必须要PDA 的厂商也要实作出该平台的Java Virtual Ma<br/>chine 才行)。利用Java 来做PDA 上的程序当然有其缺点，最广为人知的<br/>可能就是执行效率的问题， Java 在执行速度这个议题上一直让人诟病。<br/>不过笔者认为，随著技术的发达，将会有更快更省电的PDA 专用CPU 出现<br/>，因此效率上的问题其实是可以忽略的。更何况，当 Sun 在设计J2ME 的<br/>时候，也用了很多方式企图加快Java 在PDA 上的执行速度(例如预先审核<br/> )。 <br/>   <br/>  ■总结 <br/>   <br/> 看完了本章之後，您对整个Java 2 Micro Edition 有个大致上的了解了<br/>吗？  再进入下一章之前，请务必弄清楚本章所提到的专有名词。如果各<br/>位想对各种技术规格做更详细的了解，请自行参考下表所列出的网页。  <br/>   <br/>  Consumer &amp;amp; Embedded Technologies <br/>  <a href="http://java.sun.com/products/consumer-embedded/">http://java.sun.com/products/consumer-embedded/</a> <br/>   <br/>  Consumer &amp;amp; Embedded Technology Center <br/>  <a href="http://developer.java.sun.com/developer/products/j2me/">http://developer.java.sun.com/developer/products/j2me/</a> <br/>   <br/>  Java 2 Micro Edition  <br/>  <a href="http://www.javasoft.com/j2me/">http://www.javasoft.com/j2me/</a> <br/>   <br/>  JDC J2ME Tech Tips  <br/>  <a href="http://developer.java.sun.com/developer/J2METechTips/">http://developer.java.sun.com/developer/J2METechTips/</a> <br/>   <br/>  CLDC &amp;amp; KVM  <br/>  <a href="http://www.javasoft.com/products/cldc/">http://www.javasoft.com/products/cldc/</a> <br/>   <br/>  C &amp;amp; E Center Wireless Technologies <br/> <a href="http://developer.java.sun.com/developer/products/j2me/wireless">http://developer.java.sun.com/developer/products/j2me/wireless</a>.<br/> html <br/>   <br/>  MIDP  <br/>  <a href="http://www.javasoft.com/products/midp/">http://www.javasoft.com/products/midp/</a> <br/>   <br/>  Embedded Java  <br/>  <a href="http://www.javasoft.com/products/embeddedjava/">http://www.javasoft.com/products/embeddedjava/</a> <br/>   <br/>  Personal Java  <br/>  <a href="http://java.sun.com/products/personaljava/">http://java.sun.com/products/personaljava/</a> <br/>   <br/>  JavaPhone  <br/>  <a href="http://java.sun.com/products/javaphone/">http://java.sun.com/products/javaphone/</a> <br/>   <br/>  Java Embedded Server  <br/>  <a href="http://www.sun.com/software/embeddedserver/index.html">http://www.sun.com/software/embeddedserver/index.html</a> <br/>   <br/>  C &amp;amp; E Center Java Embedded ServerTechnology <br/> <a href="http://developer.java.sun.com/developer/products/j2me/embedserv">http://developer.java.sun.com/developer/products/j2me/embedserv</a><br/> .html <br/>   <br/>  JavaTV  <br/>  <a href="http://www.javasoft.com/products/javatv/">http://www.javasoft.com/products/javatv/</a> <br/>   <br/>  C &amp;amp; E Center Digital Interactive Television <br/>  <a href="http://developer.java.sun.com/developer/products/j2me/tv.html">http://developer.java.sun.com/developer/products/j2me/tv.html</a> <br/>   <br/>  Java Card  <br/>  <a href="http://java.sun.com/products/javacard/">http://java.sun.com/products/javacard/</a> <br/>   <br/>  C &amp;amp; E Center JavaCardTechnology <br/> <a href="http://developer.java.sun.com/developer/products/j2me/smartcard">http://developer.java.sun.com/developer/products/j2me/smartcard</a><br/> .html <br/>   <br/>  Motorola 官方Java 网站 <br/>  <a href="http://www.motorola.com/java/">http://www.motorola.com/java/</a> <br/>   <br/>  JINI  <br/>  <a href="http://www.sun.com/jini/">http://www.sun.com/jini/</a> <br/>   <br/>  C &amp;amp; E Center Downloads &amp;amp; Specifications <br/> <a href="http://developer.java.sun.com/developer/products/j2me/downloads">http://developer.java.sun.com/developer/products/j2me/downloads</a><br/> .html <br/>   <br/>  Spotless System Page  <br/>  <a href="http://www.sun.com/research/spotless/">http://www.sun.com/research/spotless/</a> </p>                </div>                    </div>
1883	 职业生涯规划的三个阶段	工作  审查  体育  招聘  活动  	989914200	2105	superyan	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <strong>第一阶段： 　　 <br/></strong>从你20岁开始，你就需要接受培训，需要有一个好的老板，并在你所能找到的最好的环境里参加实际工作，获得实际体验，学习技术常识，增强职业上的自信心。比起创立一个良好的“职业”基础来说，报酬并不重要。 　　 <br/><br/><strong>第二阶段： 　　 <br/></strong>在你30多岁的时候，你就处在一种前进和上升的时尚当中，你将会有充沛的精力和挣钱的实力，你的领导水平将受到检验，你将会为你应得的报酬而同老板讨价还价。这是积累你所需的财富以增加你的选择机会的时候了。你将会考虑你是做个合伙人还是做一个独立的企业家，是做个职员还是做个老板。 　　 <br/><br/><strong>第三阶段： 　　 <br/></strong>达到顶峰，也许是你的奋斗目标之一。做到不拘泥于你现在的各种选择，要保持灵活性，这样就会进步。最后，你得安排好自己光彩地退出来，或继续你喜欢的工作生涯，只要你喜欢，你愿意干多久就干多久。 　　 <br/><br/><br/>你需要： 　　 <br/><br/>1.了解你是什么人，了解你应该做些什么。要鉴定和估价一下你的特长、能力和兴趣。了解自己的优势和劣势是职业生涯计划最好的开端。然后通过决定什么样的工作将最适合你的兴趣和能力来界定你在市场上所处的位置。你很可能会使自己感到吃惊。 <br/>　 <br/>2.利用一切信息来源进行分析研究：从报纸到行业及学术指南上获得的各种信息。同你的朋友、同事以及你的同行取得联络，这样你就会注意到各种机遇。注意保持同招聘代理机构的接触。这些机构往往在为你所瞄准的企业组织招揽人才。 <br/><br/>3.检查一下你的财力状况，当你考虑需要挣什么钱时要头脑冷静。要弄清楚你必须提供的服务其实际收入幅度有多大。 <br/><br/>4.审查你的简历（CV），要保证你的简历中有大量可靠的事实，来说明你迄今为止所取得的成就以及突出显示你的潜在能力。要显示你曾经负责过什么事情，以及你是如何应付你所遇到的各种局势的。 <br/><br/>5.要充分利用你现在的工作或项目。不要随意认为你必须变动工作才能改善你的处境。要考虑多种方式，通过与单位内部不同人的合作，通过学习新的特长或做不同形式的工作使得你当前的工作或项目更有意义或更富挑战性。志愿参加一些有可能的业余活动，如体育运动或所在公司认可的社区工作。 <br/><br/>6.遵循“5年规则”。有些人呆在同一个工作岗位上的时间太长，因为他们害怕变动。然而如果你已经变得过于安稳，如果没有提拔晋升的迹象或没有新的重要长进，那么，你该动一动了。 <br/><br/>7.提高你的谈判能力。这对讨论你的薪水、利益及休息时间等都是颇有用场的。要了解你的公司以及你所在部门和产业的各项相关政策。与过去相比，现在这些待遇的灵活性要大得多。所以要弄准确你是否已经使每项待遇都最大化了，包括养老金和卫生保健。这很可能使你警觉到其他公司、行业可能是什么情况。在任何时候，你都要经常审查你的工作的待遇，因为就业上的事情经常处于变动之中。 <br/><br/>8.对一个职员或潜在的职员来说，毅力、事业心及创造性是最珍贵的品质。要努力做到让我们知道你的工作经历中有这些方面的优势。 <!--文章结束--><br/>                </div>                    </div>
1996	 GuruoftheWeek条款04:类的构造技巧	constructor  os  class  c++  reference  library  	1003884960	1099	kingofark	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p class="MsoNormal"><span lang="en-us" xml:lang="en-us">GotW #04 Class Mechanics</span></p><p class="MsoNormal"><span style="font-family:'宋体';">著者：</span><span lang="en-us" xml:lang="en-us">Herb Sutter<span>      </span></span></p><p class="MsoNormal"><span style="font-family:'宋体';">翻译：</span><span lang="en-us" xml:lang="en-us">kingofark</span></p><p class="MsoNormal"><span lang="en-us" xml:lang="en-us">[</span><span style="font-family:'宋体';">声明</span><span lang="en-us" xml:lang="en-us">]</span><span style="font-family:'宋体';">：本文内容取自</span><span lang="en-us" xml:lang="en-us">www.gotw.ca</span><span style="font-family:'宋体';">网站上的</span><span lang="en-us" xml:lang="en-us">Guru of the Week</span><span style="font-family:'宋体';">栏目，其著作权归原著者本人所有。译者</span><span lang="en-us" xml:lang="en-us">kingofark</span><span style="font-family:'宋体';">在未经原著者本人同意的情况下翻译本文。本翻译内容仅供自学和参考用，请所有阅读过本文的人不要擅自转载、传播本翻译内容；下载本翻译内容的人请在阅读浏览后，立即删除其备份。译者</span><span lang="en-us" xml:lang="en-us">kingofark</span><span style="font-family:'宋体';">对违反上述两条原则的人不负任何责任。特此声明。</span></p><p class="MsoNormal"><span lang="en-us" xml:lang="en-us">Revision 1.0</span></p><p class="MsoNormal"><b><span lang="en-us" xml:lang="en-us">Guru of the Week </span></b><b><span style="font-family:'宋体';">条款</span><span lang="en-us" xml:lang="en-us">04: </span></b><b><span style="font-family:'宋体';">类的构造技巧</span><span lang="en-us" xml:lang="en-us">&lt;?xml:namespace prefix = o ns = "urn:schemas-microsoft-com:office:office" /&gt;</span></b></p><p><b></b></p><b></b><p class="MsoNormal"><span style="font-family:'宋体';">难度：</span><span lang="en-us" xml:lang="en-us">7.5 / 10</span></p><p class="MsoBodyText"><span style="font-family:'宋体';"><em>（你在实现类的细节方面到底有多行？本条款不仅要讲述一些可怕的错误，还要更多的涉及专业的编码风格方面的内容。）</em></span></p><p class="MsoBodyText"><span style="font-family:'宋体';"></span> </p><p class="MsoNormal"><b><span lang="en-us" xml:lang="en-us">[</span></b><b><span style="font-family:'宋体';">问题</span><span lang="en-us" xml:lang="en-us">]</span></b></p><p><b></b></p><b></b><p class="MsoBodyTextIndent"><span style="font-family:'宋体';">    你正在考查另一个程序员编写的一个类（见下），这个类的编码风格很差劲，而且还有一些严重的错误。你能找到多少个，又怎么进行修改呢？</span><span lang="en-us" xml:lang="en-us"> </span></p><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>class Complex {</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>public:</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>Complex( double real, double imaginary = 0 )</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> <span>         </span>: _real(real), _imaginary(imaginary) {};</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>void operator+ ( Complex other ) {</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>            </span>_real = _real + other._real;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>            </span>_imaginary = _imaginary + other._imaginary;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>}</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>void operator&lt;&lt;( ostream os ) {</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>            </span>os &lt;&lt; "(" &lt;&lt; _real &lt;&lt; "," &lt;&lt; _imaginary &lt;&lt; ")";</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>}</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>Complex operator++() {</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>            </span>++_real;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>            </span>return *this;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>}</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>Complex operator++( int ) {</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>            </span>Complex temp = *this;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>            </span>++_real;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>            </span>return temp;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>}</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>private:</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>double _real, _imaginary;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>};</span></pre><p></p><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><b><span lang="en-us" xml:lang="en-us">[</span></b><b><span style="font-family:'宋体';">解答</span><span lang="en-us" xml:lang="en-us">]</span></b></p><p><b></b></p><b></b><p class="MsoNormal"><b><span lang="en-us" xml:lang="en-us"> </span></b><b><span lang="en-us" xml:lang="en-us">[</span></b><b><span style="font-family:'宋体';">前言</span><span lang="en-us" xml:lang="en-us">]</span></b><span style="font-family:'宋体';">：实际上，这个类所包含的错误比我们下面要讲述的还要多。但出这道难题的意图，与其说是要指出其设计得很差劲的接口，还不如说主要是为了体现类的构造技巧（比如，“典型的</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">operator&lt;&lt;</span><span style="font-family:'宋体';">是如何实现的？”，“应该把</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">operator+</span><span style="font-family:'宋体';">视为一个成员吗？”，等等）。不管怎么说吧，我将从非常有用的第</span><span lang="en-us" xml:lang="en-us">0</span><span style="font-family:'宋体';">点开始讲起……</span></p><p class="MsoNormal" style="margin-left:18pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us">0．<span style="font:7pt 'Times New Roman';">  </span></span><span style="font-family:'宋体';">既然标准库里面已经有一个</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">Complex</span><span style="font-family:'宋体';">类，何苦自己再写一个呢？（更何况标准库里的这一个是集业内最优秀的高手们多年经验之结晶，绝对不会出现下面讲述的任何一个问题。所以嘛，你还是“不耻复用”吧！）</span></p><p class="MsoNormal" style="margin-left:18pt;"><b><span lang="en-us" xml:lang="en-us">[</span></b><b><span style="font-family:'宋体';">学习指导</span><span lang="en-us" xml:lang="en-us">]</span></b><span style="font-family:'宋体';">：请复用标准库的算法，而不要编写自己的算法版本。这样做更快、更容易、更安全！</span><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-left:18pt;"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><pre><span lang="en-us" style="font-family:'宋体';font-size:10.5pt;" xml:lang="en-us">*</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>   </span>class Complex {</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>public:</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>Complex( double real, double imaginary = 0 )</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>          </span>: _real(real), _imaginary(imaginary) {};</span><span lang="en-us" xml:lang="en-us"> </span></pre><p></p><p class="MsoNormal" style="margin-left:18pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us">1．<span style="font:7pt 'Times New Roman';">  </span></span><span style="font-family:'宋体';">风格说明：这可以用作单一参数的构造函数（</span><span lang="en-us" xml:lang="en-us">constructor</span><span style="font-family:'宋体';">），包含着一个隐式的转换操作。但注意，并不总是要故意这样做！</span><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-left:18pt;"><b><span lang="en-us" xml:lang="en-us">[</span></b><b><span style="font-family:'宋体';">学习指导</span><span lang="en-us" xml:lang="en-us">]</span></b><span style="font-family:'宋体';">：千万要注意那些“悄悄进行的”转换操作。</span><span style="font-family:'宋体';">一个避免它的好办法就是尽可能显式（</span><span lang="en-us" xml:lang="en-us">explicit</span><span style="font-family:'宋体';">）的使用构造函数（</span><span lang="en-us" xml:lang="en-us">constructor</span><span style="font-family:'宋体';">）。</span><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-left:18pt;"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><pre><span lang="en-us" style="font-family:'宋体';font-size:10.5pt;" xml:lang="en-us">*</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>       </span>void operator+ ( Complex other ) {</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>            </span>_real = _real + other._real;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>            </span>_imaginary = _imaginary + other._imaginary;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>}</span><span lang="en-us" xml:lang="en-us"> </span></pre><p></p><p class="MsoNormal" style="margin-left:18pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us">2．<span style="font:7pt 'Times New Roman';">  </span></span><span style="font-family:'宋体';">风格说明：出于效率的考虑，其参数应该是</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">const&amp;</span><span style="font-family:'宋体';">；而且，像“</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">a = a + b</span><span style="font-family:'宋体';">”这样的语句应该被改写成“</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">a += b</span><span style="font-family:'宋体';">”。</span><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-left:18pt;"><b><span lang="en-us" xml:lang="en-us">[</span></b><b><span style="font-family:'宋体';">规则</span><span lang="en-us" xml:lang="en-us">]</span></b><span style="font-family:'宋体';">：请传递</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">const&amp;</span><span style="font-family:'宋体';">，而不要传递拷贝。</span><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-left:18pt;"><b><span lang="en-us" xml:lang="en-us">[</span></b><b><span style="font-family:'宋体';">学习指导</span><span lang="en-us" xml:lang="en-us">]</span></b><span style="font-family:'宋体';">：对于算术操作，请使用“</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">a op= b</span><span style="font-family:'宋体';">”的形式而不要使用“</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">a = a op b</span><span style="font-family:'宋体';">”的形式（当然，在有些类里面——你应该从来都没有写过这种类的吧！？（汗）——</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">op</span><span lang="en-us" xml:lang="en-us"> </span><span style="font-family:'宋体';">和</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">op=</span><span lang="en-us" xml:lang="en-us"> </span><span style="font-family:'宋体';">之间并不是原本的等价关系。这种情况除外。）。</span><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-left:18pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us">3．<span style="font:7pt 'Times New Roman';">  </span></span><span style="font-family:'宋体';">风格说明：</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">operator+</span><span style="font-family:'宋体';">不应该被视为成员函数。如果它像上面的代码里面那样是一个成员函数，那你就只能写“</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">a = b + 1</span><span style="font-family:'宋体';">”这样的语句而绝不能写成“</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">a = 1 + b</span><span style="font-family:'宋体';">”。出于效率的考虑，你还可能想要提供</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">operator+(Complex,int)</span><span style="font-family:'宋体';">和</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">operator+(int,Complex)</span><span style="font-family:'宋体';">。</span><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-left:18pt;"><b><span lang="en-us" xml:lang="en-us">[</span></b><b><span style="font-family:'宋体';">学习指导</span><span lang="en-us" xml:lang="en-us">]</span></b><span style="font-family:'宋体';">：对于把一个运算符视为成员函数还是非成员函数，请遵循</span><span lang="en-us" xml:lang="en-us">(Lakos96: 143-144; 591-595; Murray93: 47-49)</span><span style="font-family:'宋体';">中提到的规则，即</span><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-left:39pt;text-indent:-18pt;"><span lang="en-us" style="font-family:Wingdings;" xml:lang="en-us">l<span style="font:7pt 'Times New Roman';">       </span></span><span style="font-family:'宋体';">一元运算符是成员函数</span></p><p class="MsoNormal" style="margin-left:39pt;text-indent:-18pt;"><span lang="en-us" style="font-family:Wingdings;" xml:lang="en-us">l<span style="font:7pt 'Times New Roman';">       </span></span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">=</span><span style="font-family:'宋体';">，</span><span style="font-family:'宋体';">（）</span><span style="font-family:'宋体';">，</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">[]</span><span style="font-family:'宋体';">和</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">-&gt;</span><span style="font-family:'宋体';">必须是成员函数</span></p><p class="MsoNormal" style="margin-left:39pt;text-indent:-18pt;"><span lang="en-us" style="font-family:Wingdings;" xml:lang="en-us">l<span style="font:7pt 'Times New Roman';">       </span></span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">+=</span><span style="font-family:'宋体';">，</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">-=</span><span style="font-family:'宋体';">，</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">/=</span><span style="font-family:'宋体';">，</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">*=</span><span style="font-family:'宋体';">（等等）是成员函数</span></p><p class="MsoNormal" style="margin-left:39pt;text-indent:-18pt;"><span lang="en-us" style="font-family:Wingdings;" xml:lang="en-us">l<span style="font:7pt 'Times New Roman';">       </span></span><span style="font-family:'宋体';">所有其它的二元运算符是非成员函数</span><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-left:18pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us">4．<span style="font:7pt 'Times New Roman';">  </span></span><span style="font-family:'宋体';">错误说明：</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">operator+</span><span style="font-family:'宋体';">不应该改变这个对象的值，而应该返回一个包含相加结果的临时对象。注意，为了避免像“</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">a + b = c</span><span style="font-family:'宋体';">”这样的用法，返回类型应该是</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">const Complex</span><span style="font-family:'宋体';">（而不是</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">Complex</span><span style="font-family:'宋体';">）。</span><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-left:18pt;"><span style="font-family:'宋体';">（实际上，这部分代码反而更接近于</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">operator+=</span><span style="font-family:'宋体';">的实现，而不是</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">operator+</span><span style="font-family:'宋体';">实现。）</span><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-left:18pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us">5．<span style="font:7pt 'Times New Roman';">  </span></span><span style="font-family:'宋体';">风格说明：一般来说，如果你定义了</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">op</span><span style="font-family:'宋体';">，那你也应该同时定义</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">op=</span><span style="font-family:'宋体';">。就这里给出的代码而言，因为你定义了</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">operator+</span><span style="font-family:'宋体';">，所以你也应该同时定义</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">operator+=</span><span style="font-family:'宋体';">。如此一来，上面的函数无论如何都应该是对</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">operator+=</span><span style="font-family:'宋体';">的实现（只不过返回值拧过来了，见下面的叙述）。</span><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><pre><span lang="en-us" style="font-family:'宋体';font-size:10.5pt;" xml:lang="en-us">*</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>       </span>void operator&lt;&lt;( ostream os ) {</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>            </span>os &lt;&lt; "(" &lt;&lt; _real &lt;&lt; "," &lt;&lt; _imaginary &lt;&lt; ")";</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>}</span><span lang="en-us" xml:lang="en-us"> </span></pre><p></p><p class="MsoNormal"><span style="font-family:'宋体';">（<b>作者记</b>：对于一个正宗的</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">operator&lt;&lt;</span><span style="font-family:'宋体';">而言，你还应该考虑到做一些额外的事情，比如检查流当前的格式化标志（</span><span lang="en-us" xml:lang="en-us">format flag</span><span style="font-family:'宋体';">）以使其符合通常的用法。你可以查阅自己最好的</span><span lang="en-us" xml:lang="en-us">STL</span><span style="font-family:'宋体';">方面的书籍，以获得更多详细的描述。在此推荐几本：</span><span lang="en-us" xml:lang="en-us">Steve Teale</span><span style="font-family:'宋体';">的</span> <span style="font-family:'宋体';">《</span><span lang="en-us" xml:lang="en-us">C++ IOStreams Handbook</span><span style="font-family:'宋体';">》，</span><span lang="en-us" xml:lang="en-us">Glass </span><span style="font-family:'宋体';">和</span><span lang="en-us" xml:lang="en-us"> Schuchert</span><span style="font-family:'宋体';">的《</span><span lang="en-us" xml:lang="en-us">The STL &lt;Primer&gt;</span><span style="font-family:'宋体';">》，</span> <span style="font-family:'宋体';">还有</span><span lang="en-us" xml:lang="en-us">Plauger</span><span style="font-family:'宋体';">的《</span><span lang="en-us" xml:lang="en-us">The (Draft) Standard C++ Library</span><span style="font-family:'宋体';">》</span><span style="font-family:'宋体';">。</span><span style="font-family:'宋体';">）</span><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-left:18pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us">6．<span style="font:7pt 'Times New Roman';">  </span></span><span style="font-family:'宋体';">错误说明：</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">operator&lt;&lt;</span><span style="font-family:'宋体';">不应该是一个成员函数（见上面说过的规则）；而且参数应该为</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">(ostream&amp;, const Complex&amp;)</span><span style="font-family:'宋体';">。在这里还要注意，正如</span><span lang="en-us" xml:lang="en-us">James Kanze</span><span style="font-family:'宋体';">所说，不让其成为一个友元将会更好！相应的，可以通过调用一个公有（</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">public</span><span style="font-family:'宋体';">）的成员函数</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">print</span><span style="font-family:'宋体';">来解决问题。</span><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-left:18pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us">7．<span style="font:7pt 'Times New Roman';">  </span></span><span style="font-family:'宋体';">错误说明：函数的返回类型应该是</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">ostream&amp;</span><span style="font-family:'宋体';">；而且函数应该以“</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">return os;</span><span style="font-family:'宋体';">”语句结束，从而允许链式表达式（即是说，你可以写“</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">cout &lt;&lt; a &lt;&lt; b;</span><span style="font-family:'宋体';">”这样的语句）。</span><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-left:18pt;"><b><span lang="en-us" xml:lang="en-us">[</span></b><b><span style="font-family:'宋体';">规则</span><span lang="en-us" xml:lang="en-us">]</span></b><span style="font-family:'宋体';">：总是让</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">operator&lt;&lt;</span><span style="font-family:'宋体';">和</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">operator&gt;&gt;</span><span style="font-family:'宋体';">返回流引用（</span><span lang="en-us" xml:lang="en-us">stream reference</span><span style="font-family:'宋体';">）。</span><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><pre><span lang="en-us" style="font-family:'宋体';font-size:10.5pt;" xml:lang="en-us">*</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>       </span>Complex operator++() {</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>            </span>++_real;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span><span>        </span>return *this;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>}</span><span lang="en-us" xml:lang="en-us"> </span></pre><p></p><p class="MsoNormal" style="margin-left:18pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us">8．<span style="font:7pt 'Times New Roman';">  </span></span><span style="font-family:'宋体';">风格说明：先增（</span><span lang="en-us" xml:lang="en-us">preincrement</span><span style="font-family:'宋体';">）操作应该返回</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">Complex&amp;</span><span style="font-family:'宋体';">，让调用它的代码能够更直观的进行操作。</span></p><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span><span lang="en-us" xml:lang="en-us"> </span></p><p></p><pre><span lang="en-us" style="font-family:'宋体';font-size:10.5pt;" xml:lang="en-us">*</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>       </span>Complex operator++( int ) {</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>            </span>Complex temp = *this;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>            </span>++_real;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>            </span>return temp;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>}</span><span lang="en-us" xml:lang="en-us"> </span></pre><p></p><p class="MsoNormal" style="margin-left:18pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us">9．<span style="font:7pt 'Times New Roman';">  </span></span><span style="font-family:'宋体';">风格说明：后增（</span><span lang="en-us" xml:lang="en-us">postincrement</span><span style="font-family:'宋体';">）操作应该返回</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">const Complex</span><span style="font-family:'宋体';">。这可以避免像</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">a++++</span><span style="font-family:'宋体';">之类超出一个编码新手所能及的奇怪语句。</span><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="text-indent:17.85pt;"><span lang="en-us" xml:lang="en-us">10．</span><span style="font-family:'宋体';">风格说明：按照实现先增（</span><span lang="en-us" xml:lang="en-us">preincrement</span><span style="font-family:'宋体';">）操作的模式去实现后增（</span><span lang="en-us" xml:lang="en-us">postincrement</span><span style="font-family:'宋体';">）操作。</span><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="text-indent:21pt;"><b><span lang="en-us" xml:lang="en-us">[</span></b><b><span style="font-family:'宋体';">学习指导</span><span lang="en-us" xml:lang="en-us">]</span></b><span style="font-family:'宋体';">：请按照实现先增（</span><span lang="en-us" xml:lang="en-us">preincrement</span><span style="font-family:'宋体';">）操作的模式去实现后增（</span><span lang="en-us" xml:lang="en-us">postincrement</span><span style="font-family:'宋体';">）操作。</span><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><pre><span lang="en-us" style="font-family:'宋体';font-size:10.5pt;" xml:lang="en-us">*</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>   </span><span>  </span><span> </span>private:</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>      </span><span>  </span><span>  </span>double _real, _imaginary;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span><span>  </span>};</span><span lang="en-us" xml:lang="en-us"> </span></pre><p></p><p class="MsoNormal" style="margin-left:17.85pt;text-indent:-17.85pt;"><span lang="en-us" xml:lang="en-us">11．<span style="font:7pt 'Times New Roman';"> </span></span><span style="font-family:'宋体';">风格说明：尽量避免使用以下划线开头的名称。是的，我老是习惯性的使用它们；不错，一些像《</span><span lang="en-us" xml:lang="en-us">Design Patterns</span><span style="font-family:'宋体';">》（</span><span lang="en-us" xml:lang="en-us">Gamma et al</span><span style="font-family:'宋体';">）那样极受欢迎的书也这样使用它们。但是一方面，</span><span lang="en-us" xml:lang="en-us">C++</span><span style="font-family:'宋体';">标准为了某些实现上的原因而保留了一部分以下划线开头的标识符；另一方面，无论对于你还是对于编译器的编写者来说，要记住相关的规则都是很困难的。所以，你最好还是在自己的代码中避免使用以下划线开头的名称。（有鉴于我被禁止以下划线开头来表示我自己的成员变量之事实，我现在改用以下划线结尾的方式作为替代方案！）</span><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="text-indent:17.95pt;"><span style="font-family:'宋体';">好了。现在终于得到这个程序的正确代码版本，在这里我们忽略那些在上面没有提到过的有关设计和编码风格的问题：</span><span lang="en-us" xml:lang="en-us"> </span></p><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>class Complex {</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>public:</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>explicit Complex( double real, double imaginary = 0 )</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>          </span>: real_(real), imaginary_(imaginary) {}</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>Complex&amp; operator+=( const Complex&amp; other ) {</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>            </span>real_ += other.real_;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>            </span>imaginary_ += other.imaginary_;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>            </span>return *this;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>}</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>Complex&amp; operator++() {</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>            </span>++real_;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>            </span>return *this;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>}</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>const Complex operator++( int ) {</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>            </span>Complex temp = *this;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>            </span>++(*this);</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>       </span><span>     </span>return temp;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>}</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>ostream&amp; print( ostream&amp; os ) const {</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>            </span>return os &lt;&lt; "(" &lt;&lt; real_</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>                      </span>&lt;&lt; "," &lt;&lt; imaginary_ &lt;&lt; ")";</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>}</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>private:</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>double real_, imaginary_;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>friend ostream&amp; </span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>operator&lt;&lt;( ostream&amp; os, const Complex&amp; c );</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>};</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>const Complex operator+( const Complex&amp; lhs,</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>                             </span>const Complex&amp; rhs ) {</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>Complex ret( lhs );</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>ret += rhs;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>return ret;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>}</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>ostream&amp; operator&lt;&lt;( ostream&amp; os,</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>                         </span>const Complex&amp; c ) {</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>return c.print(os);</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>}</span><span lang="en-us" xml:lang="en-us"> </span></pre><p></p>                </div>                    </div>
1999	 GuruoftheWeek条款07：编译期的依赖性	function  class  iostream  string  struct  dependencies  	1003839180	1120	kingofark	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                         <p class="MsoNormal"><span lang="en-us" xml:lang="en-us">GotW #07 Compile-Time Dependencies</span></p><p class="MsoNormal"><span style="font-family:'宋体';">著者：</span><span lang="en-us" xml:lang="en-us">Herb Sutter<span>      </span></span></p><p class="MsoNormal"><span style="font-family:'宋体';">翻译：</span><span lang="en-us" xml:lang="en-us">kingofark</span></p><p class="MsoNormal"><span lang="en-us" xml:lang="en-us">[</span><span style="font-family:'宋体';">声明</span><span lang="en-us" xml:lang="en-us">]</span><span style="font-family:'宋体';">：本文内容取自</span><span lang="en-us" xml:lang="en-us">www.gotw.ca</span><span style="font-family:'宋体';">网站上的</span><span lang="en-us" xml:lang="en-us">Guru of the Week</span><span style="font-family:'宋体';">栏目，其著作权归原著者本人所有。译者</span><span lang="en-us" xml:lang="en-us">kingofark</span><span style="font-family:'宋体';">在未经原著者本人同意的情况下翻译本文。本翻译内容仅供自学和参考用，请所有阅读过本文的人不要擅自转载、传播本翻译内容；下载本翻译内容的人请在阅读浏览后，立即删除其备份。译者</span><span lang="en-us" xml:lang="en-us">kingofark</span><span style="font-family:'宋体';">对违反上述两条原则的人不负任何责任。特此声明。</span></p><p class="MsoNormal"><span lang="en-us" xml:lang="en-us">Revision 1.0</span></p><p class="MsoNormal"><b><span lang="en-us" xml:lang="en-us">Guru of the Week </span></b><b><span style="font-family:'宋体';">条款</span><span lang="en-us" xml:lang="en-us">07</span></b><b><span style="font-family:'宋体';">：编译期的依赖性</span><span lang="en-us" xml:lang="en-us">&lt;?xml:namespace prefix = o ns = "urn:schemas-microsoft-com:office:office" /&gt;</span></b></p><p><b></b></p><b></b><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';">难度：</span><span lang="en-us" xml:lang="en-us">7 / 10</span></p><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><i><span style="font-family:'宋体';">（大多数程序员使用</span></i><i><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">#include</span></i><i><span style="font-family:'宋体';">包含的头文件都比实际需要的多。你也是这样的吗？想知道的话，请看本条款。）</span><span lang="en-us" xml:lang="en-us"></span></i></p><p><i></i></p><i></i><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><b><span lang="en-us" xml:lang="en-us">[</span></b><b><span style="font-family:'宋体';">问题</span><span lang="en-us" xml:lang="en-us">]</span></b></p><p><b></b></p><b></b><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="text-indent:17.95pt;"><span lang="en-us" xml:lang="en-us">[</span><b><span style="font-family:'宋体';">注意</span></b><span style="font-family:'宋体';">：这个问题比想象的还要难！下面程序中的注释都是非常有用的。</span><span lang="en-us" xml:lang="en-us">]</span></p><p class="MsoNormal" style="text-indent:17.95pt;"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="text-indent:17.95pt;"><span style="font-family:'宋体';">大多数程序员使用</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">#include</span><span style="font-family:'宋体';">包含的头文件都比实际需要的要多。这会严重的影响并延长程序的建立时间（</span><span lang="en-us" xml:lang="en-us">build time</span><span style="font-family:'宋体';">），特别是当一个被频繁使用的头文件中包含了太多其它的头文件的时候，问题越发严重。<span lang="en-us" xml:lang="en-us"></span></span></p><p></p><p class="MsoNormal" style="text-indent:17.95pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="text-indent:17.95pt;"><span style="font-family:'宋体';">首先，在下面的头文件当中，有哪些</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">#include</span><span style="font-family:'宋体';">语句可以在不对程序产生副作用的情况下被直接去掉？其次，还有哪些</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">#include</span><span style="font-family:'宋体';">语句可以在对程序进行适当的修改之后被去掉？程序将如何修改？（你不能改变</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">X</span><span style="font-family:'宋体';">类和</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">Y</span><span style="font-family:'宋体';">类的公共接口；也就是说，你对这个头文件所作的任何修改都不能影响调用它的代码）。</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"></span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span></p><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>// gotw007.h (implementation file is gotw007.cpp)</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>//</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>#include "a.h"<span>  </span>// class A</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>#include "b.h"<span>  </span>// class B</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>#include "c.h"<span>  </span>// class C</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>#include "d.h"<span>  </span>// class D</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>                </span>// (</span><span>注意</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">: </span><span>只有</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">A</span><span>和</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">C</span><span>有虚拟函数（</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">virtual functions</span><span>）</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">)</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>#include &lt;iostream&gt;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>#include &lt;ostream&gt;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>#include &lt;sstream&gt;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>#include &lt;list&gt;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>#include &lt;string&gt;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>class X : public A {</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>public:</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>             </span>X<span>        </span>( const C&amp; );</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>D<span>    </span>Function1( int, char* );</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>D<span>    </span>Function1( int, C );</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>B&amp;<span>   </span>Function2( B );</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>void Function3( std::wostringstream&amp; );</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>std::ostream&amp; print( std::ostream&amp; ) const;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>private:</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>std::string<span>  </span>name_;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>std::list&lt;C&gt; clist_;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>D<span>            </span>d_;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>};</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const X&amp; x )</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>{ return x.print(os); }</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>class Y : private B {</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>public:</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>C<span>  </span>Function4( A );</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>private:</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>std::list&lt;std::wostringstream*&gt; alist_;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>};</span></pre><p></p><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><b><span lang="en-us" xml:lang="en-us">[</span></b><b><span style="font-family:'宋体';">解答</span><span lang="en-us" xml:lang="en-us">]</span></b></p><p><b></b></p><b></b><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="text-indent:17.95pt;"><span style="font-family:'宋体';">首先，我们考虑那些可以被直接去掉的</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">#include</span><span style="font-family:'宋体';">语句（或者说是头文件）。为了便于查看，我们再把原始的代码列在下面：</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"></span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span></p><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>// gotw007.h (</span><span>其实现文件为</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">gotw007.cpp)</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>//</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>#include "a.h"<span>  </span>// class A</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>#include "b.h"<span>  </span>// class B</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>#include "c.h"<span>  </span>// class C</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>#include "d.h"<span>  </span>// class D</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>                    </span>// (</span><span>注意</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">: </span><span>只有</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">A</span><span>和</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">C</span><span>有虚拟函数（</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">virtual functions</span><span>）</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">)</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>#include &lt;iostream&gt;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>#include &lt;ostream&gt;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>#include &lt;sstream&gt;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>#include &lt;list&gt;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>#include &lt;string&gt;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>class X : public A {</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>public:</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>             </span>X<span>        </span>( const C&amp; );</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>D<span>    </span>Function1( int, char* );</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>D<span>    </span>Function1( int, C );</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>B&amp;<span>   </span>Function2( B );</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>void Function3( std::wostringstream&amp; );</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>std::ostream&amp; print( std::ostream&amp; ) const;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>private:</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>     </span><span>   </span>std::string<span>  </span>name_;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>std::list&lt;C&gt; clist_;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>D<span>            </span>d_;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>};</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const X&amp; x )</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>{ return x.print(os); }</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>class Y : private B {</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>public:</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>C<span>  </span>Function4( A );</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>private:</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>std::list&lt;std::wostringstream*&gt; alist_;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>};</span></pre><p></p><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-left:18pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us">1．<span style="font:7pt 'Times New Roman';">  </span></span><span style="font-family:'宋体';">我们可以直接去掉的头文件有：</span></p><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-left:39pt;text-indent:-21pt;"><span lang="en-us" style="font-family:Wingdings;" xml:lang="en-us">l<span style="font:7pt 'Times New Roman';">         </span></span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">iostream</span><span style="font-family:'宋体';">，因为程序里尽管用到了流，但并没有用到</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">iostream</span><span style="font-family:'宋体';">里特定的东西。</span></p><p class="MsoNormal" style="margin-left:39pt;text-indent:-21pt;"><span lang="en-us" style="font-family:Wingdings;" xml:lang="en-us">l<span style="font:7pt 'Times New Roman';">         </span></span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">ostream</span><span style="font-family:'宋体';">和</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">sstream</span><span style="font-family:'宋体';">，因为程序中的参数和返回类型被前置声明（</span><span lang="en-us" xml:lang="en-us">forward-declared</span><span style="font-family:'宋体';">）是可以的，所以其实只需要</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">iosfwd</span><span style="font-family:'宋体';">就够了（要注意，并没有与</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">iosfwd</span><span style="font-family:'宋体';">相对应的诸如</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">stringfwd</span><span style="font-family:'宋体';">或者</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">listfwd</span><span style="font-family:'宋体';">之类的标准头文件；</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">iosfwd</span><span style="font-family:'宋体';">是考虑到向下兼容性问题的产物，它使得以前那些不支持模板的流子系统的代码仍然可用而不需要修改或者重写。）</span></p><p class="MsoNormal" style="margin-left:18pt;"><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-left:18pt;"><span style="font-family:'宋体';">我们不能直接去掉的</span><span style="font-family:'宋体';">头文件</span><span style="font-family:'宋体';">有：</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"></span></p><p></p><p class="MsoNormal" style="margin-left:18pt;"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-left:39pt;text-indent:-21pt;"><span lang="en-us" style="font-family:Wingdings;" xml:lang="en-us">l<span style="font:7pt 'Times New Roman';">         </span></span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">a.h</span><span style="font-family:'宋体';">，因为</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">A</span><span style="font-family:'宋体';">是</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">X</span><span style="font-family:'宋体';">的基类。</span></p><p class="MsoNormal" style="margin-left:39pt;text-indent:-21pt;"><span lang="en-us" style="font-family:Wingdings;" xml:lang="en-us">l<span style="font:7pt 'Times New Roman';">         </span></span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">b.h</span><span style="font-family:'宋体';">，因为</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">B</span><span style="font-family:'宋体';">是</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">Y</span><span style="font-family:'宋体';">的基类。</span></p><p class="MsoNormal" style="margin-left:39pt;text-indent:-21pt;"><span lang="en-us" style="font-family:Wingdings;" xml:lang="en-us">l<span style="font:7pt 'Times New Roman';">         </span></span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">c.h</span><span style="font-family:'宋体';">，因为现有的许多编译器需要</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">list&lt;C&gt;</span><span style="font-family:'宋体';">能够看见对</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">C</span><span style="font-family:'宋体';">的定义（这些编译器应该在未来的版本中修正这一点。）</span></p><p class="MsoNormal" style="margin-left:39pt;text-indent:-21pt;"><span lang="en-us" style="font-family:Wingdings;" xml:lang="en-us">l<span style="font:7pt 'Times New Roman';">         </span></span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">d.h</span><span style="font-family:'宋体';">，</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">list</span><span style="font-family:'宋体';">和</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">string</span><span style="font-family:'宋体';">，因为</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">X</span><span style="font-family:'宋体';">需要知道</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">D</span><span style="font-family:'宋体';">和</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">string</span><span style="font-family:'宋体';">的大小，</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">X</span><span style="font-family:'宋体';">和</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">Y</span><span style="font-family:'宋体';">都需要知道</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">list</span><span style="font-family:'宋体';">的大小。</span></p><p class="MsoNormal" style="margin-left:18pt;"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-left:18pt;"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="text-indent:17.95pt;"><span style="font-family:'宋体';">其次，我们再来考查那些可以通过隐藏</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">X</span><span style="font-family:'宋体';">和</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">Y</span><span style="font-family:'宋体';">的实现细节来被去掉的</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">#include</span><span style="font-family:'宋体';">语句（或者说是头文件）</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">:</span></p><p></p><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-left:18pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us">2．<span style="font:7pt 'Times New Roman';">  </span></span><span style="font-family:'宋体';">我们可以通过让</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">X</span><span style="font-family:'宋体';">和</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">Y</span><span style="font-family:'宋体';">使用</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">pimpl_</span><span style="font-family:'宋体';">的方法来去掉</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">d.h</span><span style="font-family:'宋体';">，</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">list</span><span style="font-family:'宋体';">和</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">string</span><span style="font-family:'宋体';">（也就是说，其私有部分被一个指针代替，这个指针指向类型被</span><span style="font-family:'宋体';">前置声明（</span><span lang="en-us" xml:lang="en-us">forward-declared</span><span style="font-family:'宋体';">）的</span><span style="font-family:'宋体';">实体对象）</span><span style="font-family:'宋体';">，因为这时，</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">X</span><span style="font-family:'宋体';">和</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">Y</span><span style="font-family:'宋体';">都不再需要知道</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">list</span><span style="font-family:'宋体';">、</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">D</span><span style="font-family:'宋体';">或者</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">string</span><span style="font-family:'宋体';">的大小。这也使我们可以干掉</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">c.h</span><span style="font-family:'宋体';">，因为这时在</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">X::clist</span><span style="font-family:'宋体';">中的</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">C</span><span style="font-family:'宋体';">对象只作为参数或者返回值出现。</span></p><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-left:18pt;"><b><span style="font-family:'宋体';">重要的事项</span></b><span style="font-family:'宋体';">：即使</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">ostream</span><span style="font-family:'宋体';">没有被定义，内联的</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">operator&lt;&lt;</span><span style="font-family:'宋体';">也可能仍然保持其内联性并使用其</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">ostream</span><span style="font-family:'宋体';">参数！这是因为你只在调用成员函数的时候才真正需要相应的定义；当你想接收一个对象，并只将其当成一个在其它函数调用时的参数而不做任何其它额外的事情时，你并不需要该函数的定义。</span></p><p class="MsoNormal" style="margin-left:18pt;"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';">最后，我们来看一下那些可以通过其它微小的修改而去掉的头文件：</span></p><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-left:18pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us">3．<span style="font:7pt 'Times New Roman';">  </span></span><span style="font-family:'宋体';">我们注意到</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">B</span><span style="font-family:'宋体';">是</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">Y</span><span style="font-family:'宋体';">的</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">private</span><span style="font-family:'宋体';">基类，而且</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">B</span><span style="font-family:'宋体';">没有虚拟函数（</span><span lang="en-us" xml:lang="en-us">virtual function</span><span style="font-family:'宋体';">），因此</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">b.h</span><span style="font-family:'宋体';">也是有可能被去掉的。有一个（也只有一个）主要的原因使我们在派生类的时候使用</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">private</span><span style="font-family:'宋体';">继承，那就是想要重载（</span><span lang="en-us" xml:lang="en-us">override</span><span style="font-family:'宋体';">）虚拟函数（</span><span lang="en-us" xml:lang="en-us">virtual function</span><span style="font-family:'宋体';">）。如此看来，在这里与其让</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">Y</span><span style="font-family:'宋体';">继承自</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">B</span><span style="font-family:'宋体';">，还不如让</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">Y</span><span style="font-family:'宋体';">拥有一个类型为</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">B</span><span style="font-family:'宋体';">的成员。要去掉</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">b.h</span><span style="font-family:'宋体';">，我们应该让</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">Y</span><span style="font-family:'宋体';">的这个</span><span style="font-family:'宋体';">类型为</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">B</span><span style="font-family:'宋体';">的成员存在于</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">Y</span><span style="font-family:'宋体';">中隐藏的</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">pimpl_</span><span style="font-family:'宋体';">部分。</span></p><p class="MsoNormal" style="margin-left:18pt;"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-left:18pt;"><b><span lang="en-us" xml:lang="en-us">[</span></b><b><span style="font-family:'宋体';">学习指导</span><span lang="en-us" xml:lang="en-us">]</span></b><span style="font-family:'宋体';">：请使用</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">pimpl_</span><span style="font-family:'宋体';">把代码的调用者与代码的实现细节隔离开来。</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"></span></p><p></p><p class="MsoNormal" style="margin-left:18pt;"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-left:18pt;"><span style="font-family:'宋体';">摘录自</span><span lang="en-us" xml:lang="en-us">GotW</span><span style="font-family:'宋体';">的编码标准：</span></p><p class="MsoNormal" style="margin-left:18pt;"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-left:57pt;text-indent:-18pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">—<span style="font:7pt 'Times New Roman';">     </span></span><span style="font-family:'宋体';">封装（</span><span lang="en-us" xml:lang="en-us">encapsulation</span><span style="font-family:'宋体';">）和隔离（</span><span lang="en-us" xml:lang="en-us">insulation</span><span style="font-family:'宋体';">）：</span></p><p class="MsoNormal" style="margin-left:54pt;text-indent:3pt;"><span style="font-family:'宋体';">—</span> <span style="font-family:'宋体';">在声明一个类的时候，应避免暴露出其私有成员：</span></p><p class="MsoNormal" style="margin-left:90pt;text-indent:-18pt;"><span style="font-family:'宋体';">—</span> <span style="font-family:'宋体';">应该使用一个形如“</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">struct Xxxxlmpl* pimpl_</span><span style="font-family:'宋体';">”的不透明的指针来存储私有成员（包括状态变量和成员函数），例如：</span></p><p class="MsoNormal" style="text-indent:94.5pt;"><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">class Map {private: struct Maplmpl* pimpl_;};</span></p><p></p><p class="MsoNormal" style="text-indent:94.5pt;"><span style="font-family:'宋体';">（</span><span lang="en-us" xml:lang="en-us">Lakos96: 398-405; Meyers92: 111-116; Murray93: 72-74</span><span style="font-family:'宋体';">）</span></p><p class="MsoNormal" style="text-indent:94.5pt;"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-left:18pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us">4．<span style="font:7pt 'Times New Roman';">  </span></span><span style="font-family:'宋体';">基于以下几个原因，我们目前还不能够对</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">a.h</span><span style="font-family:'宋体';">动手脚</span><span style="font-family:'宋体';">：</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">A</span><span style="font-family:'宋体';">被用作</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">public</span><span style="font-family:'宋体';">基类；</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">A</span><span style="font-family:'宋体';">含有虚拟函数（</span><span lang="en-us" xml:lang="en-us">virtual function</span><span style="font-family:'宋体';">），因而其</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">IS-A</span><span style="font-family:'宋体';">关系可能会被代码的调用者所使用。然而我们注意到，</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">X</span><span style="font-family:'宋体';">和</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">Y</span><span style="font-family:'宋体';">两个类之间没有任何关系，因此我们至少可以把</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">X</span><span style="font-family:'宋体';">和</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">Y</span><span style="font-family:'宋体';">的定义分别放到两个不同的头文件中间去（为了不影响现有的代码，我们还应该把现有的头文件作为一个存根（</span><span lang="en-us" xml:lang="en-us">stub</span><span style="font-family:'宋体';">），让其用</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">#include</span><span style="font-family:'宋体';">包含</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">x.h</span><span style="font-family:'宋体';">和</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">y.h</span><span style="font-family:'宋体';">）。如此以来，我们至少可以让</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">y.h</span><span style="font-family:'宋体';">不用</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">#include</span><span style="font-family:'宋体';">包含</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">a.h</span><span style="font-family:'宋体';">，因为现在它只把</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">A</span><span style="font-family:'宋体';">用作函数参数的类型，不需要</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">A</span><span style="font-family:'宋体';">的定义。</span></p><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';">综上所述，我们现在可以得到一个清爽的头文件了：</span></p><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>//---------------------------------------------------------------</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>// </span><span>新文件</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">x.h: </span><span>只包含两个</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">#include!</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>//</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>#include "a.h"<span>  </span>// class A</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>#include &lt;iosfwd&gt;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> <span>   </span>class C;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>class D;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>class X : public A {</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>public:</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>             </span>X<span>        </span>( const C&amp; );</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>D<span>    </span>Function1( int, char* );</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>D<span>    </span>Function1( int, C );</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>B&amp;<span>   </span>Function2( B );</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>void Function3( std::wostringstream&amp; );</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>std::ostream&amp; print( std::ostream&amp; ) const;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>private:</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>class XImpl* pimpl_;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>};</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>inline std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const X&amp; x )</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>{ return x.print(os); }</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>// </span><span>注意</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">: </span><span>这里不需要</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">ostream</span><span>的定义</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">!</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>//---------------------------------------------------------------</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>// </span><span>新文件</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">y.h: </span><span>没有</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">#include!</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>//</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>class A;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>class C;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>class Y {</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>public:</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>C<span>  </span>Function4( A );</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>private:</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>class YImpl* pimpl_;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>};</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>//---------------------------------------------------------------</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>// gotw007.h </span><span>作为存根包含两个</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">#include</span><span>，又通过</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">x.h</span><span>附带了另外两个</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">#include)</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>//</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>#include "x.h"</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>#include "y.h"</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>//---------------------------------------------------------------</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>// gotw007.cpp</span><span>中的新结构</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">... </span><span>注意：</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">impl </span><span>对象应该在</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">X</span><span>和</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">Y</span><span>的构造函数中</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"></span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>// </span><span>用</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">new</span><span>来创建，并在</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">X</span><span>和</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">Y</span><span>的析构函数中用</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">delete</span><span>来清除。</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"></span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>// X</span><span>和</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">Y </span><span>的成员函数要通过</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">pimpl_ </span><span>指针来访问数据</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"></span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>//</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>struct XImpl<span>    </span>// </span><span>是的</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">, </span><span>我们可以用</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">"struct" </span><span>，虽然前置声明的时候</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"></span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>{<span>               </span>// </span><span>我们用了</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">"class"</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>std::string<span>  </span>name_;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>std::list&lt;C&gt; clist_;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>D<span>            </span>d_;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>}</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>struct YImpl</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>{</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>std::list&lt;std::wostringstream*&gt; alist_;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>        </span>B b_;</span></pre><p></p><pre><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"><span>    </span>}</span></pre><p></p><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="text-indent:17.95pt;"><span style="font-family:'宋体';">最后说几句：到现在，</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">X</span><span style="font-family:'宋体';">的使用者只需要用</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">#include</span><span style="font-family:'宋体';">包含</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">a.h</span><span style="font-family:'宋体';">和</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">iosfwd</span><span style="font-family:'宋体';">就可以了。而</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">Y</span><span style="font-family:'宋体';">的使用者也只需要包含</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">a.h</span><span style="font-family:'宋体';">和</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">iosfwd</span><span style="font-family:'宋体';">，即使后来为了更新代码而需要包含</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">y.h</span><span style="font-family:'宋体';">并去掉</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">gotw007.h</span><span style="font-family:'宋体';">，也照样是一行</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">#include</span><span style="font-family:'宋体';">都不用多加。与原来的程序相比，这是多么大的改进呀！</span></p>                </div>                    </div>
2010	 详解<K's50PV>(上篇)	c++  microsoft  游戏  语言  borland  pascal  	1005293220	1591	kingofark	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                         <p align="center" class="MsoNormal" style="text-align:center;"><b><span lang="en-us" style="font-family:Arial;font-size:12pt;" xml:lang="en-us">Explanatory Notes On &lt;K's 50 PV&gt;&lt;?xml:namespace prefix = o ns = "urn:schemas-microsoft-com:office:office" /&gt;</span></b></p><p><b></b></p><b></b><p align="center" class="MsoNormal" style="text-align:center;"><span style="font-family:'黑体';font-size:12pt;">详解</span><b><span lang="en-us" style="font-family:Arial;font-size:12pt;" xml:lang="en-us">&lt;K's 50 PV &gt; Revision 1.0</span></b></p><p><b></b></p><b></b><p align="center" class="MsoNormal" style="text-align:center;"><b><span lang="en-us" style="font-family:Arial;font-size:12pt;" xml:lang="en-us">[</span></b><b><span style="font-family:'宋体';font-size:12pt;">上篇</span></b><b><span lang="en-us" style="font-family:Arial;font-size:12pt;" xml:lang="en-us">]</span></b></p><p><b></b></p><b></b><p align="center" class="MsoNormal" style="text-align:center;"><span lang="en-us" style="font-family:Arial;" xml:lang="en-us">by<span>  </span>Kingofark</span><span lang="en-us" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><b><span lang="en-us" xml:lang="en-us">[</span></b><b><span style="font-family:'宋体';">注</span><span lang="en-us" xml:lang="en-us">]</span></b><b><span style="font-family:'宋体';">：</span></b><span lang="en-us" xml:lang="en-us">&lt;</span><span lang="en-us" style="font-family:Arial;" xml:lang="en-us">K's 50 PV</span><span lang="en-us" xml:lang="en-us">&gt;</span><span style="font-family:'宋体';">是《</span><span lang="en-us" style="font-family:Arial;" xml:lang="en-us">Kingofark's 50 Points of View About Learning C++ And Programming</span><span style="font-family:'宋体';">（</span><span lang="en-us" style="font-family:Arial;" xml:lang="en-us">kingofark</span><span style="font-family:'宋体';">关于学习</span><span lang="en-us" style="font-family:Arial;" xml:lang="en-us">C++</span><span style="font-family:'宋体';">和编程的</span><span lang="en-us" xml:lang="en-us">50</span><span style="font-family:'宋体';">个观点）》的简称；</span><span lang="en-us" xml:lang="en-us">&lt;</span><span lang="en-us" style="font-family:Arial;" xml:lang="en-us">K's 35 MPV</span><span lang="en-us" xml:lang="en-us">&gt;</span><span style="font-family:'宋体';">是《</span><span lang="en-us" style="font-family:Arial;" xml:lang="en-us">Kingofark's 35 More Points of View About Learning C++ And Programming</span><span style="font-family:'宋体';">（</span><span lang="en-us" style="font-family:Arial;" xml:lang="en-us">kingofark</span><span style="font-family:'宋体';">关于学习</span><span lang="en-us" style="font-family:Arial;" xml:lang="en-us">C++</span><span style="font-family:'宋体';">和编程的另
2014	 kingofark的第0个五评计划-kingofark自述与简介	汇编  c++  语言  工作  c  	1005648660	1103	kingofark	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p class="MsoNormal" style="margin:0cm 0cm 0pt;"><font size="3"><strong><span lang="en-us" xml:lang="en-us">kingofark</span><span style="font-family:'宋体';">的第</span><span lang="en-us" xml:lang="en-us">0</span><span style="font-family:'宋体';">个“五评计划”——</span><span lang="en-us" xml:lang="en-us">kingofark</span><span style="font-family:'宋体';">自述与简介</span></strong></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> &lt;?xml:namespace prefix = o ns = "urn:schemas-microsoft-com:office:office" /&gt;</font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><font size="3"><strong><span lang="en-us" xml:lang="en-us">[</span><span style="font-family:'宋体';">声明</span><span lang="en-us" xml:lang="en-us">]</span></strong><span style="font-family:'宋体';"><strong>：</strong>本文由</span><span lang="en-us" xml:lang="en-us">kingofark</span><span style="font-family:'宋体';">创作。本文中的所有内容仅代表</span><span lang="en-us" xml:lang="en-us">kingofark</span><span style="font-family:'宋体';">个人的观点，与任何其他个人和团体无关。任何人或团体都可以复制、传播本文，但需附上完整的本声明。</span><span lang="en-us" xml:lang="en-us">kingofark</span><span style="font-family:'宋体';">对于不同意上述各点或不履行上述各要求的人或团体的言行不负任何责任。特此声明。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><font size="3"><strong><span lang="en-us" xml:lang="en-us">[</span><span style="font-family:'宋体';">概要</span><span lang="en-us" xml:lang="en-us">]</span></strong><span style="font-family:'宋体';"><strong>：</strong>本条款介绍了本文作者</span><span lang="en-us" xml:lang="en-us">kingofark</span><span style="font-family:'宋体';">和《</span><span lang="en-us" xml:lang="en-us">kingofark</span><span style="font-family:'宋体';">的“五评计划”》的基本内容。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><font size="3"><strong><span lang="en-us" xml:lang="en-us">[</span><span style="font-family:'宋体';">关于</span><span lang="en-us" xml:lang="en-us">kingofark]</span><span style="font-family:'宋体';">：</span></strong></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:17.95pt;"><font size="3"><span lang="en-us" xml:lang="en-us">kingofark</span><span style="font-family:'宋体';">是一个普通的</span><span lang="en-us" xml:lang="en-us">CSDN</span><span style="font-family:'宋体';">注册用户。男，</span><span lang="en-us" xml:lang="en-us">1979</span><span style="font-family:'宋体';">年出生，有一点点丑。曾在武汉理工大学就读于计算机科学与技术学院，进修计算机专业。学过一点</span><span lang="en-us" xml:lang="en-us">C++</span><span style="font-family:'宋体';">；学过一点点</span><span lang="en-us" xml:lang="en-us">C</span><span style="font-family:'宋体';">；学过一点点点汇编语言；学过一点点点点其它技术（汗）。毕业后在北京工作。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:17.95pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:17.95pt;"><span style="font-family:'宋体';"><font size="3">梦想：当一名画家；当一名导演和摄影师；</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:17.95pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:17.95pt;"><span style="font-family:'宋体';"><font size="3">理想：作一个优秀的程序员；</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:17.95pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:17.95pt;"><span style="font-family:'宋体';"><font size="3">喜爱的名言：</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:17.95pt;"><font size="3"><span style="font-family:'宋体';">“</span><span lang="en-us" xml:lang="en-us">God is a concept by which we measure our pain.</span><span style="font-family:'宋体';">”——</span><span lang="en-us" xml:lang="en-us">John Lennon</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:17.95pt;"><font size="3"><span style="font-family:'宋体';">“</span><span lang="en-us" xml:lang="en-us">I have understanding as well as you; I am not inferior to you.</span><span style="font-family:'宋体';">”——</span><span lang="en-us" xml:lang="en-us">Job xii</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:17.95pt;"><font size="3"><span style="font-family:'宋体';">“</span><span lang="en-us" xml:lang="en-us">Don’t be afraid to attempt the impossible. Simply knowing what is impossible is useful knowledge and you may well find, in the wake of some unexpected success, that not half of the things we call impossible have any right at all to wear the label.</span><span style="font-family:'宋体';">”——</span><span lang="en-us" xml:lang="en-us">Michael Abrash</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:17.95pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:17.95pt;"><font size="3"><span lang="en-us" xml:lang="en-us">E-mail</span><span style="font-family:'宋体';">：</span><span lang="en-us" xml:lang="en-us">kingofark@sina.com</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><font size="3"><strong><span lang="en-us" xml:lang="en-us">[</span><span style="font-family:'宋体';">“五评计划”简介</span><span lang="en-us" xml:lang="en-us">]</span><span style="font-family:'宋体';">：</span></strong></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:17.95pt;"><font size="3"><span lang="en-us" xml:lang="en-us">kingofark</span><span style="font-family:'宋体';">的“五评计划”旨在向广大初学者“推荐”计算机领域相关的书籍，为广大初学者的学习助微薄之力。从《</span><span lang="en-us" xml:lang="en-us">kingofark</span><span style="font-family:'宋体';">的第</span><span lang="en-us" xml:lang="en-us">1</span><span style="font-family:'宋体';">个“五评计划”》开始，每一个条款都会列出五本书进行“推荐”，给出</span><span lang="en-us" xml:lang="en-us">kingofark</span><span style="font-family:'宋体';">的“推荐度”，并说明推荐理由。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:17.95pt;"><span style="font-family:'宋体';"><font size="3">推荐度会以这样的形式出现：</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><font size="3"><span lang="en-us" xml:lang="en-us">[</span><span style="font-family:'宋体';">推荐度</span><span lang="en-us" xml:lang="en-us">]</span><span style="font-family:'宋体';">：</span><span lang="en-us" xml:lang="en-us">n /</span><span style="font-family:'宋体';">（</span><span lang="en-us" xml:lang="en-us">-5,5</span><span style="font-family:'宋体';">）</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:17.95pt;"><font size="3"><span style="font-family:'宋体';">其中，</span><span lang="en-us" xml:lang="en-us">n</span><span style="font-family:'宋体';">表示推荐度，</span><span lang="en-us" xml:lang="en-us">-5 &lt;= n &lt;= 5</span><span style="font-family:'宋体';">。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:17.95pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:17.95pt;"><font size="3"><span lang="en-us" xml:lang="en-us">n &gt; 0</span><span style="font-family:'宋体';">，表示书值得一看，</span><span lang="en-us" xml:lang="en-us">n </span><span style="font-family:'宋体';">越大，</span><span lang="en-us" xml:lang="en-us">kingofark</span><span style="font-family:'宋体';">觉得书越好；</span><span lang="en-us" xml:lang="en-us">n &lt; 0</span><span style="font-family:'宋体';">，表示……呃，不用我说了吧！？</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><font size="3"><strong><span lang="en-us" xml:lang="en-us">[</span><span style="font-family:'宋体';">反馈</span><span lang="en-us" xml:lang="en-us">]</span><span style="font-family:'宋体';">：</span></strong></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:17.95pt;"><font size="3"><span style="font-family:'宋体';">如果您有任何意见、建议、异议，请毫不犹豫的告知</span><span lang="en-us" xml:lang="en-us">knigofark</span><span style="font-family:'宋体';">。</span><span lang="en-us" xml:lang="en-us">kingofark</span><span style="font-family:'宋体';">欢迎大家的批评、指正。</span><span lang="en-us" xml:lang="en-us">E-mail</span><span style="font-family:'宋体';">：</span><span lang="en-us" xml:lang="en-us">kingofark@sina.com</span></font></p>                </div>                    </div>
2165	 ASP.NET：革命，不是革新	asp.net  web服务  button  textbox  asp  脚本编程语言  	1013077260	2218	zdg	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p>微软本来只需要对Web应用平台ASP作稍加改进，比方提供一个功能更强的服务器端脚本编程语言或者页面编译功能就可以保持或者甚至提高ASP的流行度。实际上ASP.NET提供了这两个功能--但是它还提供了更多的东西。简单的说，ASP.NET是一场革命。在本文中，我将讨论ASP.NET对于Web编程所做的提高。</p><br/><p>在ASP模型中，一个页面是通过HTML定义然后是通过嵌入的脚本扩展的。在ASP.NET中，不同的是，一个页面是一个生成HTML的类。这个模型被称为WebForm。如果这个名字让你想起VB6的表单控件或者.Net WinForms，那么你摸到点边了。对于WebForms来说，Web服务器控件都放在一个页面上。当这个页面被访问的时候，这些控件自动将它们以HTML的方式实现。浏览器和服务器之间的复杂过程对程序员来说是透明的，由服务器自动完成，并允许事件处理，就和WinForms一样。</p><br/><h4>欢迎页面</h4><br/><p>让我们马上开始创建一个叫Greeter（欢迎者）的例子然后看看它是如何工作的。我在学习一个新技术的时候喜欢将它们拆开然后再凑成一整块。Greeter仅仅是要求用户输入一个名字然后发出一条问候消息，但是它演示了ASP.NET的几个主要特点。</p><br/><p>Greeter页面定义在两个文件中：Greeter.aspx，在列表A中，和Greeter.aspx.cs，在列表B中。.aspx文件定义了页面的UI（用户界面），而C#文件（你也可以使用Visual Basic.Net或者 JScript.Net）在GreeterLogic类里实现了这个页面的逻辑。Greeter.aspx文件第一行的@Page指令通过继承将UI绑定在程序逻辑上。这个指令中的ClassName属性将UI类的名字指定为CreeterUI。而Inherits属性指定GreeterUI是从GreeterLogic继承而来的。</p><br/><h4>Web服务器端控件</h4><br/><p>在这个页面的&lt;form&gt;置标中申明了几个Web服务器端控件。Web服务器端控件是标准HTML置标的WebForm抽象化。它们与标准的HTML相比能够提供事件处理并生成更多的功能。Web服务器端控件在一个引用asp命名空间的XML置标里被申明。.aspx文件中的每一个Web服务器控件在页面被执行的时候会导致控件的一个实例被创建。对每个实例的引用在其相应的基类中被保持。这便使得基类能够访问这些控件并能够让它用程序控制这些控件并处理这些控件产生的事件。每个Web服务器端控件指定属性runat="server"来表明这个控件在Web服务器端运行以便为目标Web浏览器生成合适的HTML。Greeter的初始状态在图A中显示出来。</p><br/><p align="center"><img alt="previewart.gif" border="1" height="270" src="http://www.zdnet.com.cn/developer/graphics/20037064/previewart.gif" width="398"/><br/>图A</p><br/><p>最开始的三个Web服务器端控件是相当直观的：标签控件（label），文本框，和一个提交按纽。最后的一个控件，&lt;asp:RequiredFieldValidator&gt;，是不同的。一个验证控件检查另一个控件的状态并且当目标控件没有处于正确状态的时候会阻止这个表单被提交。在Greeter这个程序中，RequiredFieldValidator控件被用来验证一个数据是否已经被输入到了文本框控件里。它并不关心这个数据的值是多少。初始状态下，RequiredFieldValidator控件是不可见的。如果在按纽被单击的时候文本框是空的，那么就不会产生单击消息，而且RequiredFieldValidator控件会显示ErrorMessage属性的属性值，如图B。对于高版本的浏览器来说，RequiredFieldValidator控件生成JavaScript以在客户端进行数据验证。而对于低版本的浏览器来说则需要在服务器端进行验证。ASP.NET除了RequiredFieldValidator控件外还提供了几个验证控件。</p><br/><p align="center"><img alt="previewart(1).gif" border="1" height="270" src="http://www.zdnet.com.cn/developer/graphics/20037064/previewart(1).gif" width="398"/><br/>图B</p><br/><h4>GreeterLogic类</h4><br/><p>GreeterLogic从类System.Web.UI.Page继承而来。它申明了几个protected数据域来保存对Greeter.aspx文件中创建的控件的引用。GreeterLogic定义了两个方法。OnInit方法重载了方法Page.OnInit来为m_Button单击事件添加一个m_Button_Click方法的代理。m_Button_Click方法处理由m_Button Web服务器端控件生成的单击事件。这个单击事件触发一个到服务器端的数据发送过程。在服务器端，ASP.NET重新生成这个页面然后恢复WEb服务器控件的状态。现在文本框的值就可以通过访问TextBoxText属性得到了。图C显示了由m_Button_Click生成的响应消息。</p><br/><p align="center"><img alt="previewart(2).gif" border="1" height="270" src="http://www.zdnet.com.cn/developer/graphics/20037064/previewart(2).gif" width="398"/><br/>图C</p><br/><h4>配置Greeter程序</h4><br/><p>要配置Greeter应用程序，你可以遵循下面的步骤：</p><br/><p>创建一个应用程序的目录。</p><br/><p>在应用程序的目录里创建一个bin子目录。</p><br/><p>把Greeter.aspx放在应用程序目录里。</p><br/><p>使用命令csc /t:library /out:Greeter.dll Greeter.aspx.cs把Greeter.aspx.cs编译成一个库文件然后把Greeter.dll放在应用程序的bin子目录里。</p><br/><p>创建一个指向应用程序目录的IIS虚拟目录。</p><br/><h4>.aspx类的生成</h4><br/><p>ASP.NET应用程序是由IIS ISAPI过滤器aspnet_isapi.dll处理的。在第一次访问的时候，ISAPI过滤器在ASP命名空间下从Greeter.aspx生成一个.NET类然后把它编译成一个二进制库文件。IIS会自动搜索应用程序的bin子目录来寻找GreeterLogic基类。图D显示了生成的类的继承关系。生成的二进制文件会放在一个根据应用程序的虚拟目录而生成的一个存放临时ASP.NET文件的目录里。例如，如果Greeter的虚拟目录被命名被IntroASPNET，那么Greeter.aspx可能会生成一个名字为effla-hh.dll的二进制文件，并且放在诸如C:/WINNT/Microsoft.NET/Framework/v1.0.3328/Temporary ASP.NET Files/introaspnet/b5d8b0af/51648ab7这样的一个目录里。</p><br/><p>如果Greeter.aspx被修改了，那么ISAPI过滤器会在下一次页面访问的时候自动重新生成二进制文件。</p><br/><p align="center"><img alt="previewart(3).gif" border="0" height="312" src="http://www.zdnet.com.cn/developer/graphics/20037064/previewart(3).gif" width="293"/><br/>图D</p><br/><h4>ASP.NET是实打实面向对象的</h4><br/><p>那么所有这些意味着什么呢？ASP.NET提供了一个真正的面向对象的编程模型。WebForms能够让页面的UI完全独立于页面的逻辑而被创建然后通过继承而结合起来。不会再有夹杂着HTML和VBScript的页面了。页面的逻辑是使用一种全功能的.NET语言，比方C#, Visual Basic.NET, 或者 Jscript.NET实现的。更进一步的说，页面逻辑的实现过程可以随意使用所有的.NET基类类库。Web服务器控件封装了不同Web浏览器之间的区别并允许你从更高的级别来设计Web页面。所有的一切都会被编译成微软中间语言（MSIL）并且能够在运行时同步转化成机器码。不会再有解释性页面中存在的那种性能损失了。如果这还不能叫做一种革命的话，我就真的需要一本新的字典了:-)。<br/><br/><br/></p><table><tbody><tr><td class="subhead1">Listing A: Greeter.aspx</td></tr><tr bgcolor="#ff0000"><td height="1"><img alt="spacer.gif" height="1" src="http://www.zdnet.com.cn/developer/tech/story/spacer.gif" width="1"/></td></tr><tr><td height="5"><img alt="spacer.gif" height="5" src="http://www.zdnet.com.cn/developer/tech/story/spacer.gif" width="1"/></td></tr><tr><td><pre> &lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Greeter.aspx&lt;/title&gt;<br/>  &lt;/head&gt;<br/><br/>  &lt;body&gt;<br/><br/>    &lt;form id="QueryName" method="post" runat="server"&gt;<br/><br/>      &lt;!-- Heading --&gt;<br/>      &lt;asp:Label id="m_Heading" runat="server"<br/>        Font-Bold="true"<br/>        Font-Size="16pt"<br/>        Text="Please enter your name:"&gt;<br/>      &lt;/asp:Label&gt;<br/><br/>      &lt;br&gt;<br/><br/>      &lt;!-- Input controls --&gt;<br/>      &lt;asp:Label id="m_Label" runat="server" Font-Bold="True" Text="Name:"&gt;&lt;/asp:Label&gt;<br/>      &lt;asp:TextBox id="m_TextBox" runat="server" Width="152px"&gt;&lt;/asp:TextBox&gt;<br/>      &lt;asp:Button id="m_Button" runat="server" Text="Get Greeting"&gt;&lt;/asp:Button&gt;<br/><br/>      &lt;br&gt;<br/><br/>      &lt;!-- Input validation --&gt;<br/>      &lt;asp:RequiredFieldValidator id="m_Validator" runat="server"<br/>        ControlToValidate="m_TextBox"<br/>        ErrorMessage="You haven't entered your name!"<br/>        ForeColor="Red"&gt;<br/>      &lt;/asp:RequiredFieldValidator&gt;<br/><br/>    &lt;/form&gt;<br/>  &lt;/body&gt;<br/> &lt;/html&gt;</pre></td></tr></tbody></table><br/><table><tbody><tr><td class="subhead1">Listing B: Greeter.aspx.cs</td></tr><tr bgcolor="#ff0000"><td height="1"><img alt="spacer.gif" height="1" src="http://www.zdnet.com.cn/developer/tech/story/spacer.gif" width="1"/></td></tr><tr><td height="5"><img alt="spacer.gif" height="5" src="http://www.zdnet.com.cn/developer/tech/story/spacer.gif" width="1"/></td></tr><tr><td><pre>using System;<br/><br/>namespace TechRepublic<br/>{<br/>  public class GreeterLogic : System.Web.UI.Page<br/>  {<br/>    // Protected data members:<br/>    //   - Server controls created by the .aspx derived class.<br/>    protected System.Web.UI.WebControls.Label   m_Heading;<br/>    protected System.Web.UI.WebControls.Label   m_Label;<br/>    protected System.Web.UI.WebControls.TextBox m_TextBox;<br/>    protected System.Web.UI.WebControls.Button  m_Button;<br/>    protected System.Web.UI.WebControls.RequiredFieldValidator m_Validator;<br/><br/>    // Initialize the page.<br/>    override protected void OnInit( EventArgs e )<br/>    {<br/>      // Attach an event handler for the GetGreeting button click.<br/>      this.m_Button.Click += new System.EventHandler( this.m_Button_Click );<br/><br/>      // Initialize the base class.<br/>      base.OnInit( e );<br/>    }<br/> <br/>    // Handle the "Get Greeting" button click.<br/>    private void m_Button_Click( object sender, System.EventArgs e )<br/>    {<br/>      // Set the greeting in the heading.<br/>      m_Heading.Text = "Greetings " + m_TextBox.Text + "!";<br/><br/>      // Hide the label, text box and button.<br/>      m_Label.Visible = false;<br/>      m_TextBox.Visible = false;<br/>      m_Button.Visible = false;<br/>    }<br/>  }<br/>}</pre></td></tr></tbody></table>                </div>                    </div>
2430	 姗姗来迟的乐趣——书评《模式的乐趣》	设计模式  java  出版  uml  读书  工具  	1069174320	2839	gigix	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <table align="center" bgcolor="#ffffff" border="0" cellpadding="4" cellspacing="0" class="font-2" width="612"><tbody><tr><td bgcolor="#ffffff" valign="top" width="604"><div align="center"><font color="#ff0000"></font><p align="center"><span style="font-size:20pt;line-height:32pt;"><b>姗姗来迟的乐趣</b></span></p><p align="center"><span style="font-size:20pt;line-height:32pt;"><b><font size="2">（本文首发于《中华读书报》2003年10月22日号）</font></b></span></p></div></td></tr><tr><td bgcolor="#ffffff" valign="top" width="604"><div align="center"></div></td></tr><tr><td bgcolor="#ffffff" valign="top" width="604"><div align="center">熊节</div></td></tr><tr><td bgcolor="#ffffff" height="2" valign="top" width="604"><p align="center"><img alt="CSDN_Dev_Image_2003-11-92056221.GIF" height="1" src="/Develop/ArticleImages/22/22038/CSDN_Dev_Image_2003-11-92056221.GIF" width="610"/></p></td></tr></tbody></table><center></center><p><span style="font-size:11pt;line-height:16pt;">　　钱锺书曾有一句话，大意是说：衣袋里的钱虽然也是自己的钱，翻出来的时候却总觉得是意外的财喜。不经意间发现这本迁延经年的《模式的乐趣》（清华大学出版社2003年9月）竟然付梓，我的心境大抵就是从新换的上衣袋里翻出了钱，倒是一个不大不小的惊喜了。如果译者也可以算是翻译作品的养父，我想，我应当有责任为这个被冷遇的孩子说上几句。 <br/><br/>　　再次打开尘封已久的译稿，或许颇可以令我欣慰的是这部“早年作品”的译笔竟也不像想象中的那么不堪——“小时候干的营生”虽然显得有些突兀，倒还不至于令我“骇而笑”。单就翻译而言，或许最大的缺憾莫过于没有为这个可怜的孩子写上一篇译序。一时的疏忽让它多少有些像个孑然的孤儿。 <br/><br/>　　公正地说，这本《模式的乐趣》最大的败笔就是……来得太晚。AMAZON网站上，有一位读者的评价很是中肯：“可以把这本书看作《设计模式》的简写版——用更易懂的话语。不过与《设计模式解析》（电力出版社2003年7月影印版）比起来，后者又更胜一筹。”本应当作为读完《设计模式》、初识模式的精妙时第一本入门读物的《模式的乐趣》，却偏偏在更多的预期读者已经拥有了模式的常识之后才姗姗来迟——而且恰好还晚于《设计模式解析》（尽管后者只推出了原文影印版）。于是，自然地，它被置于一个相当尴尬的境地：区区百余页的篇幅使它不足以满足读者求知的渴望。或许，正像它的名字一样，只能希望它夹在其他干瘪或者不那么干瘪的宏篇巨著中，给读者带来一点“乐趣”吧。 <br/><br/>　　它的另一个尴尬则出现在英文原版的标题上：副标题“Using Patterns for Enterprise Development”是彻头彻尾的名不符实，或许仅仅因为“enterprise”这个词听上去很酷，作者Brandon Goldfedder才会乐于让它在标题中出现。是的，这本书与我们常说的“企业级开发”毫不搭界，它是一本真正的模式入门教材。在为阎宏博士的《Java与模式》作评时，我曾经提到“模式教材的四要素”，这本薄薄的小书倒是忠实地符合了这四点要求：它用通俗易懂的方式引荐了C.Alexander的模式理论，它合理地介绍了面向对象设计的基础，它不厌其详地阐释了几个重要的GoF模式的原理和用法，它描述程序结构所用的工具是UML和Java。作为另一本模式的入门教材，《模式的乐趣》的164页和《Java与模式》的1K页相映成趣，倒也算得上一对“可怕的对称”——这或许该是《模式的乐趣》的另一个优势：读者会乐于在公共汽车上阅读它。 <br/><br/>　　不过，尽管并没有给自己留出太多空间，Goldfedder倒是不吝惜漂亮的点子。作为一位专职顾问，他似乎很愿意为自己缺乏深度的作品增加一些广度。《模式的乐趣》涉足了这个圈子里几乎所有时髦的话题：代码复审／设计复审、James Coplien的共同点／变化点分析、组件技术、William Opdyke的博士论文、Martin Fowler的《重构》、XP……自然，以最简略的方式。不可否认，这些还算恰如其分的点缀让这本小书多了一些阅读时的乐趣，我打赌会有读者喜欢这种口味。而在介绍具体模式的细节时，它看上去更像是Wrox的Expert One－to－One。尽管我并不赞同在一本模式专著中加入太多的代码，但一个立竿见影的实例也许的确能够帮助初学者找到把握局面的信心。 <br/><br/>　　说到底，同时作为译者和一个挑剔的读者，我应该如何评价这本《模式的乐趣》？AMAZON上另一位读者的评论引起了我的兴趣：“在读了《烹调的乐趣》和《性的乐趣》之后，这是我所读的第三本《xx的乐趣》，多么有意思的阅读体验。”无厘头的批评套路，或许很适合这本散发出尴尬的幽默气息的入门教材。</span></p>                </div>                    </div>
2600	 JavaTM安全体系结构2	applet  java  jdk  程序开发  网络  sun  	988996560	746	wxyxl	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p><br/><font face="宋体" size="3">Java<sup>TM</sup>安全体系结构（JDK1.2）</font> </p><dl><dd><br/><br/></dd><dd><b><font size="4">2. 新的保护机制──基本概念概述</font></b><br/><br/></dd><dd>现在，我们讨论一下新的保护体系结构，并对它的功能性做一个简要的说明。我们将从新体系结构的基本概念说起，然后按自然顺序介绍主要的新类，即先从许可说明开始，然后是策略和有关特性及访问控制和它的使用，最后是安全类装载和解决方案。 <br/><br/></dd><dd>一个基本的概念和系统安全性的重要积木是保护域。一个域可通过对象集来划分范围，这些对象当前可由一个主体直接访问。而主体是在计算机系统中被授予许可（许可的结果是可说明的）的实体。JDK1.0所利用的沙箱就是一个有着固定边界的保护域实例。 <br/><br/></dd><dd>保护域的概念是一种在保护单元间起着分组和隔离作用的便利机制。例如，我们可以（还没有作为一种内置特性来提供给用户）将保护域分开以避免它们之间的直接交互作用，于是，任何允许的交互作用必须通过可信系统代码或被有关的域所明确允许。请注意，在新的安全体系结构下，现存对象访问规则仍然有效。 <br/><br/></dd><dd><p align="center">保护域通常分为明确的两个类别：系统域和应用程序域。重要的是，所有被保护的外部资源（如文件系统、网络设施以及屏幕和键盘等）仅能通过系统域来访问。下图演示了一个Java应用环境的域的组成。 <br/><img alt="jdk-chart4.gif" border="0" height="164" src="http://www.cnjavaclub.com/03/java_security/JDK12SA/jdk-chart4.gif" width="305"/><br/></p></dd><dd><p align="center">从概念上讲，一个域包括一组类，这些类的实例被授予相同的一组许可。保护域是由现行策略所确定的。Java应用程序环境保持了来自代码（类和实例）到它们的保护域然后再到它们的许可的映射。如下图所示： <br/><img alt="jdk-chart5.gif" border="0" height="200" src="http://www.cnjavaclub.com/03/java_security/JDK12SA/jdk-chart5.gif" width="400"/><br/></p></dd><dd>执行的一个线程（它经常是一个单一的Java线程，但也不一定依赖于这个单一的Java线程，也不依赖于底层操作系统的线程概念）可能完全发生在一个单一的保护域中，也可能涉及一个应用程序域或是系统域。例如，一个打印消息的应用程序将不得不与系统域发生交互作用，因为系统域是唯一对输出流的访问点。在次种情况下，无论在任何时候，应用程序域都不能通过调用系统域获得除打印消息外的任何额外许可。这点至关重要。否则，可能会出现严重的安全隐患。 <br/><br/></dd><dd>在相反的情形，一个系统域从一个应用程序域中调用一个方法，如当一个AWT系统域调用一个Applet的绘画方法来显示这个Applet时，有效访问权限与应用程序域所允许的当前权限在任何时候都相同，这一点也是同样至关重要的。 <br/><br/></dd><dd>换句话说，一个并非"强大"的域不能通过调用一个更强大的域，或被一个更强大的域所调用来获得额外的许可。 <br/><br/></dd><dd>上述有关一个线程涉及两个保护域的讨论自然地归纳为一个遍历多重保护域的线程，计算许可的一个简单而谨慎的经验做法是： <ul><li>一个执行线程的许可集可被认为是由该线程所遍历的所有保护域的许可的交集。 <br/><br/></li><li>当一条代码调用doPrivileged方法时（见下），执行线程的许可集被认为是包括一个许可，如果该许可被上述代码的保护域所允许并被调用或而后直接、间接进入的保护域所允许的话。 </li></ul></dd><dd>正象你所看到的，通过doPrivileged方法可使一条可信代码能临时访问更多的资源。这在某些情况下是必要的。例如，一个应用程序可能不被允许直接访问包含字体的文件，但是，显示文本的系统实用程序必须代表用户获得那些字体。我们为系统域提供了doPrivileged方法来处理这样的情况，事实上，该方法在所有域中都是可以调用的。 <br/><br/></dd><dd>在执行期间，当请求访问一个关键系统资源（如文件I/O和网络I/O）时，资源处理代码直接或间接地调用一个特殊AccessController类的方法，它可评估该请求并决定是否准予该请求。 <br/><br/></dd><dd>该评估紧跟在上面提到的"经验做法"之后并概括了该"经验做法"。进行评估的实际做法可由于实现的方法不同而有所变化。其基本原则是检查调用历史和相关保护域的许可，如果请求被准予，则安静地返回，反之，则扔出一个安全异常。 <br/><br/></dd><dd><p align="center">最后，每个域（系统的或应用程序的）也可以对其域边界内的内部资源的进行附加保护。例如，一个银行系统的应用程序可能需要支持并保护其内部的一些概念，如查帐、存款和取款等。由于此种保护的语义一般是不可预测的，JDK也无法实施，因而，在这个等级的保护最好留给系统或应用程序开发员来做。尽管如此，我们仍然愿意在合适的时候为简化程序员的工作而提供一定的方法，其中之一就是SignedObject类，我们稍后再讨论它的细节。 <br/><br/>..........|<a href="http://www.cnjavaclub.com/03/java_security/JDK12SA/jdk1_2-3.html">Next</a>|.......... </p><p align="center"><br/><font color="#333333" face="宋体" size="2">欢迎与我们联系：<a href="mailto:webmaster@prc.sun.com">webmaster@prc.sun.com</a><br/>版权所有 1997-1998 Sun(中国)公司，北京南礼士路66号建威大厦16层<br/>All rights reserved.<a href="http://www.cnjavaclub.com/java/share/text/SMICopyright.html">Legal Terms</a></font><!--- end copyright notice --></p></dd></dl>                </div>                    </div>
2601	 JavaTM安全体系结构3	url  applet  solaris  windows  java  扩展  	988996620	849	wxyxl	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p><br/><font face="宋体" size="3">Java<sup>TM</sup>安全体系结构（JDK1.2）</font></p><p><font face="宋体" size="3"><br/><b>3. 许可和安全策</b><br/><br/></font><font color="#666699" face="宋体" size="3"><b>3.1 许可类</b></font><font face="宋体" size="3">? <br/><br/>许可类表示了对系统资源的访问。java.security.Permission类是一个抽象的类，且在适当的时候可生成子类以表示特定的访问。 </font></p><dl><dd><br/><br/></dd><dd>作为许可的一个例子，下列代码可被用来生成一个阅读在/tmp目录下名为“abc”的文件的许可?br&gt;<br/></dd><dd>perm = new java.io.FilePermission ("/tmp/abc", "read"); <br/><br/></dd><dd>新许可类可通过继承Permission类或它的子类（如java.security.BasicPermission） 来生成的。已成为子类的许可（不是BasicPermission）通常都属于它们自己的包。因此，FilePermission可在java.io.package中找到。 <br/><br/></dd><dd>一个重要的并需要被每个许可新类实现的抽象方法是implies方法。一般来说，“a implies b”意味着如果你被授予了许可"a"，那么你也就自然地被授予了许可"b"。这在访问控制决策中是十分重要的。 <br/><br/></dd><dd>与抽象类java.security.Permission一起的是被称为java.security.PermissionCollection的抽象类和叶子类java.security.Permissions。 <br/><br/></dd><dd>java.security.PermissionCollection类表示了单一类别的（如文件许可）Permission对象的集合（例如，允许复制的一个集），以便于分组。在许可能够被以任何顺序添加到PermissionCollection对象的情况下（如为文件许可），当implies功能被调用时，PermissionCollection对象能够确保其后语义的正确性是至关重要的。 <br/><br/></dd><dd>java.security.Permissions类表示了Permission对象的集合的集合，或换句话说，是异类许可的超级集合。 <br/><br/></dd><dd>应用程序可添加系统支持的许可的新类型。添加此种特殊应用程序的许可的方法将在后面讨论。 <br/><br/></dd><dd>现在，我们来说明所有内置许可的句法和语义。 <br/><br/><b>3.1.1 java.security.Permission</b>? <br/><br/></dd><dd>这个抽象类是所有许可的祖先，它为所有许可定义了所需的基本功能。 <br/><br/></dd><dd>典型地，每个许可实例通过将一个或多个字符串参数传递给构造函数而被生成。在有两个参数的普通情况下，第一个参数通常是“目标名”（如作为许可目标的一个文件的名称），第二个参数是动作（如对一个文件的“阅读”动作）。一般的，一组动作可用逗号分隔的复合串来一起指定。 <br/><br/><b>3.1.2 java.security.PermissionCollection</b> <br/><br/></dd><dd>这个类掌握了许可的一个同类收集。换言之，类的每个实例仅掌握同类型的许可。 <br/><br/><b>3.1.3 java.security.Permissions</b> <br/><br/></dd><dd>设计这个类是为了掌握许可的异类收集。基本上，它是java.security.PermissionCollection对象的收集。 <br/><br/><b>3.1.4 java.security.UnresolvedPermission</b> <br/><br/></dd><dd>在正常情况下，一个安全策略的内部状态是由与每个代码源相关联的许可对象来表示的。然而，鉴于Java技术的动态性，当该策略被启动时，那些用来实现特定许可类的实际代码可能还没有在Java环境中被装载和定义。例如，一个基准许可类可能在JAR文件中，而该文件将稍后再装载。 <br/><br/></dd><dd>UnresolvedPermission类被用来掌握这种“未解决的”的许可。类似的，java.security.UnresolvedPermissionCollection类储存UnresolvedPermission许可的收集。 <br/><br/></dd><dd>在对一个以前未解决的类型（但它的类已经被装载）的许可的访问控制检查中，未解决的许可是“解决的”，并且作出了适当的访问控制决策。即：如果可能的话，基于UnresolvedPermission的信息，适当的类的新的对象被实例化，这个新的对象代替了UnresolvedPermission。 <br/><br/></dd><dd>如果此时许可仍然是不可解决的，则该许可被认为是无效的，就象在一个安全策略中，它从未被授予过一样。 <br/><br/><b>3.1.5 java.io.FilePermission</b> <br/><br/></dd><dd>这个类的目标可用下列方法来说明，在这里，目录和文件名是不包括空格的字符串。 <br/><br/><font size="2"></font><pre>filefirectory (与directory/一样)firectory/filefirectory/* (在目录directory下的所有文件)? (在当前目录中的所有文件)firectory/- (在目录directory 下的文件系统中的所有文件)? (在当前目录下的文件系统中的所有文件)《ALL FILES》" (在文件系统中的所有文件)</pre><p>? </p><br/></dd><dd>注意“”是一个用来表示系统中所有文件的特殊字符串。在Unix系统中，它包括了根目录下的所有文件；在MS-DOS系统中，它包括了在所有驱动器中的所有文件。 <br/><br/></dd><dd>这个类的动作是：读、写、删除和执行(read, white, delete and execute)。以下是创建文件许可的有效代码样本： <br/><br/><font size="2"></font><pre>　port java.io.FilePermission;　FilePermission p = new FilePermission("myfile", "read,write");FilePermission p = new FilePermission("/home/gong/", "read");  FilePermission p = new FilePermission("/tmp/mytmp", "read,delete");　FilePermission p = new FilePermission("/bin/*", "execute");　FilePermission p = new FilePermission("*", "read");　FilePermission p = new FilePermission("/-", "read,execute");　FilePermission p = new FilePermission("-", "read,execute");　FilePermission p = new FilePermission("《ALL FILES》", "read");　在这个类中的implies方法可正确地说明文件系统。例如，　FilePermission("/-","read,execute")隐含　FilePermission("/home/gong/public_html/index.html", "read")；　FilePermission("/bin/*", "execute")隐含　FilePermission("bin/emacs19.13", "execute")。</pre><p></p><br/></dd><dd>注：这些字符串的大部分都是以依赖于平台的格式给出。例如，要表示对在Windows系统C驱动器中的 "temp" 目录下名为 "foo"的文件的阅读访问，你可以使用： <br/><br/></dd><dd><font size="2">FilePermission p = new FilePermission ("c://temp//foo", "read"); </font><br/><br/></dd><dd>这里使用双反斜线来代表单反斜线是必要的。因为字符串是由一个tokenizer来处理的（java.io.StreamTokenizer），它允许 "/" 当作换行字符串来使用（例如， "/n"表示一个新的行），因此，我们需要用双反斜线来替代单反斜线的功能。在tokenizer对上述FilePermission目标字符串做过处理之后，再将双反斜线转换为单反斜线，最后结果是实际路径： <br/><br/></dd><dd>"c:/temp/foo" <br/><br/></dd><dd>在全局文件描述语言出现之前，字符串应该以依赖于平台的格式给出，这一点是必要的。还要注意的是，通配符（如 "*"和 "-"等）的使用影响了特殊文件名的使用。我们认为这是一个可以容忍的小限制。最后，要注意 "/-" 和 "《ALL FILES》" 在Unix系统中是同一个目标，它们都表示整个文件系统（如果有的话，它们也可表示多个文件系统）；在其它操作系统中（如MS Windows，MacOS），这两个目标可能是不同的。 <br/><br/></dd><dd>还要注意的一点是，象下列代码中仅指出目录和 "read" 动作的目标名，表示你只被允许列出那个目录中的文件名，而不能读它们。 <br/><br/></dd><dd>FilePermission p = new FilePermission ("/home/gong", "read"); <br/><br/></dd><dd>要允许对文件的阅读访问，你必须指出明确的文件名，或 "*"，或 "- "，如下所示：?br&gt;<br/><font size="2"></font><pre>FilePermission p = new FilePermission ("/home/gong/myfile", "read");FilePermission p = new FilePermission ("/home/gong/*", "read");FilePermission p = new FilePermission ("/home/gong/-", "read");</pre><p></p><br/></dd><dd>最后注意的是，代码总是自动具有对阅读位于与其相同的URL位置上的文件的许可，包括那个位置上的子目录；这不需要明确的许可。 <br/><br/><b>3.1.6 java.net.SocketPermission</b> <br/><br/></dd><dd>这个类表示通过sockets对一个网络的访问。这个类的目标可给为 "hostname:port_range"，这里的hostname可用下列方式给出： <br/><br/></dd><dd>　hostname (一个主机) 　IP address (一个主机) 　localhost (本地机) 　"" (相同于localhost") 　hostname.domain (在域domain中的一个主机) 　hostname.subdomain.domain 　*.domain (在域domain中的所有主机) 　*.subdomain.domain 　* (所有主机) ?/pre&gt;? <br/></dd><dd>也就是说，主机被表示为一个DNS名，或数字IP地址，或 "localhost"(为本地的机器)，或 ""（它与指定的 "localhost" 等同）。 <br/><br/></dd><dd>通配符 "*"可能会在DNS名称主机规范中使用一次，在这种情况下，它必须被放置在最左边，如: "*.sun.com"。 ?br&gt;<br/></dd><dd>port_range可按如下方式给出： <br/><br/></dd><dd>N (一个单一的端口)<br/></dd><dd>N- (端口N及以上的所有端口)<br/></dd><dd>-N (端口N及以上下的所有端口)<br/></dd><dd>N1-N2 (N1和N2之间的所有端口, 包括N1和N2) <br/><br/></dd><dd>这里的N、N1和N2为非负整数，范围为0至65535（2^16-1）。 ?br&gt;<br/></dd><dd>在socket上的动作有accept(接受), connect(连接), listen(侦听)和resolve(分辨) (它们是基本的DNS查询)。请注意，动作 "resolve"是由 "accept"、 "connect"和 "listen"所暗指的，也就是说，那些可以侦听、接受来自主机的连接或启动一个指向另一主机的连接的动作的类，应该能够查询远程主机的名称。 <br/><br/>以下是socket许可的一些实例： <br/><font size="2"></font><pre>import java.net.SocketPermission;SocketPermission p = new SocketPermission ("java.sun.com", "accept");p = new SocketPermission ( "204.160.241.99", "accept");p = new SocketPermission ( "*.com", "connect");p = new SocketPermission ( "*.sun.com:80", "accept");p = new SocketPermission ( "*.sun.com:-1023", "accept");p = new SocketPermission ( "*.sun.com:1024-", "connect");p = new SocketPermission ( "java.sun.com:8000-9000", "connect,accept");p = new SocketPermission ( "localhost:1024-", "accept,connect,listen");</pre>?   </dd><dd>请注意， SocketPermission ( "java.sun.com:80,8080", "accept") 和 SocketPermission ( "java.sun.com,javasun.sun.com", "accept")不是有效的socket许可。 <br/><br/></dd><dd>另外，listen是仅用于本地主机端口的动作，而accept是不但可用于本地主机端口，也可应用于远程主机端口的动作。两个动作都是必需的。 <br/><br/><b>3.1.7 java.security.BasicPermission?/b&gt; <br/><br/></b></dd><dd><b>BasicPermission类继承了Permission类，它可被当作许可的基类，并按照相同的命名惯例称作BasicPermission。 <br/><br/></b></dd><dd><b>一个BasicPermission的名称是特定许可的名称（例如，"exitVM", "setFctory", "queuePrintJob"等）。命名是按照所有等级命名惯例来进行。星号可能出现在名称的最后以表示一个通配符匹配，其前面可能有个 "."，也可能没有。例如： "java.*"或 "*"是有效的， "*java"或 "a*b"则是无效的。 <br/><br/></b></dd><dd><b>不能使用动作串（从Permission继承）。因此，BasicPermission一般被用作“已命名的”许可的基类（这些许可包含名称但无动作列表；你可能有已命名的许可，也可能没有）。如果愿意，子类可能在BasicPermission的上层实现动作。 <br/><br/><font size="2">某些BasicPermission的子类有java.lang.RuntimePermission, <br/>java.security.SecurityPermission，java.util.PropertyPermission, ?br&gt;java.net.NetPermission ?/font&gt;? <br/><br/><b>3.1.8 java.util.PropertyPermission</b> <br/><br/></font></b></dd><dd><b>这个类的基本目标是设置在各种属性文件中的Java属性名称，例如 "java.home"和 "os.name" 属性。目标可被指定为 "*" (全部属性)、 "a.*"(其名称具有前缀a.的全部属性)以及 "a.b.*"等等。请注意，通配符只能出现一次，且必须位于最右端。 <br/><br/></b></dd><dd><b>这个类是BasicPermission子类之一，它在BasicPermission上实现动作。该动作是读和写，其定义如下： "read" 许可允许在java.lang.System中的getProperty方法被调用以得到属性值， "white" 许可允许setProperty方法被调用以设置属性值。 <br/><br/><b>3.1.9 java.lang.RuntimePermission</b> <br/><br/></b></dd><dd><b>一个RuntimePermission的目标可用任何字符串来表示，且没有动作与该目标相关联。例如，RuntimePermission("exitVM")表示退出Java虚拟机的许可。 <br/><br/>目标名为： <br/><br/></b><pre><b>　createClassLoader　getClassLoader　setContextClassLoader　setSecurityManager　createSecurityManager　exitVM　setFactory　setIO　modifyThread　stopThread　modifyThreadGroup　getProtectionDomain　readFileDescriptor　writeFileDescriptor　loadLibrary.{library name}　accessClassInPackage.{package name}　defineClassInPackage.{package name}　accessDeclaredMembers.{class name}　queuePrintJob</b></pre><b></b><p><b>? <br/><b>3.1.10 java.awt.AWTPermission</b> <br/><br/></b></p><b></b></dd><dd><b>它与RuntimePermission相同，也是一个无动作的许可。其目标名为： <br/><br/></b></dd><dd><b>accessClipboard<br/></b></dd><dd><b>accessEventQueue<br/></b></dd><dd><b>listenToAllAWTEvents<br/></b></dd><dd><b>showWindowWithoutWarningBanner <br/><br/><b>3.1.11 java.net.NetPermission</b> <br/><br/></b></dd><dd><b>这个类包含下列目标且无动作： <br/><br/></b></dd><dd><b>requestPasswordAuthentication<br/></b></dd><dd><b>setDefaultAuthenticator<br/></b></dd><dd><b>specifyStreamHandler <b><br/><br/>3.1.12 java.lang.reflect.ReflectPermission</b> <br/><br/></b></dd><dd><b>这是一个为进行反射操作的Permission类。一个ReflectPermission是一个命名的许可（与RuntimePermission类似）且无动作。目前定义的唯一名称是： <br/><br/></b></dd><dd><b>suppressAccessChecks?br&gt;<br/></b></dd><dd><b>它允许超越反射对象实施的标准Java编程语言的存取检查，即对其类中的公有的、缺省的、受保护的和私有成员的访问检查等。换句话说，当一个实例拥有该许可后，它可访问反射对象的公有的、缺省的、受保护的和私有成员。 <br/><br/><b>3.1.13 java.io.SerializablePermission</b>?br&gt;<br/></b></dd><dd><b>这个类包含下列目标并且无动作： ?br&gt;<br/></b></dd><dd><b>enableSubclassImplementation<br/></b></dd><dd><b>enableSubstitution ?br&gt;<br/><b>3.1.14 java.security.SecurityPermission</b>?br&gt;<br/></b></dd><dd><b>SecurityPermission控制对与安全相关的对象的访问，如对象Security, Policy, Provider, Signer和Identity等。这个类包含下列目标并且无动作： <br/><br/></b><pre><b>　getPolicy　setPolicy　getProperty.{key}　setProperty.{key}　insertProvider.{provider name}　removeProvider.{provider name}setSystemScope　setIdentityPublicKey　setIdentityInfo　printIdentity　addIdentityCertificate　removeIdentityCertificate　clearProviderProperties.{provider name}　putProviderProperty.{provider name}　removeProviderProperty.{provider name}　getSignerPrivateKey　setSignerKeyPair</b></pre><b></b><p><b><b><br/>3.1.15 java.security.AllPermission</b> <br/><br/></b></p><b></b></dd><dd><b>这个许可意味着全部许可。它是为简化系统管理员的工作而设计的，因为系统管理员可能需要执行多种要求全部（或大量）许可的任务。反复定义许可显然是烦琐的。请注意，AllPermission也意味着在未来定义的新的许可。 ?br&gt;<br/></b></dd><dd><b>当使用这个许可时，应慎重考虑。 <br/><br/><b>3.1.16许可含义讨论</b> <br/><br/></b></dd><dd><b>回想一下我们发现，许可经常被互相比较，而且，为了便于这种比较，我们要求每个许可类定义一个implies方法，它表示特定的许可类是如何与其它许可类发生关系的。例如，java.io.FilePermission("/temp/*", "read")隐含java.io.FilePermission("/temp/a.txt", "read")，但不隐含任何java.net.NetPermission。 <br/><br/></b></dd><dd><b>另外一层含义可能对某些读者来说不能立即明了。假设一个Applet被授予了编写全部文件系统的许可，它假设允许该Applet来替换执行系统，包括JVM运行环境。这就有效地意味着Applet已经被授予了全部许可。 ?br&gt;<br/></b></dd><dd><b>另一个例子是，如果一个Applet被授予运行时创建类装载器的许可，它就被有效地授予了更多的许可。因为类装载器可执行敏感操作。 ?br&gt;<br/></b></dd><dd><b>其它一些“危险的”许可包括允许设置系统属性的许可、运行时定义包和装载本地代码库的许可（因为Java安全结构不能防止本地代码的恶意行为），当然，还有AllPermission。 ?br&gt;<br/></b></dd><dd><b>有关许可的更多信息，包括列举分配特殊许可的风险的表格和所有需要许可的JDK内置方法表格等，请查看： ?br&gt;<br/></b></dd><dd><b>?a href="http://java.sun.com/products/jdk/1.2/docs/guide/security/permissions.html " target="_new"&gt;http://java.sun.com/products/jdk/1.2/docs<br/></b></dd><dd><b>/guide/security/permissions.html <br/><br/><b>3.1.17如何创建新型许可</b> <br/><br/></b></dd><dd><b>除了SUN Microsystems应该负责扩展内置于JDK中的许可外，无论是通过增加功能性，还是通过将附加目标关键词引入到一个类中（如java.lang.RuntimePermission），无人能够担当此任。这一点是必需的，它保持了JDK的连续性。 <br/><br/></b></dd><dd><b>要创建一个新的许可，建议采用下面例子所示的步骤。假设ABC公司的一个应用程序开发员要创建一个“看电视”的用户化许可。 <br/><br/></b></dd><dd><b>首先，创建一个新的类com.abc.Permission，它继承抽象类java.security.Permission(或它的一个子类)；再创建另一个新的类com.abc.TVPermission，它继承com.abc.Permission。确认其它类中的implies方法被正确地实现（当然，com.abc.TVPermission可直接继承java.security.Permission；不需要中间的com.abc.Permission）。 <br/><br/></b></dd><dd><b>public class com.abc.Permission extends java.security.Permission<br/></b></dd><dd><b>public class com.abc.TVPermission extends com.abc.Permission <br/><br/></b></dd><dd><b></b><p align="center"><b>下图显示了子类之间的关系： <br/><img alt="jdk-chart6.gif" border="0" height="180" src="http://www.cnjavaclub.com/03/java_security/JDK12SA/jdk-chart6.gif" width="396"/><br/></b></p><b></b></dd><dd><b>第二， 将这些新类加在应用系统包中。 <br/><br/></b></dd><dd><b>每个想要允许这个新型许可的用户都要在策略文件中增加一个入口（策略文件句法的细节见以下章节）。授予来自http://java.sun.com/的代码许可，使其可以观看5频道电视的策略文件入口授权码为： <br/><br/></b><pre><b>grant codeBase "http://java.sun.com/" ｛　permission com.abc.TVPermission "channel-5", "watch";        ｝</b></pre><b></b><p><b><br/></b></p><b></b></dd><dd><b>在应用程序的资源管理代码中，要查看一个许可是否应该被准予时，使用一个com.abc.TVPermission对象作为参数来调用AccessController的checkPermission方法。 <br/><br/></b><pre><b>com.abc.TVPermission tvperm = new     com.abc.TVPermission ("channel-5", "watch");AccessController.checkPermission(tvperm);</b></pre><b></b><p><b><br/></b></p><b></b></dd><dd><b>请注意，当增加一个新的许可时，你应该创建一个新的（许可）类，而不在SecurityManager中增加新的方法（过去，为了检查访问的新类型，你必须在SecurityManager类中增加新的方法）。 <br/><br/></b></dd><dd><b>如果更精细的TVPermission (例如, "channel-1:13"或"channel-*")被允许的话，则需实现一个TVPermissionCollection对象，这个对象知道如何处理这些伪名称。 <br/><br/></b></dd><dd><b>为了执行内置访问控制算法，新的代码应该总是通过调用AccessController类的checkPermission方法来调用一个许可检查。没有必要检查是否具有ClassLoader或SecurityManager。另一方面，如果这个算法留给已安装的安全管理器类，则应该调用方法SecurityManager.checkPermission。 <br/><br/><font color="#666699"><b>3.2 java.security.CodeSource　</b></font> <br/><br/></b></dd><dd><b>这个类继承了HTML内代码基址(codebase)的概念，目的是不仅封装代码位置（URL），而且封装包含公共密钥（这个公共密钥可用来校验来自那个位置的数字签字）的数字证书。请注意，这不是在HTML文件中的CodeBase标记的等价物。每个证书表示为java.security.cert.Certificate，每个URL表示为java.net.URL。 <b><br/><br/><font color="#666699">3.3 java.security.Policy</font> </b><br/><br/></b></dd><dd><b>Java应用环境的系统安全策略说明了来自不同地方的代码的可用许可，它用Policy对象来表示。 在特别的情况下，用Policy子类来表示，该子类实现了Policy类中的抽象方法。 <br/><br/></b></dd><dd><b>为了使一个Applet(或一个在SecurityManager下运行的应用程序)能被允许执行安全的动作，如阅读或编写文件，该Applet（或应用程序）必须被授予那个特定动作的许可。唯一例外是，代码总是自动具有阅读来自相同的出处的文件以及这个出处的子目录的文件的许可，而不需要明确的许可。 <br/><br/></b></dd><dd><b>可能有多个Policy对象的实例，尽管在任何时候都仅有一个是“有效的”。通过调用getPolicy方法，可获得当前安装的Policy对象，并且，可通过调用setPolicy方法（由具有重设Policy的许可的代码来执行）来改变它。 <br/><br/></b></dd><dd><b>当保护域启动它的许可集时，当前策略被一个ProtectionDomain所检查。保护域在一个CodeSource对象中通过，这封装了它的代码基址（URL）和证书属性。Policy对象评估全局策略并返回一个适当的Permission对象，它说明了来自指定代码源的代码的许可。 <br/><br/></b></dd><dd><b>对Policy对象所采用的策略信息的资源定位等于Policy实现。策略的配置可被存储， 例如当作一个平面ASCII文件来存储，或当作一个Policy类的串行二进制文件来存储，或当作一个数据库来存储。有一个缺省Policy实现，它可获得来自静态策略配置文件的信息。 <br/><br/></b></dd><dd><b>在制定安全策略时并没有涉及Policy对象。它只是策略配置在Java运行时的体现。 <br/><br/><b>3.3.1策略文件格式</b> 　 <br/><br/></b></dd><dd><b>在缺省Policy实现中, 策略可在一个或多个策略配置文件中指定。配置文件指出, 对来自指定代码源的代码, 哪些许可是被允许的。 <br/><br/></b></dd><dd><b>一个策略配置文件一般都包含一个入口列表。它可能包含一个密钥库(keystore)入口, 并包含零个或多个 "grant"入口。 <br/><br/></b></dd><dd><b>密钥库是一个数据库, 它装有私有密钥和它们的相关数字证书, 如用来认证相应的公共密钥的X.509证书链。keytool实用程序用来创建并管理密钥库。在策略配置文件中指定的密钥库可被用来查询在文件准予入口中指定的签字者的公共密钥。 如果任何准予入口说明了签字者的别名, 则一个密钥库入口必须出现在一个策略配置文件中。 <br/><br/></b></dd><dd><b>此时, 在策略文件中可能只有一个密钥库入口(第一个之后的被忽略), 并且, 它可出现在文件准予入口之外的任何地方。它具有如下句法: <br/><br/></b></dd><dd><b>keystore "some_keystore_url", "keystore_type"; <br/><br/></b></dd><dd><b>这里, "some_keystore_url"指定keystore的URL位置, "keystore_type"指定密钥库类型。后者是可选项, 如果未指定, 则被假定为在安全属性文件中的 "keystore.type"属性所指定的类型。 <br/><br/></b></dd><dd><b>URL与策略文件的位置相关。因此, 如果策略文件在安全属性文件中被指定为: <br/><br/></b></dd><dd><b>policy.url.l=http://foo.bar.com/blah/some.policy <br/></b></dd><dd><b>并且该策略文件有一个入口: <br/></b></dd><dd><b>keystore ".keystore"; <br/></b></dd><dd><b>则keystore将被从如下位置装载: <br/></b></dd><dd><b><a href="http://foo.bar.com/blah/.keystore">?http://foo.bar.com/blah/.keystore</a> <br/></b></dd><dd><b>URL也可以是绝对地址。 <br/><br/></b></dd><dd><b>密钥库类型定义了密钥库信息的存储形式和数据格式, 并定义了算法以保护密钥库中的私有密钥以及密钥库本身的完整性。Sun Microsystems支持的缺省类型是被称为 "JKS"的专用密钥库类型。 <br/><br/></b></dd><dd><b>在策略文件中的每个准予入口基本上是由一个CodeSource和它的许可所组成。实际上，CodeSource是由一个URL和一个证书集所组成，而一个策略文件入口包括一个URL和一个签名者列表。在查询了密钥库以确定指定签名者的证书之后，系统创建相应的CodeSource。 <br/><br/></b></dd><dd><b>在策略文件中的每个准予入口采用以下格式。前面的 "grant"是一个保留字，它表示一个新的入口的开始，可选项出现在括号内。在每个入口内，第一个 "permission" 也是一个保留字，它标志着在该入口内的一个新的许可的开始。每个准予入口都将一个许可集授予一个指定代码源。 <br/></b><pre><b>　grant [SignedBy "signer_names"] [, CodeBase "URL"] {    permission permission_class_name [ "target_name" ]                [, "action"] [, SignedBy "signer_names"];    permission ...};</b></pre><b></b><p><b><br/></b></p><b></b></dd><dd><b>在任何逗号之前或之后，允许空格。许可类的名称必须全部是合格的类名称，如java.io.FilePermission, 且不能简化（如简化为FilePermission） <br/><br/></b></dd><dd><b>动作字段是可选项，如果许可类不需要它，则可将其忽略。如果出现动作字段，则必须紧接在目标字段之后。 <br/><br/></b></dd><dd><b>一个CodeBase URL值的确切含义取决于结尾处的字符。用 "/" <br/></b></dd><dd><b>结尾的CodeBase可在指定目录中与所有类文件匹配（不包括JAR文件）；用 "/*" <br/></b></dd><dd><b>结尾的CodeBase可在指定目录中与所有文件匹配（包括类文件和JAR文件）；用 "/-" <br/></b></dd><dd><b>结尾的CodeBase可在指定目录中及那个目录下的子目录中与所有文件匹配（包括类文件和JAR文件）。 <br/><br/></b></dd><dd><b>CodeBase字段（URL）是可选项，如果忽略，它表示“任意代码基址”。 <br/><br/></b></dd><dd><b>第一个签字字段是通过单独机制映射的字符串别名，这个映射对应与签字者相关的公共密钥集（在密钥库中的证书内）的映射。这些密钥被用来校验某个已签字的类是否真的是由那些签字者所签的字。 <br/><br/></b></dd><dd><b>包括多个签名的字段可以是用逗号分隔的字符串。例如， "Adam,Eve,Charles"表示这是一个由Adam和Eve和Charles签的字（也就是说，他们的关系是“和”，而不是“或”）。 <br/><br/></b></dd><dd><b>这个字段是可选项，如果被忽略，则表示“任意签字者”；换句话说，“这个代码是否被签字都无所谓”。 <br/><br/></b></dd><dd><b>第二个签字字段（在一个Permission入口内）代表了包括公共密钥的密钥库入口的别名，这个公共密钥对应于用来签写实现上述许可类的字节码的私有密钥。只有在该字节码的实现被校验为是上述别名的正确签字时，这个许可入口才是有效的（也就是说，访问控制许可是基于这个入口而发出的）。 <br/><br/></b></dd><dd><b>CodeBase和SignedBy字段之间的顺序是无关紧要的。 <br/><br/></b></dd><dd><b>以下是一个非正式的为Policy文件格式设计的BNF语法，这里的非大写项是终结符。 <br/><br/></b></dd><dd><b><font size="2">? </font></b><pre><b>?PolicyFile -&gt; PolicyEntry | PolicyEntry; PolicyFilePolicyEntry -&gt; grant {PermissionEntry}; |               grant SignerEntry {PermissionEntry} |               grant CodebaseEntry {PermissionEntry} |               grant SignerEntry, CodebaseEntry {PermissionEntry} |               grant CodebaseEntry, SignerEntry {PermissionEntry} |               keystore "url"SignerEntry -&gt; signedby (a comma-separated list of strings)CodebaseEntry -&gt; codebase (a string representation of a URL)PermissionEntry -&gt; OnePermission | OnePermission PermissionEntryOnePermission -&gt; permission permission_class_name                 [ "target_name" ] [, "action_list"]                 [, SignerEntry];</b></pre><b> </b></dd><dd><b>现在我们给出一些实例。下面的策略将许可a.b.Foo授予由Roland签字的代码： <br/><br/></b><pre><b>　grant signedBy "Roland" ｛    permission a.b.Foo;｝;</b></pre><b></b><p><b><br/></b></p><b></b></dd><dd><b>下面的例子将一个FilePermission授予所有代码（不管签字者和/或codeBase）: <br/><br/></b><pre><b>grant {   permission java.io.FilePermission ".tmp", "read";};下面的例子将两个许可授予由Li和Roland共同签字的代码：grant signedBy "Roland,Li" {  permission java.io.FilePermission "/tmp/*", "read";  permission java.util.PropertyPermission "user.*";};</b></pre><b></b><p><b><br/></b></p><b></b></dd><dd><b>? 下面的例子将两个许可授予由Li签字的代码且来自<a href="http://java.sun.com/">http://java.sun.com</a>： <br/><br/></b><pre><b>　grant codeBase "http://java.sun.com/*", signedBy "Li" {    permission java.io.FilePermission "/tmp/*", "read";    permission java.io.SocketPermission "*", "connect";};</b></pre><b></b><p><b>? 下面的例子将两个许可授予由Li和Roland共同签字的代码，而且只有在由实现com.abc.TVPermission的字节码是由Li签字时才能成功： <br/></b></p><b></b><pre><b>　grant signedBy "Roland,Li" {  permission java.io.FilePermission "/tmp/*", "read";  permission com.abc.TVPermission "channel-5", "watch",      signedBy "Li";};</b></pre><b></b><p><b><br/></b></p><b></b></dd><dd><b>包括第二个签字者字段的原因是为了在一个许可类没有与Java运行安装在一起时防止欺骗。例如，com.abc.TVPermission的一个拷贝可作为一个远程JAR被下载，并且用户策略可能包括一个引用它的入口。因为该文档不是长命的，当com.abc.TVPermission类被第二次下载时（可能从不同的web地址），第二个拷贝是否可信，这一点是至关重要的，因为在用户策略中的许可入口的出现可能反映了用户对这个类字节码的第一个拷贝的信心和信任。 <br/><br/></b></dd><dd><b>我们选择使用数字签字（而不是选择存储字节码的第一个拷贝的哈希值，然后在将第二个拷贝与之进行比较）以保证真实性的原因是，因为许可类的作者能合法地更改类文件以反映一个新的设计或实现。 <br/><br/></b></dd><dd><b>请注意：文件路径字符串必须采用依赖于平台的格式；在一个全局文件描述语言出现之前，这是必要的。上面的例子已经显示了适用于Solaris系统的字符串。在Windows系统中，当你要用字符串直接指定一个文件路径时，你需要使用双反斜线来代替表示路径的单反斜线。举例如下： <br/><br/></b><pre><b>　grant signedBy "Roland" {  permission java.io.FilePermission "C://users//Cathy//*", "read";};?/pre&gt;</b></pre><b></b></dd><dd><b>这是因为该字符串是由一个tokenizer来处理的（java.io.StreamTokenizer）,它允许 "/"被用来当作转义字符串（例如： "/n"表示新的一行），这就要求用双反斜线来代替单反斜线。tokenizer处理上述FilePermission目标字符串时，将双反斜线转换为单反斜线，最终结果是实际路径： <br/><br/></b></dd><dd><b>"C:/users/Cathy/*" <br/><br/><b>? 3.3.2策略文件的属性扩展</b> <br/><br/></b></dd><dd><b>在策略文件和安全属性文件中的属性扩展是可能的。 <br/><br/></b></dd><dd><b>属性扩展与扩展在一个外壳上的变量相似。即：当如下字符串 <br/><br/></b></dd><dd><b>"${some.property}"<br/><br/></b></dd><dd><b>　 <br/><br/></b></dd><dd><b>出现在一个策略文件或一个安全属性文件中时，它将被扩展为指定系统的属性的值。例如： <br/><br/></b></dd><dd><b>permission java.io.Permission "$｛user.home｝", "read"; <br/><br/></b></dd><dd><b>将扩展 "$｛user,home｝"以使用 "user.home"系统属性的值；如果那个属性的值是 "/home/cathy"，则上述代码与下面的代码等价： <br/><br/></b></dd><dd><b>permission java.io.FilePermission "/home/cathy", "read"; <br/><br/></b></dd><dd><b>为加速独立于平台的策略文件，你也可以使用特殊符号 “$｛/｝"，它是 "$｛file.separator｝"的快捷方式。它允许在许可定义中使用。例如： <br/><br/></b></dd><dd><b>permission java.io.FilePermission "$｛user.home｝$｛/｝*", "read"; <br/><br/></b></dd><dd><b>如果user.home为/home/cathy，并且你是在Solaris系统，上式可转换为： <br/><br/></b></dd><dd><b>permission java.io.FilePermission "/home/cathy/*", "read"; <br/><br/></b></dd><dd><b>另一方面，如果user.home为C:/users/cathy，并且你是在Windows系统，则可转换为： <br/><br/></b></dd><dd><b>permission java.io.FilePermission "C:/users/cathy/*", "read"; <br/><br/></b></dd><dd><b>另外，作为特殊情况，如果你在一个代码基址中扩展一个属性，如： <br/><br/></b></dd><dd><b>grant codeBase "file:/$｛java.home｝/lib/ext/" <br/><br/></b></dd><dd><b>则任何file.separator字符将被自动转换为 /'s，因为代码基数是URLs，所以上述转换是我们所期望的。这样，在一个Windows系统上，甚至如果java,home被设置为C:/jdk1.2，上式也可转换为： <br/><br/></b></dd><dd><b>grant codeBase "file:/C:/jdk1.2/lib/ext/" <br/><br/></b></dd><dd><b>于是你不需要在代码基址字符串中使用$｛/｝（你不应该使用）。 <br/><br/></b></dd><dd><b>属性扩展可发生在策略文件中任何有双引号字符串的地方，这包括：signedby、代码基址、目标名和动作字段。 <br/><br/></b></dd><dd><b>是否允许属性扩展，取决于安全属性文件中的 "policy.expandProperties"属性的值。如果这个值是true（缺省值），则允许扩展。 <br/><br/></b></dd><dd><b>请注意：你不能使用嵌套的属性。例如： <br/><br/></b></dd><dd><b>"$｛user.$｛foo｝｝" <br/><br/></b></dd><dd><b>　 上式将不起作用，甚至 "foo"属性被设置为 "home"，也不起作用。原因是属性语法分析程序不能识别嵌套属性。它只寻找第一个 "$｛"，然后继续寻找，直到发现第一个 "｝"为止，并且试图解释结果 "$｛user.$foo｝"为一个属性。如果没有这样的属性，则失败。 <br/><br/></b></dd><dd><b>　 另外还要注意，如果一个属性在一个准予入口、许可入口或密钥库入口不能被扩展，则那个入口将被忽略。例如：如果系统属性 "foo" 未被定义并且你具有： <br/><br/></b><pre><b>　grant  codebase "$ ｛foo｝" ｛permission  ?permission  ?｝；</b></pre><b></b><p><b><br/></b></p><b></b></dd><dd><b>则所有在准予入口的许可将被忽略。如果你具有： </b><pre><b>?　grant ｛permission  Foo  "$ ｛foo｝"  permission Bar;｝;</b></pre><b></b><p><b><br/></b></p><b></b></dd><dd><b>则仅有"permission Foo ?入口被忽略。最后，如果你具有： <br/></b></dd><dd><b>keystore "$｛foo ｝"; <br/></b></dd><dd><b>则密钥库入口被忽略。 <br/></b></dd><dd><b>最后注意一点，在Windows系统中，当你直接用字符串指定一个文件路径时，你需要使用双反斜线来代替在路径中的单反斜线： <br/></b></dd><dd><b>"C://users//cathy//foo.bat" <br/><br/></b></dd><dd><b>这是因为该字符串是由一个tokenizer来处理的（java.io.StreamTokenizer）,它允许 "/"被用来当作转义字符串（例如： "/n"表示新的一行），这就要求用双反斜线来代替单反斜线。tokenizer处理上述字符串时，将双反斜线转换为单反斜线，最终结果是： <br/></b></dd><dd><b>"C:/users/Cathy/foo.bat" <br/></b></dd><dd><b>　 在一个字符串中的属性扩展发生在tokenizer处理完该字符串之后。于是，如果你有字符串 <br/></b></dd><dd><b>　 "$｛user.home｝//foo.bat" <br/></b></dd><dd><b>　 则tokenizer将首先处理该字符串，转换双反斜线为单反斜线，结果是： <br/></b></dd><dd><b>　 "$｛user.home｝/foo.bat" <br/></b></dd><dd><b>　 然后 $｛user.home｝属性被扩展，最后结果是： <br/></b></dd><dd><b>"C:/users/cathy/foo.bat" <br/></b></dd><dd><b>假设user.home值为 "C:/users/cathy" (当然是独立于平台的)，最好在一开始字符串就被指定，且不用任何显式斜线。如下所示： <br/></b></dd><dd><b>"$｛user.home｝$｛/｝foo.bat" <br/><br/><b>3.3.3分配许可</b> <br/><br/></b></dd><dd><b>当装载一个起源于特定CodeSource的新的类时，安全性机制查询策略对象以决定应准予什么样的许可。这是通过调用安装在VM上的Policy对象上的getPermission方法来完成的。 <br/><br/></b></dd><dd><b>显然，一个特定的代码源可与多个入口所给定的代码源在该策略中相匹配。例如，因为允许使用通配符 "*"。 <br/><br/></b></dd><dd><b>下列算法被用来在策略中定位适当的许可集： <br/><br/></b></dd><dd><b>1. 如果代码被签字的话，匹配公共密钥。<br/><br/></b></dd><dd><b>2.如果在策略中没有找到密钥，则忽略该密钥；如果每一个密钥都被忽略，则视该代码为未签字代码。<br/><br/></b></dd><dd><b>3. 如果密钥匹配或没有说明签字者{ 在策略中尝试为该密钥匹配所有的URLs }<br/><br/></b></dd><dd><b>4. 如果密钥或URL之一未得到匹配，使用内置的缺省的许可，该许可就是最初的沙箱许可。 <br/><br/></b></dd><dd><b>一个策略入口CodeBase URL值的确切含义取决于结尾处的字符。用 "/" <br/><br/></b></dd><dd><b>结尾的CodeBase在指定目录中与所有类文件匹配（不包括JAR文件）；用 "/*" <br/><br/></b></dd><dd><b>结尾的CodeBase在指定目录中与所有文件匹配（包括类文件和JAR文件）；用 "/-" <br/><br/></b></dd><dd><b>结尾的CodeBase在指定目录中及那个目录下的子目录中与所有文件匹配（包括类文件和JAR文件）。 <br/><br/></b></dd><dd><b>举例来说，在策略中给定了 "http://java.sun.com/- "，则在该web地址上的任意代码基址都将与策略入口匹配。匹配的代码基址包括 <br/>"<a href="http://java.sun.com/jdk/">http://java.sun.com/jdk/</a>"和<br/>"<a href="http://java.sun.com/people/gong/appl.jar">http://java.sun.com/people/gong/appl.jar"</a>。 <br/><br/></b></dd><dd><b>如果多个入口被匹配，则所有在那些入口中所给定的许可将被准予。换言之，许可的分配是附加的。例如，如果用密钥A签字的代码获得了许可X，用密钥B签字的代码获得了许可Y，并且未指定特定的代码基基址，则由A和B共同签字的代码将获得许可X和Y。类似的，如果带有代码基址"http://java.sun.com/- "的代码获得了许可X， 带有代码基址 "http://java.sun.com/people/* "的代码获得了许可Y, 并且未指定特定签字者，则来自 "<a href="http://java.sun.com/people/applet.jar">http://java.sun.com/people/applet.jar</a>"的一个Applet将同时获得X和Y。 <br/><br/></b></dd><dd><b>请注意，这里的URL匹配纯粹是句法上的。例如，一个策略可给定一个入口，这个入口指定一个URL "http://ftp.sun.com"，只有在能够直接从ftp获得Java代码来执行时，这样的入口才是有用的。 <br/><br/></b></dd><dd><b>为了为本地文件系统指定URLs，可使用文件URL。例如，为指定在Solaris系统中的/home/cathy/temp目录下的文件，你可以使用： <br/><br/></b></dd><dd><b>"file:/home/cathy/temp/*" <br/><br/></b></dd><dd><b>要指定在Windows系统中C驱动器上temp目录下的文件，你可以使用： <br/><br/></b></dd><dd><b>"file:/c:/temp/*" <br/><br/></b></dd><dd><b>注意：无论在什么平台上，代码基址URL总是使用斜线（不是反斜线）。 <br/><br/></b></dd><dd><b>你也可以使用一个绝对路径名，如： <br/><br/></b></dd><dd><b>"/home/gong/bin/MyWonderfulJava" <br/><br/><b>3.3.4缺省系统和用户策略文件</b> <br/><br/></b></dd><dd><b>在缺省Policy实现中，策略可在一个或多个策略配置文件中说明。配置文件指定什么样的许可能够为来自指定代码源的代码所使用。 <br/><br/></b></dd><dd><b>一个策略文件可通过一个简单的文本编辑器来制作，也可以使用我们稍后将要讨论的图形Policy Tool实用程序来制作。 <br/><br/></b></dd><dd><b>缺省地，我们具有一个单独的系统整体策略文件和一个单独的用户策略文件。 <br/><br/></b></dd><dd><b>系统整体策略文件缺省地位于： <br/><br/></b></dd><dd><b>｛java.home｝/lib/security/java.policy (Solaris)?br&gt; </b></dd><dd><b>｛java.home｝/lib/security/java.policy (Windows) <br/><br/></b></dd><dd><b>这里的java.home是一个系统属性，它指定JDK被安装的目录。 <br/><br/></b></dd><dd><b>用户策略文件缺省地位于： <br/><br/></b></dd><dd><b>｛user.home｝/.java.policy (Solaris)<br/></b></dd><dd><b>｛user.home｝/.java.policy (Windows) <br/><br/></b></dd><dd><b>这里的user.home是一个指定用户的起始目录的系统属性。 <br/><br/></b></dd><dd><b>当Policy被初始化时，系统整体策略首先被装入，然后用户策略被添加上去。如果这两个策略都不出现，则一个内置策略被使用。这个内置策略与初始沙箱策略相同。 <br/><br/></b></dd><dd><b>策略文件定位在安全属性文件中被指定，它位于： <br/><br/></b></dd><dd><b>{java.home｝/lib/security/java.security (Solaris)<br/></b></dd><dd><b>{java.home｝/lib/security/java.security (Windows) <br/><br/></b></dd><dd><b>策略文件定位被指定为某个属性的值，它的名称为如下形式： <br/><br/></b></dd><dd><b>policy.url.n <br/><br/></b></dd><dd><b>这里的n是一个数。你可以用如下一行形式来指定每一个这样的属性值： <br/><br/></b></dd><dd><b>policy.url.n=URL <br/><br/></b></dd><dd><b>这里的URL是一个URL说明。例如，缺省系统和用户策略文件在安全属性文件中被定义为： <br/><br/></b></dd><dd><b>policy.url.1=file:$｛java.home｝/lib/security/java.policy<br/></b></dd><dd><b>policy.url.2=file:$｛java.home｝/.java.policy <br/><br/></b></dd><dd><b>实际上，你可以指定许多URLs，包括 "http://"形式的。所有指定的策略文件将被装载。你也可以注释或改变第二个URL，使缺省用户策略文件不能被阅读。 <br/><br/></b></dd><dd><b>算法从policy.url.1开始，并保持递增直到它未发现一个URL为止。于是如果你具有policy.url.1和policy.url.3，则policy.url.3将总是读不到。 <br/><br/></b></dd><dd><b>当调用一个应用程序的执行时，可能指定一个附加的或不同的策略文件。这可以通过 "-Djava.security.policy"命令行自变量来实现，它设置java.security.policy属性的值。例如，如果你使用： <br/><br/></b></dd><dd><b>java -Djava.security.manager -Djava.security.policy=pURL SomeApp <br/><br/></b></dd><dd><b>这里的pURL是一个URL，它指定一个策略文件位置，然后除了安全属性文件中指定的所有策略文件外，这个指定的策略文件也将被装载。（ "-Djava.security.manager"自变量将保证缺省安全管理器被安装，并且应用程序服从于策略检查，就象 "Security Management for Applets and Applications"中所描述的那样。如果应用程序SomeApp安装一个安全管理器，则无必要）。 <br/><br/></b></dd><dd><b>如果如下程序一样使用双等号，那么仅有指定的策略文件将被使用，其它将被忽略。 <br/><br/></b></dd><dd><b>java -Djava.security.manager -Djava.security.policy = = pURL SomeApp <br/><br/></b></dd><dd><b>如果你要传递一个策略文件至appletviewer，请再次使用 "-Djava.security.policy"自变量，如下所示： <br/></b></dd><dd><b>appletviewer -J-Djava.security.policy=pURL myApplet <br/><br/></b></dd><dd><b>请注意： 如果在安全属性文件中的 "policy.allowSystemProperty"属性被设置为假，"-Djava.security.policy"策略文件值将被忽略（对java 和 appletviewer都一样）。其缺省值为真。 <br/><br/><b>3.3.5用户化策略评估</b> <br/><br/></b></dd><dd><b>Policy类的当前设计不象以前那样复杂。我们已经充分地考虑了这个问题并谨慎地向前发展；部分原因是为了我们所设计的方法调用能够适合大多数的一般情况。同时，给出可选择的策略类以替代缺省策略类，只要前者是一个抽象Policy类的子类并实现getPermissions方法（需要时实现其它方法）。 <br/><br/></b></dd><dd><b>通过将 "policy.provider"安全属性（在安全属性文件中）的值重新设置到所期望的Policy实现类名中，则缺省Policy实现可被改变。安全属性文件名称如下： <br/><br/></b></dd><dd><b>{java.home｝/lib/security/java.security (Solaris)<br/></b></dd><dd><b>{java.home｝/lib/security/java.security (Windows) <br/><br/></b></dd><dd><b>这里，｛java.home｝指安装有JDK的目录。 <br/><br/></b></dd><dd><b>属性policy.provider指定策略类的名称，其缺省值如下： <br/><br/></b></dd><dd><b>policy.provider=sun.security.provider.PolicyFile <br/><br/></b></dd><dd><b>为了用户化，你可以改变该属性的值以指定另一个类，如下所示： <br/><br/></b></dd><dd><b>policy.provider=com.mycom.MyPolicy <br/><br/></b></dd><dd><b><br/><br/></b></dd><dd><b>注意：MyPolicy类必须是java.security.Policy的一个子类。或许值得强调这样的策略类覆盖是暂时的解决方案，而更广泛的策略API将会替代这种方法。 <br/><br/>? <font color="#666699"><b>3.4　jjava.security.GeneralSecurityException</b></font> <br/><br/></b></dd><dd><b>这是一个新的异常类，它是java.lang.Exception的一个子类。它试图表示，应该有两个与安全和安全包相关的异常类型。 <br/><br/></b></dd><dd><b>java.lang.SecurityException和它的子类应该是运行时异常（未检查的，未声明的），它可能会引起一个程序的执行被中断。 <br/><br/></b></dd><dd><b>只有在某种安全性违规被检测到时，这样的异常才被扔出。例如，当某些代码试图访问一个文件，但它没有访问许可，该异常就被扔出。应用程序开发人员可捕捉这些异常。 <br/><br/></b></dd><dd><b>java.security.GeneralSecurityException是java.lang.Exception（必须被声明或捕捉）的一个子类，它在所有其它情况下被从安全包中扔出。 <br/><br/></b></dd><dd><b>这样的异常与安全有关但不是致命的。例如，传输一个无效的密钥可能不是安全违规， 它应该被开发人员捕捉并处理。 <br/><br/></b></dd><dd><b></b><p align="center"><b>在java.security包中还有两个异常，它们是RuntimeException的子类，由于向后兼容的要求，此时我们不能改变它。我们将在以后讨论这个问题。 <br/><br/>..........|<a href="http://www.cnjavaclub.com/03/java_security/JDK12SA/jdk1_2-4.html">Next</a>|.......... </b></p><b></b><p align="center"><b><br/><font color="#333333" face="宋体" size="2">欢迎与我们联系：<a href="mailto:webmaster@prc.sun.com">webmaster@prc.sun.com</a><br/>版权所有 1997-1998 Sun(中国)公司，北京南礼士路66号建威大厦16层<br/>All rights reserved.<a href="http://www.cnjavaclub.com/java/share/text/SMICopyright.html">Legal Terms</a></font><!--- end copyright notice --></b></p><b></b></dd></dl><b></b>                </div>                    </div>
2603	 JavaTM安全体系结构5	classloader  applet  java  jdk  虚拟机  语言  	988996680	941	wxyxl	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p><br/><font face="宋体" size="3">Java<sup>TM</sup>安全体系结构（JDK1.2）<br/><br/><br/><b>5. 安全类装载</b></font> </p><dl><dd><br/><br/></dd><dd>动态类装载是Java虚拟机的一个重要特性，因为它为Java平台提供了一种在运行时安装软件的能力。它有许多独特的性质。首先，惰性装载表示按需求并在可能的最后一刻装载类；第二，通过增加链接时检查（它代替了某些运行时检查，并仅执行一次），动态类装载维护了Java虚拟机的类型安全；再有，程序员可定义他们自己的类装载器。例如，指定某些的远程位置，类装载器从哪里装载某些类，或为哪些类分配适当的安全属性等。最后，类装载器可为各种软件部件提供单独的命名空间。例如，一个浏览器可使用单独的类装载器从不同的web页装载Applets，这就维护了在那些Applet类之间的一定程度的隔离。事实上，这些类可包含名称相同的类──这些类被Java虚拟机当作截然不同的类型。 <br/><br/></dd><dd>类装载机制不仅是Java编程语言的重要动态特性，而且在保证安全方面也起到了关键的作用。原因是类装载器负责类文件的定位和提取、安全策略的查询以及用适当的许可定义类对象等任务。 <br/><br/><b><font color="#666699">5.1 类装载器类层次</font></b> <br/><br/></dd><dd>当装载一个类时，因为在一个Java虚拟机中可能有多个类装载器实例，所以一个重要的问题是，如何确定使用哪个类装载器。JDK1.2引进了具有独特性能的多重类装载器类，于是，另一个重要的问题就是，我们应该使用哪种类型的类装载器。 <br/><br/></dd><dd>类装载器类层次的根是一个被称为java.lang.ClassLoader的抽象类，它最初是在JDK1.0中被定义的，并在此之后，又做了进一步的扩展。类java.security.SecureClassLoader是在JDK1.2中引进的，它是这个抽象的ClassLoader类的子类和一个具体的实现。类java.net.URLClassLoader是SecureClassLoader的一个子类。 <br/><br/></dd><dd>一个被称作appletviewer的实用程序使用私有类sun.applet.AppletClassLoader来装载Applets。在JDK1.0中，AppletClassLoader是ClassLoader的一个子类和一个具体实现。在JDK1.2中，它是URLClassLoader的一个子类。 <br/><br/></dd><dd>当创建一个用户定制的类装载器类时，你可以从任何以上类装载器类中创建子类，这依赖于用户类装载器的特殊需求。因为AppletClassLoader是一个在sun.*包中定义的专用类，它不被支持并可能被更改，因而，不应该由它创建子类。 <br/><br/><b><font color="#666699">5.2 原始类装载器</font></b> <br/><br/></dd><dd>因为每个类都是由它的类装载器所装载的，并且每个类装载器本身是一个类，它必须由另外一个类装载器来装载，我们似乎遇到了明显的鸡和蛋的问题。也就是说第一个类装载器从何而来？一个"原始的"类装载器解开了这个类装载的难题。原始类装载器一般用本机语言编写（如C语言），并且在Java上下文中不表明它自己。原始类装载器经常从本地文件系统用依赖于平台的方式装载类。 <br/><br/></dd><dd>某些类，如：那些在Java.*包中定义的类，对完成Java虚拟机和运行时系统的功能是十分重要的，它们经常被引用为基类。由于历史上的原因，所有这样的类都有一个空值类装载器，这个空值类装载器或许是一个原始类装载器存在的唯一标记。事实上直接将空值类装载器当作原始类装载器看待则容易的多。 <br/><br/></dd><dd>如果给出在一个Java应用环境中的所有类，则我们可以轻易地形成一个类装载树，以反映类装载之间的关系，每个不是类装载器的类是一个叶子节点，每个类的父节点是它的类装载器，空值类装载器则是根类。因为不可能有循环所以这样的结构是一个树-一个类装载器不可能装载它的祖先类装载器， <br/><br/><b><font color="#666699">5.3 类装载器授权</font></b> <br/><br/></dd><dd>当一个类装载器被要求装载一个类时，这个类装载器可以自己装载这个类，也可以要求其它的类装载器来装载这个类。换言之，第一个类装载器可授权给第二个类装载器，授权关系在一定意义上是虚拟的，它与哪个类装载器装载哪个其它类装载器无关。当类装载器对象被创建时，则授权关系被形成（并且是以父子关系的形式）。然而，系统类装载器是所有类装载器授权根祖先。必须注意保证这种授权关系不包括循环，否则，该授权过程可能进入死循环。 <br/><br/><b><font color="#666699">5.4 类解析算法</font></b> <br/><br/></dd><dd>JDK 1.2 ClassLoader的方法装载一个类时的缺省实现，以如下顺序搜索类 <ul><li>检查该类是否已经被装载。<br/><br/></li><li>如果当前类装载器有一个指定的授权父辈，授权给这个父辈来装载这个类，如果没有父辈，则授权给原始类装载器。<br/><br/></li><li>调用一个能够用户化的方法，以搜索其它地方的类。 </li></ul></dd><dd>这里的第一步是为了查询类装载器的本地缓存（或它的功能等价物，如全局缓存），以确认一个要装载的类是否与目标类相匹配。最后一步提供了一种使寻找类的机制用户化的途径。这样，用户类装载器可覆盖这个方法来指明一个类应该如何被查询。例如一个Applet类装载器可覆盖这个方法以回到Applet的源主机，通过网络装载该类。 <br/><br/></dd><dd>如果在任意步骤中，找到该类，它就被返回；如果使用上述步骤未发现类，则一个异常ClassNotFound被扔出。 <br/><br/></dd><dd>类型安全是十分重要的，相同的类只能由相同的类装载器最多装载一次。如果这个类不是那些已装载的类之一，当前类装载器则试图将这个任务授权给父辈类装载器。这个情况可递推地发生。它可以保证使用适当类装载器。例如，当装载一个系统类时，在到达系统类装载器之前，授权过程将一直递推地进行。 <br/><br/></dd><dd>我们已在早些时候知道了授权算法。但是，假设给定任意一个类的名称，我们应从哪个类装载器开始，来装载这个类呢？有关确定类装载器的规则如下： <ul><li>当装载一个应用程序的第一个类时，使用URLClassLoader的一个新实例；<br/><br/></li><li>当装载一个Applet的第一个类时，使用AppletClassLoader的一个新实例；<br/><br/></li><li>当java.lang.ClassForName被直接调用时，使用原始类装载器；<br/><br/></li><li>当装载一个类的请求被现存类中对这个类的引用所触发时，使用现存类的类装载器来装载这个类。 </li></ul></dd><dd>请注意：有关使用URLClassLoader和AppletClassLoader实例的规则有一些例外，并根据特定的系统环境而有所变化。例如，一个web浏览器可能会选择再次使用一个现存的AppletClassLoader来从相同的web页中装载Applet类。 <br/><br/></dd><dd><p align="center">由于类装载器的能力极大，所以我们严格地限制由谁来创建类装载器实例。另一方面，我们期望能为应用程序或Applets提供一种简单的机制，以指明URL地址并从这些地方装载类。我们可提供静态方法以使各种应用程序能创建URLClassLoader类的实例，但没有其它装载器类型。 <br/><br/>..........|<a href="http://www.cnjavaclub.com/03/java_security/JDK12SA/jdk1_2-6.html">Next</a>|.......... </p><p align="center"><br/><font color="#333333" face="宋体" size="2">欢迎与我们联系：<a href="mailto:webmaster@prc.sun.com">webmaster@prc.sun.com</a><br/>版权所有 1997-1998 Sun(中国)公司，北京南礼士路66号建威大厦16层<br/>All rights reserved.<a href="http://www.cnjavaclub.com/java/share/text/SMICopyright.html">Legal Terms</a></font><!--- end copyright notice --></p></dd></dl>                </div>                    </div>
2604	 JavaTM安全体系结构6	工具  jdk  java  applet  solaris  windows  	988996680	839	wxyxl	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p><br/><font face="宋体" size="3">Java<sup>TM</sup>安全体系结构（JDK1.2）<br/><br/><br/><b>6. 安全性管理</b><br/><br/></font><font color="#666699" face="宋体" size="3"><b>6.1 管理Applet和应用程序</b></font><font face="宋体" size="3"> <br/></font></p><dl><dd><br/><br/></dd><dd>目前，所有JDK系统代码都是调用SecurityManager方法以检查现行策略并进行访问控制检查。不管一个Applet是在何时运行，都典型地安装一个安全管理器（SecurityManager实现）；appletviewer和大多数浏览器（包括Netscape和Microsoft的浏览器）都安装了安全管理器。 <br/><br/></dd><dd>当运行一个应用程序时，安全管理器不能被自动安装。为了象运行下载的Applet一样将同样的安全策略应用于一个在本地文件系统中的应用程序，运行该应用程序的用户必须使用新的 "-Djava.security.manager"命令行自变量（它设置java.security.manager的值）来调用Java虚拟机，如下所示： <br/><br/></dd><dd>java -Djava.security.manager SomeApp <br/><br/></dd><dd>或者，该应用程序本身必须调用java.lang.System类中的setSecurityManager方法，以安装一个安全管理器。 <br/><br/></dd><dd>可以用一个命令行来指定一个特殊的安全管理器。方法是在"-Djava.security.manager"后加上一个等号，再加上将作为安全管理器使用的类名。如下所示： <br/><br/></dd><dd>java -Djava.security.manager=COM.abc.MySecMgr SomeApp <br/><br/></dd><dd>如果没有安全管理器被指定，则将使用内置缺省安全管理器（除非应用程序安装了一个不同的安全管理器）。下列几行命令是等价的，它们都会安装缺省安全管理器： <br/><br/></dd><dd>java -Djava.security.manager SomeApp<br/></dd><dd>java -Djava.security.manager= "" SomeApp<br/></dd><dd>java -Djava.security.manager=default SomeApp <br/><br/></dd><dd>JDK1.2包括一个名为java.class.path的属性。那些被存储在本地文件系统但不被当作基础类的类应该在这个路径下。在这个路径下的类用安全类装载器来装载，并且符合当前推行的安全策略。 <br/><br/></dd><dd>还有一个 "-Djava.security.policy"命令行自变量，它的用法决定了应采用什么样的策略文件。这个命令行自变量在"缺省系统和用户策略文件"一节中详述。一般来说，如果你在一个命令行中未包括 "-Djava.security.policy"，则在安全属性文件中所指定的策略文件将被使用。 <br/><br/></dd><dd>当调用一个应用文件的执行时，你可以使用一个"-Djava.security.policy" 命令行自变量来指定一个附加的或不同的策略文件。举例如下：如果你键入以下命令行（这里的pURL是一个指定策略文件位置的URL），除了所有在安全属性中指定的策略文件外，上述由URL所指定的策略文件也将被装载。 <br/><br/></dd><dd><font size="2">java -Djava.security.manager -Djava.security.policy= pURL SomeApp</font> <br/><br/></dd><dd>如果你不这样做，而是使用如下命令，即使用双等号来代替上面的单等号，则只有指定的策略文件被使用，其它策略文件将被忽略： <br/><br/></dd><dd><font size="2">java -Djava.security.manager -Djava.security.policy = = pURL SomeApp</font> <br/><br/><b><font color="#666699">6.2 SecurityManager和AccessController</font></b> <br/><br/></dd><dd>新的访问控制机制是全部向后兼容的。例如，在SecurityManager中的所有check方法仍然被支持(尽管它们的大多数实现已被变为调用新的SecurityManager 中的checkPermission方法，它们的缺省实现调用AccessController 的checkPermission方法)。注意：某些内部安全检查可能驻留在SecurityManager类中，除非它能被参数化。 <br/><br/></dd><dd>到目前为止，我们还没有修改任何JDK代码系统以调用AccessController来代替调用SecurityManager(和检查类装载器的存在)，这是由于现有的第三方应用程序可能创建SecurityManager子类并使check方法用户化。事实上，我们增加了一个新的方法SecurityManager.checkPermission，它缺省地直接调用AccessController.checkPermission。 <br/><br/></dd><dd>为了理解SecurityManager和AccessController之间的关系，需注意：SecurityManager代表了一个访问控制的核心概念，而AccessController是实现一个特定的访问控制算法（利用例如doPrivileged方法这样一些特殊的性质）。通过保持SecurityManager的不断更新，我们维护向后兼容性（例如，兼容那些基于早期JDK版本而编写他们自己的安全管理器类的应用程序）和灵活性（例如，某些程序员希望客户化安全模式以实现强制性存取控制和多层安全控制）。通过提供AccessController，我们内置了算法。我们认为该算法是最具约束性的并且可以解脱了程序员在许多情况下不得不编写大量安全代码的重负。 <br/><br/></dd><dd>我们鼓励在应用程序代码中使用AccessController, 用户化安全管理器（通过建立子类）应该是最后一种手段，并且在做时应格外小心。另外，一个用户化的安全管理器（如在调用标准安全检查之前都要检查当日时间的管理器）应该也能够利用由AccessController在任何适当的时候提供的算法。 <br/><br/><b><font color="#666699">6.3 辅助工具</font></b> <br/><br/></dd><dd>这一节将简单地介绍三种有助于部署新的安全性能的工具。这些工具有可能在将来打包到一起。 <br/><br/></dd><dd>有关这些工具更详尽的文本可在JDK发布目录的子目录中找到： <br/><br/></dd><dd>/doc/tooldocs/solaris 和 /doc/tooldocs/win32 <br/><br/></dd><dd>这里的路径分隔符在Windows系统中实际是 "/"。 <br/><br/></dd><dd>例如：如果JDK被安装在Solaris系统中一个名为 "/jdk1.2"的目录中，那么，为Solaris用户和Windows用户的keytool文本则分别在下列目录中： <br/><br/></dd><dd>/jdk1.2/docs/tooldocs/solaris/keytool.html<br/></dd><dd>/jdk1.2/docs/tooldocs/win32/keytool.html <br/><br/></dd><dd>如果JDK被安装在Windows系统中一个名为 "C:/jdk1.2"的目录中，那么，为Solaris用户和Windows用户的keytool文本则分别在下列目录中： <br/><br/></dd><dd>C:/jdk1.2/docs/tooldocs/solaris/keytool.html<br/></dd><dd>C:/jdk1.2/docs/tooldocs/win32/keytool.html <br/><br/><b>6.3.1 密钥和证书管理工具</b> <br/><br/></dd><dd>keytool是一个密钥和证书管理工具。它使用户可以自己管理自己的公共/私有密钥对及相关的用来自我认证（自我认证是用户向其他用户/服务进行自我身份说明）的证书，或使用数字签字来管理数据完整性及认证服务。认证信息既包括X.509证书的序列（链）和一个相关的私有密钥（它可被所谓的"别名"来引用）。这个工具还可以管理证书（它是被用户所"信任"的），这些证书作为认证信息存储在同一个数据库中，并且可被"别名"来引用。 <br/><br/></dd><dd>keytool在一个所谓的keystore中存储密钥和证书。缺省keystore是以文件形式来实现的。它用口令来保护私有密钥。 <br/><br/></dd><dd>X.509证书的链是由一个被称为认证中心 (或CA) 的组织所提供的。身份（包括CA）使用他们的私有密钥来认证他们与对象（如使用SSL保护的通道）的关联、与他们所签署的代码文档的关联或与他们所发布的X.509证书（包括CA）的关联等。作为一种"解铃"工具，使用-genkey命令所生成的证书可能被使用到一个认证中心返回一个证书链为止。 <br/><br/></dd><dd>在这个数据库中的私有密钥总是以加密的形式存储，它使得这些私有密钥很难被非法得到。访问或修改数据库需要口令。这些私有密钥是使用"口令"来加密的，它可能有几个词那样长。如果口令被丢失，则那些认证密钥将不能被恢复。 <br/><br/></dd><dd>事实上，每个在keystore中的私有密钥都可以使用它自己的口令进行保护，它与保护keystore总的口令可能相同，也可能不同。 <br/><br/></dd><dd>这个工具是要在（在目前情况下）命令行中使用。在命令行中，你可以将"keytool" 作为一个命令而直接键入。keytool是一个可执行Java类的命令文件，它与JDK被建在一起。 <br/><br/></dd><dd>该命令的选项，可以任何顺序提供。不正确的选项或键入 "keytool -help"会在输出设备上（如一个外壳Window）输出该一个工具用法小结。如下所示： <br/><font size="2"></font><pre>% keytool -helpKeyTool usage: -certreq     [-v] [-alias ] [-sigalg ]             [-file ] [-keypass ]             [-keystore ] [-storepass ]             [-storetype <i>storetype</i>] -delete      [-v] -alias              [-keystore ] [-storepass ]             [-storetype <i>storetype</i>] -export      [-v] [rfc] [-alias ] [-file ]             [-keystore ] [-storepass ]             [-storetype <i>storetype</i>] -genkey      [-v] [-alias ] [-keyalg ]             [-keysize ] [-sigalg ]             [-dname ] [-validity ]             [-keypass ] [-keystore ]             [-storepass ]             [-storetype <i>storetype</i>] -help  -identitydb  [-v] [-file ] [-keystore ]             [-storepass ]             [-storetype <i>storetype</i>]-import      [-v] [-noprompt] [-alias ]             [-file ] [-keypass ]             [-keystore ] [-storepass ]             [-storetype <i>storetype</i>] -keyclone    [-v] [-alias ] -dest              [-keypass ] [-new ]             [-keystore ] [-storepass ]             [-storetype <i>storetype</i>] -keypasswd   [-v] [-alias ]             [-keypass ] [-new ]             [-keystore ] [-storepass ]             [-storetype <i>storetype</i>] -list        [-v | -rfc] [-alias ]             [-keystore ] [-storepass ]             [-storetype <i>storetype</i>]-printcert   [-v] [-file ] -selfcert    [-v] [-alias ] [-sigalg ]             [-dname ] [-validity ]             [-keypass ] [-keystore ]             [-storepass ]             [-storetype <i>storetype</i>] -storepasswd  [-v] [-new ]             [-keystore ] [-storepass ]              [-storetype <i>storetype</i>]</pre><b> 6.3.2 策略工具</b> </dd><dd>策略工具是一个图形用户界面（如屏幕图形所示），它帮助用户（如系统管理员）指定、生成、编辑、输出或输入一个安全策略。该工具从命令行作为policytool被调用。这又是一个命令文件，它与JDK建在一起来调用适当的（非公共的）实现类。 <br/><br/></dd><dd>详细信息请看策略工具用法信息的有关文本和最新的屏幕图形。上述文本存储在policytool.html文件中，在如下路径： <br/><br/></dd><dd>/docs/tooldocs/solaris/ 或 /docs/toodocs/win32/ <br/><br/></dd><dd><p align="center">这里的文件分隔符在Windows系统中实际是反斜线。 <br/><br/><img alt="jdk-chart8.gif" border="0" height="419" src="http://www.cnjavaclub.com/03/java_security/JDK12SA/jdk-chart8.gif" width="400"/><br/><b>6.3.3 JAR签字和校验工具</b> <br/><br/></p></dd><dd>jarsigner工具可被用来数字地签署Java文档（JAR文件）并校验这个签字。与策略工具相似，这个工具依赖于由keytool管理的keystore。它的用法可快速小结如下： <br/><font size="2"></font><pre>% jarsignerUsage: jarsigner [options] jar-file alias       jarsigner -verify [options] jar-file  [-keystore ]         keystore file location  [-storepass ]   password for keystore integrity  [-keypass ]     password for private key (if different)  [-sigfile ]         name of .SF/.DSA file  [-signedjar ]       name of signed JAR file  [-verify]                 verify a signed JAR file  [-verbose]                verbose output when signing/verifying  [-certs]          display certificates when verbose and verifying  [-internalsf]             include .SF file inside signature block  [-sectionsonly]           don't compute hash of entire manifest</pre></dd><dd><p align="center">这个工具也是与JDK建在一起的命令文件。我们希望这个工具和jar工具命令能够在将来合并，以形成一个单一的用来创建JARs的（签字或不签字的）命令行原语。 <br/><br/>..........|<a href="http://www.cnjavaclub.com/03/java_security/JDK12SA/jdk1_2-7.html">Next</a>|.......... </p><p align="center"><br/><font color="#333333" face="宋体" size="2">欢迎与我们联系：<a href="mailto:webmaster@prc.sun.com">webmaster@prc.sun.com</a><br/>版权所有 1997-1998 Sun(中国)公司，北京南礼士路66号建威大厦16层<br/>All rights reserved.<a href="http://www.cnjavaclub.com/java/share/text/SMICopyright.html">Legal Terms</a></font><!--- end copyright notice --></p></dd></dl>                </div>                    </div>
2605	 JavaTM安全体系结构7	algorithm  算法  object  java  存储  string  	988996680	781	wxyxl	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p><br/><font face="宋体" size="3">Java<sup>TM</sup>安全体系结构（JDK1.2）<br/><br/><br/><b>7. GuardedObject和SignedObject</b><br/><br/></font><font color="#666699" face="宋体" size="3"><b>7.1 java.security.GuardedObject和java.security.Guard</b></font><font face="宋体" size="3"> <br/></font></p><dl><dd><br/><br/></dd><dd><p align="center">回想一下，当访问控制决策必须在不同的上下文中作出时，AccessControlContext类是非常有用的。这里有另外一种情况：资源的供应者与资源的消费者不在同一个线程，并且消费者线程不能为供应者线程提供访问控制上下文信息（因为上下文是安全敏感的；或上下文太大，不能传递；或由于其它原因）。对这种情况，我们提供了一个被称为GuardedObject的类，来保护对这个资源的访问。见下图说明： <br/><img alt="jdk-chart9.gif" border="0" height="220" src="http://www.cnjavaclub.com/03/java_security/JDK12SA/jdk-chart9.gif" width="381"/><br/></p></dd><dd>基本的想法是：资源的供应者可创建一个代表这个资源的对象，再创建一个将资源对象嵌套在内的GuardedObject, 然后，将GuardedObject提供给消费者。在创建GuardedObject时，供应者还要指定一个Guard对象；这样，如果某些在这个Guard内部的（安全）检查令人满意的话，任何人（包括消费者）则只能获得资源对象。 <br/><br/></dd><dd>Guard是一个界面，所以任何对象可选择成为一个Guard。这个界面上的唯一方法被称为checkGuard。它提取一个Object变量，并执行一定的（安全）检查。java.security中的Permission类实现这个Guard界面。 <br/><br/></dd><dd>例如，假设一个系统线程被要求为阅读访问打开一个文件/a/b/c.txt，但是系统线程不知道请求者是谁或这个请求是在什么情况下被做出的。因此，正确的访问控制决策不能在服务器端做出。系统线程可使用GuardedObject来延迟访问控制检查。如下所示： <br/><font size="2"></font><pre>FileInputStream f = new FileInputStream ("/a/b/c.txt");FilePermission p = new FilePermission ("/a/b/c.txt", "read");GuardedObject g = new GuardedObject (f, p);</pre></dd><dd>现在，系统线程可将g传递给消费者线程。消费者线程要获得文件输入流，必须调用： <br/><br/></dd><dd>FileInputStream fis = (FileInputStream) g.getObject(); <br/><br/></dd><dd>这个方法结果调用在Guard对象p上的checkGuard方法，并且由于p是一个许可，所以它的checkGuard方法事实上是： <br/><br/></dd><dd>SecurityManager sm = System.getSecurityManager ();<br/></dd><dd>if (sm ! = null) sm.checkPermission (this); <br/><br/></dd><dd>这可以保证一个真正的访问控制检查发生在消费者上下文内。事实上，你可以在许多情况下，替换常用哈希表和访问控制列表，并直接存储GuardedObject的哈希表。 <br/><br/></dd><dd>这个GuardedObject和Guard的基本模式是非常通用的，我们期望通过继承这个基本的GuardedObject和Guard的类，开发人员可以轻松地获得极强大的访问控制工具。例如：用一个适当的方法的Guard可获得每个方法的调用，并且一个Guard可检查该日的时间、调用者的签字或其它证明、或任何其它相关的信息。 <br/><br/></dd><dd>注意：由于GuardedObject返回一个Object，所以某些键入信息会丢失。要在合作方之间使用GuardedObject，接受方应该了解希望获得对象的什么类型（以及转换类型）。事实上，我们预见GuardedObject的多数用法涉及创建子类（即形成一个GuardedFileInputStream类），从而封装键入信息，类型转换也可在子类中相应地进行。 <br/><br/><b><font color="#666699">7.2 java.security.SignedObject</font></b> <br/><br/></dd><dd><p align="center">这个类是其它安全要素的基本积木块。SignedObject包含另一个可序列化的对象，（将）签字的对象和它的数字签字。如果数字签字不是空，它将包含一个有效的已签字的对象的数字签字。这可以用下图表示： <br/><img alt="jdk-chart10.gif" border="0" height="200" src="http://www.cnjavaclub.com/03/java_security/JDK12SA/jdk-chart10.gif" width="298"/><br/></p></dd><dd>底层签字算法是通过一个被当作sign方法调用来设置的，该方法的参数是Signature对象，算法可以是如下算法之一：NIST标准DSA、使用DSA和SHA-1。与数字签字一样，算法是用通常方式说明的，如 "SHA/DSA"。 <br/><br/></dd><dd>已签字的对象是一个初始对象的"深度拷贝"（以序列化的形式），一旦拷贝完成，初始对象的操作对该拷贝不产生副作用，一个已签字的对象是永恒不变的。 <br/><br/></dd><dd>创建一个已签字对象的典型事例如下： <br/><font size="2"></font><pre>Signature signingEngine = Signature.getInstance(algorithm,provider);SignedObject so = new SignedObject(myobject, signingKey, signingEngine);</pre></dd><dd>一个典型的校验例子如下，so是一个被收到的SignedObject对象。如果已知算法的名称，则这里的第一行可被忽略： <br/><font size="2"></font><pre>String algorithm = so.getAlgorithm();Signature verificationEngine = Signature.getInstance(algorithm, provider);so.verify(verificationEngine);</pre> </dd><dd>SignedObject的潜在应用包括： <ul><li>它可作为一个不可伪造的鉴别令牌在任意Java应用环境内使用：它可任意传递，而不必担心该令牌在没有被检测到的情况下而被恶意更改；<br/><br/></li><li>它可被用来为Java运行时以外的存储器签署并序列化数据/对象（例如，在磁盘上存储访问控制的关键数据）； <br/><br/></li><li>嵌套的SignedObjects可被用来构造一个签字的逻辑顺序，就象认证和授权的链一样。 </li></ul></dd><dd><p align="center">我们期望这个类在将来可以创建子类，以允许在相同的签字对象上有多个签字。那样，在这个基础类上的现存方法调用将在语意上是全兼容的。特别是如果只有一个签字，则任意get方法将返回单独值；如果有多个签字，则将从签字集中返回一个任意值。 <br/><br/>..........|<a href="http://www.cnjavaclub.com/03/java_security/JDK12SA/jdk1_2-8.html">Next</a>|.......... </p><p align="center"><br/><font color="#333333" face="宋体" size="2">欢迎与我们联系：<a href="mailto:webmaster@prc.sun.com">webmaster@prc.sun.com</a><br/>版权所有 1997-1998 Sun(中国)公司，北京南礼士路66号建威大厦16层<br/>All rights reserved.<a href="http://www.cnjavaclub.com/java/share/text/SMICopyright.html">Legal Terms</a></font><!--- end copyright notice --></p></dd></dl>                </div>                    </div>
2606	 JavaTM安全体系结构8	applet  jar  jdk  文档  java  加密  	988996740	725	wxyxl	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p><br/><font face="宋体" size="3">Java<sup>TM</sup>安全体系结构（JDK1.2）<br/><br/><br/><b>8. 未来发展方向</b><br/><br/></font><font color="#666699" face="宋体" size="3"><b>8.1 用户、认证和信任书</b></font><font face="宋体" size="3"> <br/></font></p><dl><dd><br/><br/></dd><dd>今天，主体（例如：用户）的概念已经不太清楚了，因为每个JVM都由一个用户所拥有。将来，有必要扩展ProtectionDomain的现存概念以包括"代表一个主体运行"的概念。 <br/><br/></dd><dd>因此，我们热切地期望在不远的将来为你提供如下特性： <ul><li>明确的主体的概念和类<br/><br/></li><li>用户认证原语(既有基于口令的, 也是其它的)<br/><br/></li><li>交叉保护域主体认证协议<br/><br/></li><li>认证和授权一般机制 </li></ul><p><br/><b><font color="#666699">8.2 资源消费管理</font></b> <br/><br/></p></dd><dd>在某些情况下, 资源消费管理相对容易实现(例如, 限制任何应用程序可能突然出现的窗口数量); 而在某些其它情况下, 它又是相当难以有效实现的(例如, 限制内存或文件系统的使用)。将来, 我们要不断地研究这个问题。 <br/><br/><b><font color="#666699">8.3 随机许可的分组</font></b> <br/><br/></dd><dd>有时将一些许可组合在一起并使用速记名来引用它们可简化我们的工作。例如, 我们想要使一个被称作"SuperPermission"的许可包括(并隐含)FilePermission("-", "read,white")和SocketPermission("*","connect,accept"), 从技术上讲, 我们可以使用类Permission或一个相似的类用add方法来增加所需要的类, 从而实现这个超级许可。这样的分组可以是任意复杂的。 <br/><br/></dd><dd>更困难的事情是: 第一, 要理解在发出这样一个超级许可时, 实际上是授予了一个什么样的许可, 因此就必须创建一个固定的、并且是命名的许可类, 来表示一个静态指定的许可组; 或者就需要在策略文件中详述这些成员的许可; 第二, 由于分组的许可可能需要被扩展, 所以处理策略(文件)可能更复杂; 第三, 分组许可的嵌套也进一步增加了复杂性。 <br/><br/><b><font color="#666699">8.4 对象级保护</font></b> <br/><br/></dd><dd>假设已给定Java编程语言的面向对象的特性，则可以想象，开发人员将会从一整套适当的对象级保护机制中获得好处。这种对象级保护一是可以超越有Java编程语言所提供的自然保护；二是可以补充基于线程的访问控制机制。 <br/><br/></dd><dd>一个这样的机制是SignedObject。我们将提供对象SealedObject，它使用加密技术来隐藏对象的内容, 它与SignedObject相并行（由于美国现行出口控制条例对加密使用上的限制，SealedObject可能将与JDK分开提供）。 <br/><br/></dd><dd>GuardedObject是在每个类/对象每个方法等级上加强访问控制的一般途径。然而，这个方法应该仅被选择性地使用，部分原因是这种控制类型在高层上是难于管理的。 <br/><br/><b><font color="#666699">8.5 创建保护域的子域</font></b> <br/><br/></dd><dd>一个在当前未实现的潜在而有用的概念是"子域"的概念。一个子域被包含在另一个子域中。一个子域的许可和特权不会比它的父辈域的许可和特权多。例如，可创建一个域，以选择性地进一步限制一个程序应该做什么。 <br/><br/></dd><dd>域经常被认为是支持继承的：一个子域将自动继承其父辈域的安全属性，除非在某种情况下，父辈域要明显地限制子域。用可信码的概念，通过权力放大，有可能放宽对子域的限制。 <br/><br/></dd><dd>为方便起见，我们可以将系统域当作一个单独的、所有系统代码的一个大的集合。然而，为了更好的保护，系统代码应该运行在多个系统域中，每个域保护一个特殊资源类型并被赋予一些特殊的权力。例如，如果文件系统代码和网络系统代码运行在各自的域中，则前者无权访问网络系统的资源，后者也无权访问文件系统的资源。这样一个错误或安全性缺陷所造成的风险和后果将被限制在它自己的域中。 <br/><br/><b><font color="#666699">8.6 运行有签字内容的Applets</font></b> <br/><br/></dd><dd>有关代码签字的JAR和Manifest规范允许非常灵活的形式。在相同文档中的类可用不同的密钥签字，并且一个类可用一个密钥来签署、解除签字，或用多个密钥签字。在文档中的其它资源（如音频剪辑和图形图象等）也可被签字或解除签字。 <br/><br/></dd><dd>与这种灵活性随之而来的是如何解释的问题。下列问题 需要被回答，特别是当密钥被区别对待时： <br/><br/></dd><dd>1. 如果在文档中的任何类被签字的话，图象和音频数据是否应该用相同密钥签署？ <br/><br/></dd><dd>2. 如果图象和音频被使用不同的密钥签字，它们是否可被放置在相同的appletviewer（或浏览器页）中，或者是否应该被发送到不同的viewer中进行处理？ <br/><br/></dd><dd>这些问题并不容易回答，它们需要相容性交叉平台及最有效的产品。我们的折中的方案是要提供一种简单的答案──将所有图象和音频送到相同的Applet类装载器中进行处理（无论它们是签字的或未签字的）。一旦上述问题被达成共识，则这个临时的解决方案将被改进。 <br/><br/></dd><dd>再有，如果一个数字签字由于一个类文件的字节码内容与已签字的JAR哈希值不匹配而不能被验证，则一个安全异常被扔出，因为JAR作者的最初意图被明显地改变了。以前，有人建议将这些代码当作不可信代码来运行。这种想法是不受欢迎的。因为Applet类装载器允许装载由多方签字的代码。这意味着接受部分更改的JAR文件将允许一条不可信代码与相同的类装载器共同运行并通过同一类装载器访问其它代码。 <a></a><br/><br/><br/><font size="4">9 结束语</font> <br/><br/></dd><dd>本文概述了JDK1.2实现的主要安全特性的生成动机并介绍了这种新的安全体系结构。 <br/><br/></dd><dd><p align="center">请将你的评价反馈给 java-security@java.sun.com (它被存档的web地址为： <a href="http://java.sun.com/security/hypermail/java-security-archive/index.html">http://java.sun.com/security/hypermail/<br/>java-security-archive/index.html</a> )。 如需保密请直接发送至作者本人(<a href="mailto:li.gong@sun.com">li.gong@sun.com</a>)。 <br/><br/>..........|<a href="http://www.cnjavaclub.com/03/java_security/JDK12SA/jdk1_2.html">Back</a>|.......... </p><p align="center"><br/><font color="#333333" face="宋体" size="2">欢迎与我们联系：<a href="mailto:webmaster@prc.sun.com">webmaster@prc.sun.com</a><br/>版权所有 1997-1998 Sun(中国)公司，北京南礼士路66号建威大厦16层<br/>All rights reserved.<a href="http://www.cnjavaclub.com/java/share/text/SMICopyright.html">Legal Terms</a></font><!--- end copyright notice --></p></dd></dl>                </div>                    </div>
2872	 编程修养（一）	编程  语言  加密  工作  产品  c  	1052367060	51388	haoel	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p align="center"><strong>编程修养<br/>————</strong></p><p><font face="Courier New" size="2">什么是好的程序员？是不是懂得很多技术细节？还是懂底层编程？还是编程速度比较快？我觉得都不是。对于一些技术细节来说和底层的技术，只要看帮助，查资料就能找到，对于速度快，只要编得多也就熟能生巧了。</font></p><p><font face="Courier New" size="2">我认为好的程序员应该有以下几方面的素质：</font></p><p><font face="Courier New" size="2">  1、有专研精神，勤学善问、举一反三。<br/>  2、积极向上的态度，有创造性思维。<br/>  3、与人积极交流沟通的能力，有团队精神。<br/>  4、谦虚谨慎，戒骄戒燥。<br/>  5、写出的代码质量高。包括：代码的稳定、易读、规范、易维护、专业。</font></p><p><font face="Courier New" size="2">这些都是程序员的修养，这里我想谈谈“编程修养”，也就是上述中的第5点。我觉得，如果我要了解一个作者，我会看他所写的小说，如果我要了解一个画家，我会看他所画的图画，如果我要了解一个工人，我会看他所做出来的产品，同样，如果我要了解一个程序员，我想首先我最想看的就是他的程序代码，程序代码可以看出一个程序员的素质和修养，程序就像一个作品，有素质有修养的程序员的作品必然是一图精美的图画，一首美妙的歌曲，一本赏心悦目的小说。</font></p><p><font face="Courier New" size="2">我看过许多程序，没有注释，没有缩进，胡乱命名的变量名，等等，等等，我把这种人统称为没有修养的程序，这种程序员，是在做创造性的工作吗？不，完全就是在搞破坏，他们与其说是在编程，还不如说是在对源程序进行“加密”，这种程序员，见一个就应该开除一个，因为他编的程序所创造的价值，远远小于需要在上面进行维护的价值。</font></p><p><font face="Courier New" size="2">程序员应该有程序员的修养，那怕再累，再没时间，也要对自己的程序负责。我宁可要那种动作慢，技术一般，但有良好的写程序风格的程序员，也不要那种技术强、动作快的“搞破坏”的程序员。有句话叫“字如其人”，我想从程序上也能看出一个程序员的优劣。因为，程序是程序员的作品，作品的好坏直截关系到程序员的声誉和素质。而“修养”好的程序员一定能做出好的程序和软件。</font></p><p><font face="Courier New" size="2">有个成语叫“独具匠心”，意思是做什么都要做得很专业，很用心，如果你要做一个“匠”，也就是造诣高深的人，那么，从一件很简单的作品上就能看出你有没有“匠”的特性，我觉得做一个程序员不难，但要做一个“程序匠”就不简单了。编程序很简单，但编出有质量的程序就难了。</font></p><p><font face="Courier New" size="2">我在这里不讨论过深的技术，我只想在一些容易让人忽略的东西上说一说，虽然这些东西可能很细微，但如果你不注意这些细微之处的话，那么他将会极大的影响你的整个软件质量，以及整个软件程的实施，所谓“千里之堤，毁于蚁穴”。</font></p><p><font face="Courier New" size="2">“细微之处见真功”，真正能体现一个程序的功底恰恰在这些细微之处。</font></p><p><font face="Courier New" size="2">这就是程序员的——编程修养。我总结了在用C/C++语言（主要是C语言）进行程序写作上的三十二个“修养”，通过这些，你可以写出质量高的程序，同时也会让看你程序的人渍渍称道，那些看过你程序的人一定会说：“这个人的编程修养不错”。</font></p><p><font face="Courier New" size="2">    ————————————————————————<br/>        <br/>        01、版权和版本<br/>        02、缩进、空格、换行、空行、对齐<br/>        03、程序注释<br/>        04、函数的[in][out]参数<br/>        05、对系统调用的返回进行判断<br/>        06、if 语句对出错的处理<br/>        07、头文件中的#ifndef<br/>        08、在堆上分配内存<br/>        09、变量的初始化<br/>        10、h和c文件的使用<br/>        11、出错信息的处理<br/>        12、常用函数和循环语句中的被计算量<br/>        13、函数名和变量名的命名<br/>        14、函数的传值和传指针<br/>        15、修改别人程序的修养<br/>        16、把相同或近乎相同的代码形成函数和宏<br/>        17、表达式中的括号<br/>        18、函数参数中的const<br/>        19、函数的参数个数<br/>        20、函数的返回类型，不要省略<br/>        21、goto语句的使用<br/>        22、宏的使用<br/>        23、static的使用<br/>        24、函数中的代码尺寸<br/>        25、typedef的使用<br/>        26、为常量声明宏<br/>        27、不要为宏定义加分号<br/>        28、||和&amp;&amp;的语句执行顺序<br/>        29、尽量用for而不是while做循环<br/>        30、请sizeof类型而不是变量<br/>        31、不要忽略Warning<br/>        32、书写Debug版和Release版的程序</font></p><p><font face="Courier New" size="2">    ————————————————————————</font></p><p align="right"><a href="http://www.csdn.net/Develop/read_article.asp?id=18270"><font color="#0000ff" face="Courier New" size="2"><strong>下一页</strong></font></a><font color="#0000ff" face="Courier New" size="2"><strong>-&gt;</strong></font></p><p><font face="Courier New" size="2"><strong>（版权所有，转载时请注明出处和作者信息）</strong></font></p><p><font face="Courier New" size="2"></font> </p>                </div>                    </div>
2885	 用GDB调试程序（七）	语言  pascal  fortran  unix  scheme  c++  	1057999320	36690	haoel	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p><br/><font face="Courier New"><strong>改变程序的执行<br/>———————</strong></font></p><p><font face="Courier New">    一旦使用GDB挂上被调试程序，当程序运行起来后，你可以根据自己的调试思路来动态地在GDB中更改当前被调试程序的运行线路或是其变量的值，这个强大的功能能够让你更好的调试你的程序，比如，你可以在程序的一次运行中走遍程序的所有分支。<br/>    <br/><strong>    <br/>一、修改变量值</strong></font></p><p><font face="Courier New">    修改被调试程序运行时的变量值，在GDB中很容易实现，使用GDB的print命令即可完成。如：<br/>    <br/>        (gdb) print x=4<br/>    <br/>    x=4这个表达式是C/C++的语法，意为把变量x的值修改为4，如果你当前调试的语言是Pascal，那么你可以使用Pascal的语法：x:=4。<br/>    <br/>    在某些时候，很有可能你的变量和GDB中的参数冲突，如：<br/>    <br/>        (gdb) whatis width<br/>        type = double<br/>        (gdb) p width<br/>        $4 = 13<br/>        (gdb) set width=47<br/>        Invalid syntax in expression.</font></p><p><font face="Courier New">    因为，set width是GDB的命令，所以，出现了“Invalid syntax in expression”的设置错误，此时，你可以使用set var命令来告诉GDB，width不是你GDB的参数，而是程序的变量名，如：<br/>    <br/>        (gdb) set var width=47<br/>        <br/>    另外，还可能有些情况，GDB并不报告这种错误，所以保险起见，在你改变程序变量取值时，最好都使用set var格式的GDB命令。<br/>    </font></p><p><font face="Courier New"><strong>二、跳转执行</strong></font></p><p><font face="Courier New">    一般来说，被调试程序会按照程序代码的运行顺序依次执行。GDB提供了乱序执行的功能，也就是说，GDB可以修改程序的执行顺序，可以让程序执行随意跳跃。这个功能可以由GDB的jump命令来完：<br/>    <br/>    jump &lt;linespec&gt;<br/>    指定下一条语句的运行点。&lt;linespce&gt;可以是文件的行号，可以是file:line格式，可以是+num这种偏移量格式。表式着下一条运行语句从哪里开始。<br/>    <br/>    jump &lt;address&gt;<br/>    这里的&lt;address&gt;是代码行的内存地址。<br/>    <br/>    注意，jump命令不会改变当前的程序栈中的内容，所以，当你从一个函数跳到另一个函数时，当函数运行完返回时进行弹栈操作时必然会发生错误，可能结果还是非常奇怪的，甚至于产生程序Core Dump。所以最好是同一个函数中进行跳转。<br/>    <br/>    熟悉汇编的人都知道，程序运行时，有一个寄存器用于保存当前代码所在的内存地址。所以，jump命令也就是改变了这个寄存器中的值。于是，你可以使用“set $pc”来更改跳转执行的地址。如：<br/>    <br/>    set $pc = 0x485</font></p><p><br/><font face="Courier New"><strong>三、产生信号量</strong></font></p><p><font face="Courier New">    使用singal命令，可以产生一个信号量给被调试的程序。如：中断信号Ctrl+C。这非常方便于程序的调试，可以在程序运行的任意位置设置断点，并在该断点用GDB产生一个信号量，这种精确地在某处产生信号非常有利程序的调试。<br/>    <br/>    语法是：signal &lt;singal&gt;，UNIX的系统信号量通常从1到15。所以&lt;singal&gt;取值也在这个范围。<br/>    <br/>    single命令和shell的kill命令不同，系统的kill命令发信号给被调试程序时，是由GDB截获的，而single命令所发出一信号则是直接发给被调试程序的。<br/>    </font></p><p><font face="Courier New"><strong>四、强制函数返回</strong></font></p><p><font face="Courier New">    如果你的调试断点在某个函数中，并还有语句没有执行完。你可以使用return命令强制函数忽略还没有执行的语句并返回。<br/>    <br/>    return<br/>    return &lt;expression&gt;<br/>    使用return命令取消当前函数的执行，并立即返回，如果指定了&lt;expression&gt;，那么该表达式的值会被认作函数的返回值。<br/>    <br/>    <br/><strong>五、强制调用函数</strong></font></p><p><font face="Courier New">    call &lt;expr&gt;<br/>    表达式中可以一是函数，以此达到强制调用函数的目的。并显示函数的返回值，如果函数返回值是void，那么就不显示。<br/>    <br/>    另一个相似的命令也可以完成这一功能——print，print后面可以跟表达式，所以也可以用他来调用函数，print和call的不同是，如果函数返回void，call则不显示，print则显示函数返回值，并把该值存入历史数据中。</font></p><p><font face="Courier New"><strong></strong></font> </p><p><font face="Courier New"><strong>在不同语言中使用GDB<br/>——————————</strong></font></p><p><font face="Courier New">GDB支持下列语言：C, C++, Fortran, PASCAL, Java, Chill, assembly, 和 Modula-2。一般说来，GDB会根据你所调试的程序来确定当然的调试语言，比如：发现文件名后缀为“.c”的，GDB会认为是C程序。文件名后缀为“.C, .cc, .cp, .cpp, .cxx, .c++”的，GDB会认为是C++程序。而后缀是“.f, .F”的，GDB会认为是Fortran程序，还有，后缀为如果是“.s, .S”的会认为是汇编语言。</font></p><p><font face="Courier New">也就是说，GDB会根据你所调试的程序的语言，来设置自己的语言环境，并让GDB的命令跟着语言环境的改变而改变。比如一些GDB命令需要用到表达式或变量时，这些表达式或变量的语法，完全是根据当前的语言环境而改变的。例如C/C++中对指针的语法是*p，而在Modula-2中则是p^。并且，如果你当前的程序是由几种不同语言一同编译成的，那到在调试过程中，GDB也能根据不同的语言自动地切换语言环境。这种跟着语言环境而改变的功能，真是体贴开发人员的一种设计。</font></p><p><br/><font face="Courier New">下面是几个相关于GDB语言环境的命令：</font></p><p><font face="Courier New">    show language <br/>        查看当前的语言环境。如果GDB不能识为你所调试的编程语言，那么，C语言被认为是默认的环境。<br/>        <br/>    info frame<br/>        查看当前函数的程序语言。<br/>        <br/>    info source<br/>        查看当前文件的程序语言。<br/>    <br/>如果GDB没有检测出当前的程序语言，那么你也可以手动设置当前的程序语言。使用set language命令即可做到。</font></p><p><font face="Courier New">    当set language命令后什么也不跟的话，你可以查看GDB所支持的语言种类：<br/>    <br/>        (gdb) set language<br/>        The currently understood settings are:<br/>        <br/>        local or auto    Automatic setting based on source file<br/>        c                Use the C language<br/>        c++              Use the C++ language<br/>        asm              Use the Asm language<br/>        chill            Use the Chill language<br/>        fortran          Use the Fortran language<br/>        java             Use the Java language<br/>        modula-2         Use the Modula-2 language<br/>        pascal           Use the Pascal language<br/>        scheme           Use the Scheme language<br/>        <br/>    于是你可以在set language后跟上被列出来的程序语言名，来设置当前的语言环境。<br/>    <br/>    </font></p><p><font face="Courier New"><strong>后记<br/>——</strong></font></p><p><font face="Courier New">    GDB是一个强大的命令行调试工具。大家知道命令行的强大就是在于，其可以形成执行序列，形成脚本。UNIX下的软件全是命令行的，这给程序开发提代供了极大的便利，命令行软件的优势在于，它们可以非常容易的集成在一起，使用几个简单的已有工具的命令，就可以做出一个非常强大的功能。<br/>    <br/>    于是UNIX下的软件比Windows下的软件更能有机地结合，各自发挥各自的长处，组合成更为强劲的功能。而Windows下的图形软件基本上是各自为营，互相不能调用，很不利于各种软件的相互集成。在这里并不是要和Windows做个什么比较，所谓“寸有所长，尺有所短”，图形化工具还是有不如命令行的地方。（看到这句话时，希望各位千万再也不要认为我就是“鄙视图形界面”，和我抬杠了 ）<br/>    <br/>    我是根据版本为5.1.1的GDB所写的这篇文章，所以可能有些功能已被修改，或是又有更为强劲的功能。而且，我写得非常仓促，写得比较简略，并且，其中我已经看到有许多错别字了（我用五笔，所以错字让你看不懂），所以，我在这里对我文中的差错表示万分的歉意。<br/>    <br/>    文中所罗列的GDB的功能时，我只是罗列了一些带用的GDB的命令和使用方法，其实，我这里只讲述的功能大约只占GDB所有功能的60%吧，详细的文档，还是请查看GDB的帮助和使用手册吧，或许，过段时间，如果我有空，我再写一篇GDB的高级使用。<br/>    <br/>    我个人非常喜欢GDB的自动调试的功能，这个功能真的很强大，试想，我在UNIX下写个脚本，让脚本自动编译我的程序，被自动调试，并把结果报告出来，调试成功，自动checkin源码库。一个命令，编译带着调试带着checkin，多爽啊。只是GDB对自动化调试目前支持还不是很成熟，只能实现半自动化，真心期望着GDB的自动化调试功能的成熟。<br/>    <br/>    如果各位对GDB或是别的技术问题有兴趣的话，欢迎和我讨论交流。本人目前主要在UNIX下做产品软件的开发，所以，对UNIX下的软件开发比较熟悉，当然，不单单是技术，对软件工程实施，软件设计，系统分析，项目管理我也略有心得。欢迎大家找我交流，（QQ是：753640，MSN是：haoel@hotmail.com）</font></p><p align="right"><font face="Courier New">&lt;-</font><a href="http://www.csdn.net/develop/read_article.asp?id=19544"><font color="#29098a" face="Courier New">上一页</font></a><font face="Courier New">  </font></p><p><strong><font face="Courier New">（版权所有，转载时请注明作者和出处）</font></strong></p>                </div>                    </div>
2886	 跟我一起写Makefile（一）	makefile  编译器  object  command  file  unix  	1077612480	350281	haoel	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p align="center"><strong><font face="楷体_GB2312" size="6">跟我一起写 Makefile</font></strong></p><p align="center"><font face="Courier New"><strong><font size="6"></font></strong><br/><font size="4"> <strong>陈皓</strong></font></font></p><p align="left"><font face="Courier New" size="4"><strong>概述<br/>——</strong></font></p><p><font face="Courier New">什么是makefile？或许很多Winodws的程序员都不知道这个东西，因为那些Windows的IDE都为你做了这个工作，但我觉得要作一个好的和professional的程序员，makefile还是要懂。这就好像现在有这么多的HTML的编辑器，但如果你想成为一个专业人士，你还是要了解HTML的标识的含义。特别在Unix下的软件编译，你就不能不自己写makefile了，会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。</font></p><p><font face="Courier New">因为，makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。</font></p><p><font face="Courier New">makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。</font></p><p><font face="Courier New">现在讲述如何写makefile的文章比较少，这是我想写这篇文章的原因。当然，不同产商的make各不相同，也有不同的语法，但其本质都是在“文件依赖性”上做文章，这里，我仅对GNU的make进行讲述，我的环境是RedHat Linux 8.0，make的版本是3.80。必竟，这个make是应用最为广泛的，也是用得最多的。而且其还是最遵循于IEEE 1003.2-1992 标准的（POSIX.2）。</font></p><p><font face="Courier New">在这篇文档中，将以C/C++的源码作为我们基础，所以必然涉及一些关于C/C++的编译的知识，相关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是UNIX下的GCC和CC。</font></p><p><font face="Courier New"></font> </p><p><font face="Courier New"><strong>关于程序的编译和链接<br/>——————————</strong></font></p><p><font face="Courier New">在此，我想多说关于程序编译的一些规范和方法，一般来说，无论是C、C++、还是pas，首先要把源文件编译成中间代码文件，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。</font></p><p><font face="Courier New">编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。</font></p><p><font face="Courier New">链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。</font></p><p><font face="Courier New">总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的Object File.</font></p><p><font face="Courier New">好，言归正传，GNU的make有许多的内容，闲言少叙，还是让我们开始吧。</font></p><p><font face="Courier New"></font> </p><p><font face="Courier New"><strong>Makefile 介绍<br/>———————</strong></font></p><p><font face="Courier New">make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。</font></p><p><font face="Courier New">首先，我们用一个示例来说明Makefile的书写规则。以便给大家一个感兴认识。这个示例来源于GNU的make使用手册，在这个示例中，我们的工程有8个C文件，和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：<br/>    1）如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。<br/>    2）如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。<br/>    3）如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。</font></p><p><font face="Courier New">只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。</font></p><p><br/><font face="Courier New"><strong>一、Makefile的规则</strong></font></p><p><font face="Courier New">在讲述这个Makefile之前，还是让我们先来粗略地看一看Makefile的规则。</font></p><p><font face="Courier New">    target ... : prerequisites ...<br/>            command<br/>            ...<br/>            ...</font></p><p><font face="Courier New">    target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。</font></p><p><font face="Courier New">    prerequisites就是，要生成那个target所需要的文件或是目标。</font></p><p><font face="Courier New">    command也就是make需要执行的命令。（任意的Shell命令）</font></p><p><font face="Courier New">这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。</font></p><p><font face="Courier New">说到底，Makefile的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是Makefile的主线和核心，但要写好一个Makefile还不够，我会以后面一点一点地结合我的工作经验给你慢慢到来。内容还多着呢。：）</font></p><p><br/><font face="Courier New"><strong>二、一个示例</strong></font></p><p><font face="Courier New">正如前面所说的，如果一个工程有3个头文件，和8个C文件，我们为了完成前面所述的那三个规则，我们的Makefile应该是下面的这个样子的。</font></p><p><font face="Courier New">    edit : main.o kbd.o command.o display.o /<br/>           insert.o search.o files.o utils.o<br/>            cc -o edit main.o kbd.o command.o display.o /<br/>                       insert.o search.o files.o utils.o</font></p><p><font face="Courier New">    main.o : main.c defs.h<br/>            cc -c main.c<br/>    kbd.o : kbd.c defs.h command.h<br/>            cc -c kbd.c<br/>    command.o : command.c defs.h command.h<br/>            cc -c command.c<br/>    display.o : display.c defs.h buffer.h<br/>            cc -c display.c<br/>    insert.o : insert.c defs.h buffer.h<br/>            cc -c insert.c<br/>    search.o : search.c defs.h buffer.h<br/>            cc -c search.c<br/>    files.o : files.c defs.h buffer.h command.h<br/>            cc -c files.c<br/>    utils.o : utils.c defs.h<br/>            cc -c utils.c<br/>    clean :<br/>            rm edit main.o kbd.o command.o display.o /<br/>               insert.o search.o files.o utils.o</font></p><p><font face="Courier New">反斜杠（/）是换行符的意思。这样比较便于Makefile的易读。我们可以把这个内容保存在文件为“Makefile”或“makefile”的文件中，然后在该目录下直接输入命令“make”就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下“make clean”就可以了。</font></p><p><font face="Courier New">在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（*.o），依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。</font></p><p><font face="Courier New">在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个Tab键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。</font></p><p><font face="Courier New">这里要说明一点的是，clean不是一个文件，它只不过是一个动作名字，有点像C语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</font></p><font face="Courier New"></font><p align="right"><a href="http://www.csdn.net/develop/read_article.asp?id=20026"><font color="#0000ff"><strong>下一页</strong></font></a><strong>-&gt;</strong></p><p align="left"><font face="MS Sans Serif"><strong>（版权所有，转载时请注明作者和出处）</strong></font> </p><p><font face="Courier New"></font> </p>                </div>                    </div>
2891	 跟我一起写Makefile（六）	makefile  shell  yacc  unix  path  工作  	1077612660	46144	haoel	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p><font face="Courier New" size="4"><strong>书写命令<br/>————</strong></font></p><p><font face="Courier New">每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以[Tab]键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。</font></p><p><font face="Courier New">我们在UNIX下可能会使用不同的Shell，但是make的命令默认是被“/bin/sh”——UNIX的标准Shell解释执行的。除非你特别指定一个其它的Shell。Makefile中，“#”是注释符，很像C/C++中的“//”，其后的本行字符都被注释。</font></p><p><font face="Courier New"><strong>一、显示命令</strong></font></p><p><font face="Courier New">通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“@”字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如：</font></p><p><font face="Courier New">    @echo 正在编译XXX模块......</font></p><p><font face="Courier New">当make执行时，会输出“正在编译XXX模块......”字串，但不会输出命令，如果没有“@”，那么，make将输出：</font></p><p><font face="Courier New">    echo 正在编译XXX模块......<br/>    正在编译XXX模块......</font></p><p><font face="Courier New">如果make执行时，带入make参数“-n”或“--just-print”，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。</font></p><p><font face="Courier New">而make参数“-s”或“--slient”则是全面禁止命令的显示。</font></p><p><font face="Courier New"></font> </p><p><font face="Courier New"><strong>二、命令执行</strong></font></p><p><font face="Courier New">当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：</font></p><p><font face="Courier New">    示例一：<br/>        exec:<br/>                cd /home/hchen<br/>                pwd</font></p><p><font face="Courier New">    示例二：<br/>        exec:<br/>                cd /home/hchen; pwd</font></p><p><font face="Courier New">当我们执行“make exec”时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。</font></p><p><font face="Courier New">make一般是使用环境变量SHELL中所定义的系统Shell来执行命令，默认情况下使用UNIX的标准Shell——/bin/sh来执行命令。但在MS-DOS下有点特殊，因为MS-DOS下没有SHELL环境变量，当然你也可以指定。如果你指定了UNIX风格的目录形式，首先，make会在SHELL所指定的路径中找寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在PATH环境变量中所定义的所有路径中寻找。MS-DOS中，如果你定义的命令解释器没有找到，其会给你的命令解释器加上诸如“.exe”、“.com”、“.bat”、“.sh”等后缀。</font></p><p><br/><br/><font face="Courier New"><strong>三、命令出错</strong></font></p><p><font face="Courier New">每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。</font></p><p><font face="Courier New">有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。</font></p><p><font face="Courier New">为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的。如：</font></p><p><font face="Courier New">   clean:<br/>            -rm -f *.o</font></p><p><font face="Courier New">还有一个全局的办法是，给make加上“-i”或是“--ignore-errors”参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。</font></p><p><font face="Courier New">还有一个要提一下的make的参数的是“-k”或是“--keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。</font></p><p><br/><br/><font face="Courier New"><strong>四、嵌套执行make</strong></font></p><p><font face="Courier New">在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。</font></p><p><font face="Courier New">例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：</font></p><p><font face="Courier New">    subsystem:<br/>            cd subdir &amp;&amp; $(MAKE)</font></p><p><font face="Courier New">其等价于：</font></p><p><font face="Courier New">    subsystem:<br/>            $(MAKE) -C subdir</font></p><p><font face="Courier New">定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。</font></p><p><font face="Courier New">我们把这个Makefile叫做“总控Makefile”，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了“-e”参数。</font></p><p><font face="Courier New">如果你要传递变量到下级Makefile中，那么你可以使用这样的声明：</font></p><p><font face="Courier New">    export &lt;variable ...&gt;</font></p><p><font face="Courier New">如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明： </font></p><p><font face="Courier New">    unexport &lt;variable ...&gt;</font></p><p><font face="Courier New">如：<br/>    <br/>    示例一：</font></p><p><font face="Courier New">        export variable = value</font></p><p><font face="Courier New">        其等价于：</font></p><p><font face="Courier New">        variable = value<br/>        export variable</font></p><p><font face="Courier New">        其等价于：</font></p><p><font face="Courier New">        export variable := value</font></p><p><font face="Courier New">        其等价于：</font></p><p><font face="Courier New">        variable := value<br/>        export variable</font></p><p><font face="Courier New">    示例二：</font></p><p><font face="Courier New">        export variable += value</font></p><p><font face="Courier New">        其等价于：</font></p><p><font face="Courier New">        variable += value<br/>        export variable</font></p><p><font face="Courier New">如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。</font></p><p><font face="Courier New">需要注意的是，有两个变量，一个是SHELL，一个是MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层Makefile中，特别是MAKEFILES变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层Makefile中定义了这个变量，那么MAKEFILES变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。</font></p><p><font face="Courier New">但是make命令中的有几个参数并不往下传递，它们是“-C”,“-f”,“-h”“-o”和“-W”（有关Makefile参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来：</font></p><p><font face="Courier New">    subsystem:<br/>            cd subdir &amp;&amp; $(MAKE) MAKEFLAGS=</font></p><p><font face="Courier New">如果你定义了环境变量MAKEFLAGS，那么你得确信其中的选项是大家都会用到的，如果其中有“-t”,“-n”,和“-q”参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。</font></p><p><font face="Courier New">还有一个在“嵌套执行”中比较有用的参数，“-w”或是“--print-directory”会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是“/home/hchen/gnu/make”，如果我们使用“make -w”来执行，那么当进入该目录时，我们会看到：</font></p><p><font face="Courier New">    make: Entering directory `/home/hchen/gnu/make'.</font></p><p><font face="Courier New">而在完成下层make后离开目录时，我们会看到：</font></p><p><font face="Courier New">    make: Leaving directory `/home/hchen/gnu/make'</font></p><p><font face="Courier New">当你使用“-C”参数来指定make下层Makefile时，“-w”会被自动打开的。如果参数中有“-s”（“--slient”）或是“--no-print-directory”，那么，“-w”总是失效的。</font></p><p><br/><br/><font face="Courier New"><strong>五、定义命令包</strong></font></p><p><font face="Courier New">如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束，如：</font></p><p><font face="Courier New">    define run-yacc<br/>    yacc $(firstword $^)<br/>    mv y.tab.c $@<br/>    endef</font></p><p><font face="Courier New">这里，“run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名。在“define”和“endef”中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。</font></p><p><font face="Courier New">    foo.c : foo.y<br/>            $(run-yacc)</font></p><p><font face="Courier New">我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包“run-yacc”中的“$^”就是“foo.y”，“$@”就是“foo.c”（有关这种以“$”开头的特殊变量，我们会在后面介绍），make在执行命令包时，命令包中的每个命令会被依次独立执行。</font></p><p align="right"><strong><font face="Courier New">&lt;-</font></strong><a href="http://www.csdn.net/Develop/read_article.asp?id=20272"><font color="#0000ff" face="Courier New"><strong>上一页</strong></font></a><strong><font face="Courier New">  <a href="http://www.csdn.net/develop/read_article.asp?id=20438"><font color="#0000ff">下一页</font></a>-&gt;</font></strong></p><p><strong><font face="Courier New">（版权所有，转载时请注明作者和出处）</font></strong></p><p><br/><!--内容结束//--></p>                </div>                    </div>
3000	 Lotus Domino/Notes Toolkits综述(六) 其他	lotus  数据库  xml  c++  文档  windows  	1067698200	1526	oldcrane	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <h3>6 NotesSQL</h3>    NotesSQL是Notes数据库的ODBC驱动，符合ODBC 2.0规范。 <br/>    在功能上，NotesSQL和LDDJ比较相似，用于以关系数据库的方式存取Notes数据库中的数据，并利用Domino/Notes软件来实现网络传输和安全方面的特性。 <br/>    除了上一章（LDDJ）描述的特性之外，NotesSQL还提供了一个名为Authentication List Manager的工具，可用来指定只有哪些用户可以通过NotesSQL连接Notes数据库（本地或远程），进一步加强安全性。 <br/>    另外，NotesSQL还支持数据库连接可以为多个用户复用，而且对每个用户都可以实现各自的存取权限对数据访问的控制。 <br/>    NotesSQL支持从4.6.4到R6各个版本的Notes数据库，最新的版本是3.02b，发布于2003.02.06。 <br/>    NotesSQL先后经历了多个版本，软件比较稳定。但只限于Windows平台，使用ODBC技术，效率不高。 <br/><br/><br/><h3>7 Lotus XML Toolkit（DXL）</h3>    Domino对数据存储结构和显示方式的处理方法和XML有很多相似之处，因此，有人称Domino对XML提供天然的支持。在Domino/Notes R6中，软件提供了有关以XML方式处理Domino数据的类。 <br/>    除此之外，Lotus还提供单独的工具包，即Lotus XML Toolkit，来以XML的方式存取Domino数据，包括文档、RTF域和一些设计元素： <ul><li>数据库属性和ACL </li><li>文档 </li><li>RTF域<br/>按钮、计算文本、附件、内嵌图片、连接、段落和边距设置、区段、表格、文本及其显示格式等 </li><li>设计元素<br/>表单、子表单、视图、文件夹、共享域、共享操作、图像资源、帮助文档 </li></ul><b>支持的平台和开发工具</b> <br/>    DXL只支持Windows平台。 <br/>    DXL提供了Java和C++的API。For C++的应用开发需要MS Visual C++ 6.0，for Java的需要jdk 1.1.8以上版本支持。 <br/><br/><b>最新版本</b> <br/>   v1.0，发布于2001.03.27 <br/><br/><b>使用场景</b> <br/>    DXL应用的开发和应用需要安装Domino/Notes 5.0+，利用ID文件来标识用户，使用Domino/Notes的安全特性，使用当前用户的存取控制权限来判断对数据和设计元素的存取权限。 <br/>    利用DXL，可以把上述数据和对象以XML格式输入，保存为xml文件，或者作为字节流直接进行处理，例如使用XSL技术来格式化数据的表现方式，使用XSLT来重新组织数据，以便和其他系统或数据进行交互等。 <br/>   利用DXL，也可以将格式化好的数据导入到Domino/Notes数据库中，DXL能自动根据导入的数据和数据库中已有的数据，进行新增、修改、删除工作。 <br/>    在导入设计元素要特别注意，所有被导入的设计元素，在数据库中都是没有被签名的。在某些情况下会带来问题，需要用其他工具来完成对设计元素的签名操作。 <br/>    DXL所处理的xml数据格式，其描述请参考Domino DTD，在DXL的文档中有详细的描述。可以使用URL命令http://servername/dbpath/viewname?ReadViewEntries查看输出的XML数据样例。 <br/><h3><br/>8 其他</h3><h4>8.1 Custom Tag Converion kit （DCT）</h4>    Domino R6提供了一套自有的JSP标记，开发人员可以使用这些标记来开发JSP页面，灵活定义Notes数据的显示格式。相应地，DCT可以将Notes数据库中已有的视图和表单，转换成用JSP文件。转换后效果将模拟在Notes客户端中视图和表单的显示格式。 <br/>    这个工具只支持Windows平台，需要Domno R6支持。 <br/>    目前DCT仍属于IBM Alpha项目，尚未正式发布。 <br/><br/><br/><h4>8.2 Lotus Toolkit for COM</h4>    用来开发使用COM技术存取Domino对象的应用。详细信息请看工具包自带的文档。 <br/>    最新版本是 v1.0，for Domino/Notes 5.0.7，发布于2002.12.12。 <br/><br/><br/><h4>8.3 LotusScript Extensions toolkit（LSX）</h4>    LSX是在Lotus C++ API基础上开发出来的，用来扩展LotusScript的功能： <ul><li>使得Notes应用可以和Lotus家族其他产品，例如Lotus 1-2-3，进行交互 </li><li>使Notes应用可以与其他已有应用系统进行交互 </li><li>使Notes应用可以和操作系统进行某些交互 </li></ul>    LSX被编译成为动态链接库（在非windows平台上为其他类型的共享程序库），LotusScript可以在Notes中调用。 <br/>    详细信息请参见LSX的文档。 <br/>    最新版本为v3.1，发布于2001.03.27。<br/><br/><br/><a href="http://www.csdn.net/Develop/Read_Article.asp?Id=20419">Lotus Domino/Notes Toolkits综述(一)</a><br/><a href="http://www.csdn.net/Develop/Read_Article.asp?Id=20420">Lotus Domino/Notes Toolkits综述(二) C API</a><br/><a href="http://www.csdn.net/Develop/Read_Article.asp?Id=20422">Lotus Domino/Notes Toolkits综述(三) C++ API</a><br/><a href="http://www.csdn.net/Develop/Read_Article.asp?Id=20424">Lotus Domino/Notes Toolkits综述(四) Java</a><br/><a href="http://www.csdn.net/Develop/Read_Article.asp?Id=20425">Lotus Domino/Notes Toolkits综述(五) LDDJ</a><br/><a href="http://www.csdn.net/Develop/Read_Article.asp?Id=20426">Lotus Domino/Notes Toolkits综述(六) 其他</a><br/><a href="http://www.csdn.net/Develop/Read_Article.asp?Id=20428">Lotus Domino/Notes Toolkits综述(七) 分析比较</a><br/><a href="http://www.csdn.net/Develop/Read_Article.asp?Id=20432">Lotus Domino/Notes Toolkits综述(八) 分析比较 续</a><br/><a href="http://www.csdn.net/Develop/Read_Article.asp?Id=20433">Lotus Domino/Notes Toolkits综述(九) 小结</a><br/>                </div>                    </div>
3072	 未来游戏发展趋向	游戏  制造  	964777440	1591	ghj1976	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <hr/><p><font color="#800080" face="宋体"><span style="font-family:'宋体';">     <a href="http://www.gamecenter.com">Game Center</a>，是与<a href="http://www.pcgamer.com">PC Gamer</a>，<a href="http://cgw.gamespot.com">CGW</a>等齐名的游戏站点，隶属于<a href="http://www.cent.com">CNET</a>（著名的<a href="http://www.news.com">www.news.com</a>站点也在CNET旗下）。这个站点的主编——乔治·琼斯在E3大展之后，对游戏今后的发展进行了预测</span></font></p><p>　　年度业界最大的盛会E3结束了，我在会后总是对未来12到16个月的游戏发展有个思考，思路从模糊到清晰，加上来自各方面，主要是玩友们的信息反馈，我得以指出未来一年左右时间游戏业发展的三个主要趋势。</p><p><font color="#FF0000">　　1.游戏将更注重单人游戏的故事情节，大大提高单人游戏的趣味性： </font></p><p>　　从1997和1998年E3参展游戏来看，去年每个单人游戏几乎都强调了多人游戏功能，似乎单人游戏成了辅助，这未免使游戏走上了歧途。值得庆幸的是今年E3展出的游戏多数已经扭转了这种势头，游戏开发商们已经重新注重了单人游戏的功能，这才是游戏的生存之源，甚至连在故事情节方面总是欠缺的动作类游戏今次都大有进步，淡化了血腥与暴力，强化了美工，趣味性，渲染了故事情节，提高了复杂的工人智能。这对广大玩友来说是一件好事，人们不用再面对无聊的单人游戏历程。还记得Doom吗？首先是有趣的单人游戏之旅，然后才是激烈的多人对战模式。今天，设计人员不得不全力制作良好的单人游戏环境而不是喧宾夺主的制作多人游戏功能。 </p><p><font color="#FF0000">　　2.第三人称视角动作/冒险游戏人气冲天。 </font></p><p>　　由古墓丽影Ⅱ带来的巨大影响使在该模式上开发出的游戏为数不少，古墓丽影Ⅱ在市场上取得的巨大成功激励了那些游戏制造商们，这次E3大展上该类型游戏占了很大的份额，这使人想起数年前Doom类游戏层出不穷的局面，如今类似的局面又出现了，希望商家不要一味模仿，要记住创意、新意才是永远的生存之道。 </p><p><font color="#FF0000">　　3.运动类游戏——永远的乐土 </font></p><p>　　近几年，运动类游戏几乎是EA的王国，但其它游戏公司总是不失时机的推出一些同类游戏想在EA外争一席之地。今年E3大展上又涌现出众多的运动游戏同EA分一杯羹，有FoxSportsInteraetive、ESPN Gmaes和Siella Sports，运动类游戏如今在仿真度上大为提高，同时对硬件要求也越来越高，主要在3D加速方面。运动类游戏在足球、蓝球、棒球等方面做得非常成功，由于运动类游戏是老少皆宜的游戏，所以市场前景广阔。 </p>                </div>                    </div>
3087	 用PHP实现文件上传	php  file  input  服务器  javascript  action  	966860100	1359	ghj1976	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        用PHP实现文件上传 <br/>作者 Yahav Boaz 译者 limodou<br/><br/>　　在WebDev站点上经常看到的一个问题是关于文件上传的。在这篇文章里我将解释如何用PHP实现文件<br/>上传。<br/><br/>设计上传表格 <br/><br/>　　我们主要的目标是完成文件从本地计算机上传到服务器上去。为了做到这一点，我们需要做一个表<br/>格，允许用户选择一个文件并可以提交它。下面是一个例子： <br/><br/>&lt;HTML&gt; <br/>&lt;HEAD&gt; <br/>&lt;TITLE&gt;文件上传表格&lt;/TITLE&gt; <br/>&lt;/HEAD&gt; <br/>&lt;BODY&gt; <br/>&lt;TABLE&gt; <br/>&lt;FORM ENCTYPE="multipart/form-data" NAME=MyForm <br/>ACTION=submit.php3 <br/>METHOD="POST"&gt; <br/>&lt;TR&gt;&lt;TD&gt;选择上传文件&lt;/TD&gt;&lt;TD&gt;&lt;INPUT NAME="MyFile" <br/>TYPE="File"&gt;&lt;/TD&gt;&lt;/TR&gt; <br/>&lt;TR&gt;&lt;TD COLSPAN="2"&gt;&lt;INPUT NAME="submit" VALUE="上传" <br/>TYPE="submit"&gt;&lt;/TD&gt;&lt;/TR&gt; <br/>&lt;/TABLE&gt; <br/>&lt;/BODY&gt; <br/>&lt;/HTML&gt; <br/><br/><br/>　　注意表格中的ENCTYPE="multipart/form-data"部分。这个一定不能错，否则服务器将不知道你在上<br/>传文件。 <br/><br/>设计上传程序<br/><br/>　　现在我们已经完成了前台部分，让我们再仔细地考虑后台是如何接收文件并保存它到我们指定的目<br/>录下去。下面就开始用PHP了。这是submit.php3的程序： <br/><br/>&lt;? <br/>If($MyFile != "none") { <br/>copy($MyFile,"/home/berber/$MyFile_name"); <br/>unlink($MyFile); <br/>} <br/>else { <br/>echo"你没有上传任何文件"; <br/>} <br/>?&gt; <br/><br/><br/>　　不管你信不信，这就是整个处理过程。我们在程序中所做的就是： <br/><br/>　　1. 检查是否一个文件已经上传到服务器，通过If($MyFile != "none");<br/>　　2. 拷贝文件到指定位置。<br/>　　3. 删除临时文件。<br/><br/>　　当你按下了提交按钮后，文件将会从你的计算机上传到服务器的临时目录下。在临时目录下的文件<br/>名为一个临时文件。应该使用file字段的name值来访问它，在这里为$MyFile。真正的文件名使用file<br/>字段的name值加上"_name"来访问它，在这里为$MyFile_name。使用copy()函数，将临时文件$MyFile拷<br/>贝到指定目录下，拷贝后的文件名为$MyFile_name。完成后不要忘了删除临时文件，不然你会有许多你<br/>不想要的文件。 <br/><br/>设置文件名<br/><br/>　　一个可能让程序员睡不着觉的事情就是试图改变file字段的VALUE属性的值。并不是很多人知道它<br/>是不可能的。尽管W3C说可以，但实际上，象IE和Netscape都不允许设置VAUE属性的值。听上去有点可<br/>笑，为什么我不能设置一个初始值，这样让用户使用起来更方便呢？如果你那样做，那你就会发现你带<br/>来了一个安全上的漏洞。可以设想一下，你登录到我的网站，我可以改变一个表格中的file字段的值。<br/>那么有许能阻止我把你的/etc/passwd文件上传呢？更进一步的，我不需要你按下提交按钮，我可先设<br/>置file字段的值，然后通过一段JavaScript程序来模拟提交动作...哇呜...我可以处理你机器上的任何<br/>文件了。因为这个原因，浏览器简单地把&lt;INPUT&gt;标记中的file字段的VALUE字段给忽略了。 <br/><br/>限制文件大小<br/><br/>　　另一个酷的特性是限制上传文件的大小选项。只要增加一个&lt;INPUT&gt;标记就可以了：<br/><br/>&lt;INPUT TYPE="hidden" name="MAX_FILE_SIZE" value="100000"&gt; <br/><br/>　　这个将不允许用户上传超过100KB的文件。<br/><br/>显示文件大小<br/><br/>　　为了显示文件大小，可以通过file字段name属性值加上"_size"这个变量来访问。在我们的例子中<br/>就是使用$MyFile_size。所以，如果你想告诉用户上传文件的大小，你可以象下面那样去做： <br/><br/>echo "You have just uploaded $MyFile_name"; <br/>echo "The size of the file is $MyFile_size"; <br/><br/>权限<br/><br/>　　很明显你需要对目标目录的写的权限。如果一个用户用匿文上传文件，那他的用户名应该是<br/>"bobody"。这个用户必须有对目标目录写的权限否则你可能得到一个象下面的信息： <br/><br/>Warning: Unable to create '/home/berber/berber.txt': <br/>Permission denied <br/>in /home/berber/submit.php3 on line 5 <br/><br/>                </div>                    </div>
3288	 <<AI入门(3)>>(C)	c  算法  search  扩展  工作  	978050520	1210	ghj1976	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        盲目搜索的效率很低,耗费很多时间和空间,如果我们能找出一种用于从排,及选择最有希望的节点.我们称这种搜索为"启发式搜索"或"信息搜索".进行这种搜索需要有关的信息,这信息称为启发信息,它可以分为3种: 1.用于决定哪个为最有希望的节点,以免盲目的搜索 2.决定从排的顺序. 3.决定那些节点应从搜索树中丢弃.我们下面就讲一讲第一种,也就是判断哪个为最有希望的节点:有序搜索:又称为有最好优先搜索(best-first search).尼尔逊(Nilsson)提出了一个有序搜索的基本算法:估价函数f是这样决定的:一个节点的希望越大,其f值越小.算法如下: 1.把起始节点S放入OPEN表中,计算f(S),把值和S节点连结 2.如果OPEN为空表,则无解,退出. 3.在OPEN表中选择一个f值最小的节点,如果有多个节点满足要求,当其中有目标节点时,选择目标节点,否则随便选择一个,作为i 4.把i从OPEN表中移去,加入CLOSED表中. 5.如果i是目标,则成功退出,有一个解  6.扩展节点i,生成全部后续节点,对于每个后续节点j: a..计算f(j). b..如果j不在OPEN表和CLOSED表中,则加入OPEN表,并产生一个指向i的指针,以便求解答路径. c..如果j以在OPEN表或CLOSED表.则比较刚计算的f(j)值和以前的值,如果新值小:以新值取代旧值,从j指向i,如果在CLOSED表中则把其从CLOSED表中移回OPEN表. 7.转向2.有一个好的估价函数能使它工作的更好!求最短路径的例子是A*算法.下面我们用8数码难题来做说明:我们取估价函数为:f(n)=d(n)+w(n) //d(n)是n的深度,w(n)是放错了的棋子的个数.假设起始节点如下:         目标节点:       2    8    3                 1    2    3       1    6    4                 8         4       7         5                 7    6    5第一步有三中情况,我们选择其中f(n)最小的:       2    8    3       1         4       7    6    5其它依次类推.最后用了6步得出了结果.我们下一节讲一讲A*算法                </div>                    </div>
3289	 <<AI入门(4)>>(C)	c  算法  .net  扩展  	978050520	1292	ghj1976	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        我们讲一讲A*算法:我们描述一个特别的估价函数f(n),它能估算出从起始节点到n最小代价路径的代价和节点n到一目标节点的最小代价路径的代价总和.我们在介绍A*算法之前先介绍一些有用的记号:k(n,m)表示从节点n到m的之间的最小代价路径的代价,m和n必须是连通的. h*(n)表示n到整个目标节点集合的所有最小代价路径中最小的一个,也就是说h*(n)是n到目标节点的最小代价.我们定义g*(n)=k(S,n)表示从开始到节点n的最小代价的路径的代价.设f*(n)=g*(n)+h*(n)表示从开始节点通过节点n到目标节点的最小代价路径的代价.我们的估价函数f(n)=g(n)+h(n)是f*(n)的一个估计.其中h是h*的估计,g是g*的估计.h有赖于启发的信息,我们称h为启发函数.下面我们就来讲讲A*算法: 1.把S放入OPEN表中,记f=h,令CLOSED为空表. 2.若OPEN表为空,失败退出. 3.在OPEN表中选取有最小f值的节点为best,并将它放入CLOSED表. 4.若best节点是目标节点,则成功退出. 5.best节点不是目标节点,则把best节点扩展,产生后续节点children. 6.对于每个children进行如下的操作: a..建立值相父节点的指针 b..计算g(children)=g(best)+g(best,children) c..如果children在OPEN表中,比较新旧路径,如果小于就把原来节点的父节点改为best并用新的代价取代原来的代价. d..如果节点在CLOSED表中,转向c e..如果节点即不在OPEN表中也不在CLOSED表中,则加入表OPEN中. 7.计算f值 8.GOTO 2我们没有详细讨论A*算法的性质,有问题欢迎来信<a href="mailto:sevecol@163.net">sevecol@163.net</a>                </div>                    </div>
3290	 <<AI入门(5)>>(C)	c  	978050580	1129	ghj1976	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        AI(5)不知你学过离散数学没有,如果学过下面的可以跳过,没学过的最好找一本书学学.我们来看看知识表示法的另一种表示方法:谓词逻辑法谓词逻辑的基本组成部分为:谓词符号,变量符号,函数符号和常量符号,例如要表示机器人(ROBOT)在房间(ROOM)里,我们可以用简单的原子公式:INROOM(ROBOT,ROOM)其中ROBOT和ROOM为常量符号,INROOM为谓词符号,可以当成是一个函数,一个映射.它有一个确定的值.要么是真,要么是假.下面来讲讲连词和量词:连词: // 表示与,当连接的两个原子公式都是真时,公式为真 // 表示或,当连接的两个原子公式都是假时,公式为假 =&gt; 表示蕴涵,例如A=&gt;B只有当A为真,B为假时,公式为假 ~  表是否定,例如~A,A为真时,公式为假,A为假时,公式为真量词: /-/ (没法表示:-),将就一下) 表示每个,例如(/-/x)表示每个x满足... 倒着的E 表示存在,例如 (倒着的E x)表示存在x满足...谓词公式:合式公式的递归定义如下: 1.原子谓词公式是合式公式 2.若A是合式公式,则~A是合式公式 3.若A和B都是合式公式,则(A//B),(A//B),(A=&gt;B)和(A/=/B)是合式公式(其中/=/是&lt;- )(          -&gt;) 4.若A是合式公式,则(/-/A)和(倒着的E x)也是合式公式. 5.按上面的方法有限次组合的为合式公式.                 </div>                    </div>
3291	 <<AI入门(6)>>(C)	c  网络  	978050580	1163	ghj1976	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        置换和合一:置换:在谓词逻辑中一个重要的规则是假元推理,它是由合式公式W1和W1=&gt;W2产生合式公式W2,另一个重要的规是则全称化推理:它是由合式公式(/-/x)W(x)产生合式公式W(A).例一: 表达式P[x,f(y),B]的4个置换是:s1={z/x,w/y}s2={C/y}s3={q(z)/x,A/y}s4={c/x,A/y}可以得到:P[x,f(y),B]s1=P[z,f(w),B]P[x,f(y),B]s2=P[x,f(C),B]P[x,f(y),B]s3=P[q(z),f(A),B]P[x,f(y),B]s4=P[c,f(A),B]置换是可以结合的: 用s1 s2表示两个置换,L表示一表达式,则有:(Ls1)s2=L(s1s2)和(s1s2)s3=s1(s2s3)一般来说置换是不可以交换的,即s1s2不等于s2s1合一:寻找项对变量的置换,以使两表达式一致,叫做合一,合一是人工智能中重要的过程.如果置换s作用于{E}的每个元素,用{E}s来表示置换例的集我们来看个例子:表达式集{P[x,f(y),B],P[x,f(B),B]}的合一者为s={A/x,B/y}对于上面的例子,尽管s是表达式集的一个合一者,但不是最简单的合一者,最简单的合一者是:g={B/y}下回和大家讲讲另一种知识表示方法:语义网络法.                </div>                    </div>
3293	 <<AI入门(10)>>(C)	c  活动  	978050700	1166	ghj1976	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        我们来讲讲高级求解技术:1.规则演绎系统:我们用if-then规则来求解问题: IF   if1      if2      if3      ... THEN  then1       then2       then3       ...如果then后面是新断言,那么称为规则演绎系统,如果then后面是用于规定动作我们称为反应式系统.我们说说规则演绎系统,通常我们把规则演绎系统中每个if为前项,每个then为后项.从前项向后项推理的过程叫做正向推理,反之叫做逆向推理.正向推理是从事实或状况向目标活动作进行操作.我们通常把事实表示为非蕴含形式的与或形.例如:对于事实表达式:(倒E u)(/-/ v){Q(v,u)//~[(R(v)//P(v)))//S(u,v)]} 可化成:Q(v,A)//{[~R(v)//~P(v)]//~S(v,A)}先举个简单的推理的例子:事实：A//B规则: A=&gt;C//D , B=&gt;E//G目标: C//G把规则化成子句形得: ~A//C,~A//D ~B//E,~B//G目标的否定的子句形为: ~C,~G我们用消解反演来证明目标公式:                       ~A//C    ~C         ~G   ~B//G                           /    /            /   /                            /  /              / /                     A//B    ~A                ~B                         /    /                 /                         /  /                 /                           B                  /                           / ----------------                           NIL我们推出了一个空子句,目标得到证明.                </div>                    </div>
3325	 用VC++实现异形窗口.	vc++  windows  microsoft  initialization  border  c++  	980059200	2133	ghj1976	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <b><font face="宋体" lang="zh-cn" size="5" xml:lang="zh-cn"> </font></b><p align="center"><b>用</b></p><b><font size="5">VC++</font><font face="宋体" lang="zh-cn" size="5" xml:lang="zh-cn">实现异形窗口</font><font size="5">.</font></b><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"></font><p align="center"></p><p align="center">大连铁道学院（</p><font size="3">116028</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">）李文辉</font><p align="center"></p><p align="justify">随着</p><font size="3">Microsoft</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">凭借</font><font size="3">Windows</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">在操作系统上取得的巨大成绩，</font><font size="3">Windows</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">用户界面也日益成为业界标准。统一的界面给广大用户对应用软件的学习与使用带来了很大方便。但每天都面对同一副面孔，日久天长难免会产生一些厌倦，开发一些“离经叛道”，一改</font><font size="3">Windows</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">应用程序千篇一律的“标准”界面，一定会给你带来一种清新的感觉。</font><p align="justify">标准</p><font size="3">Windows</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">应用程序窗口一般为带有标题栏的浅灰色矩形外观，因而“异形”对话框</font><font size="3">/</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">窗口也主要是颜色与外形上动手脚。</font><p align="justify"></p><p align="justify"></p>改变背景颜色 <p></p><p align="justify">改变对话框（窗口）的背景颜色是最简单的改变</p><font size="3">Windows</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">应用程序外观的方法，根据</font><font size="3">Windows</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">创建与管理机理，一般有两种方法。一种是处理</font><font size="3">WM_CTLCOLOR</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">消息，首先创建所选背景颜色的刷子，然后调用</font><font size="3">SetBkColor()</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">或</font><font size="3">SetDialogBkColor()</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">以所创建的刷子来绘制窗口或对话框的背景。需要重画窗口或对话（或对话的子控件）时，</font><font size="3">Windows</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">向对话发送消息</font><font size="3">WM_CTLCOLOR</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">，应用程序处理</font><font size="3">WM_CTLCOLOR</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">消息并返回一个用来绘画对话背景的刷子句柄。另外一种是响应</font><font size="3">Windows</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">的</font><font size="3">WM_ERASEBKGND</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">消息，</font><font size="3">Windows</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">向窗口发送一个</font><font size="3">WM_ERASEBKGND</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">消息通知该窗口擦除背景，可以使用</font><font size="3">VC++</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">的</font><font size="3">ClassWizard</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">重载该消息的缺省处理程序来擦除背景（实际是用刷子画），并返回</font><font size="3">TRUE</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">以防止</font><font size="3">Windows</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">擦除窗口。</font><p align="justify"></p><font size="3"></font><p align="justify">2</p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">．改变窗口外形</font><p align="justify">通过使用新的</p><font size="3">SDK</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">函数</font><font size="3">SetWindowRgn()</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">，可以将绘画和鼠标消息限定在窗口的一个指定的区域，因此实际上是使窗口成为指定的不规则形状（区域形状）。“区域”是</font><font size="3">Windows GDI</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">中一种强有力的机制，区域是设备上的一块空间，可以是任意形状，复杂的区域可以由各个小区域组合而成。</font><font size="3">Windows</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">内含的区域创建函数有</font><font size="3">CreateRectRgn()</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">、</font><font size="3">CreatePolyRgn()</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">、</font><font size="3">CreatePolygonRgn()</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">、</font><font size="3">CreateRoundRectRgn()</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">和</font><font size="3">CreateEllipticRgn()</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">，再通过</font><font size="3">CombineRgn()</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">来组合区域，即可得到复杂形状的区域，获得复杂形状的窗口外形。</font><p align="justify">通过上面的方法虽然可以得到“异形”窗口，但感觉颜色单调，外形也不够“</p><font size="3">COOL</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">”，能否获得更酷的“异形”对话框</font><font size="3">/</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">窗口呢？回答是肯定的。下面就介绍利用位图和蒙板创建“异形”对话框</font><font size="3">/</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">窗口的方法。</font><p align="justify"></p><font size="3"></font><p align="justify">3</p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">．利用位图创建异形对话框窗口</font><p align="justify">利用位图创建异形对话框原理是根据象素的颜色来进行“扣像”处理，对所有非指定颜色象素区域进行区域组合。利用这一技术，实际上就是实现对话框</p><font size="3">/</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">窗口的位图背景，并且对指定的颜色区域进行透明处理。下面就以透明位图为背景的对话框为例来说明：</font><p align="justify">首先用绘图软件如</p><font size="3">PhotoShop</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">绘制编辑一幅拟做对话框背景用的图片，用</font><font size="3">BMP</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">格式保存，假设存为</font><font size="3">Back.Bmp</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">。需要说明的是，虽然</font><font size="3">Visual C++</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">集成开发环境的资源编辑器只能编辑不超过</font><font size="3">16</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">色的位图，但完全我们可以以真彩色方式存储，不必理会</font><font size="3">Visual C++</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">的警告。</font><p align="justify">下一步是用</p><font size="3">Visual C++</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">的</font><font size="3">AppWizard</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">创建一个基于对话框的应用程序假定命名为</font><font size="3">Trans</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">。用资源编辑器引入背景图片</font><font size="3">Back.Bmp</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">，如果是高彩色，不必理会出现的警告信息，点击</font><font size="3">OK</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">确认即可。为了明确，修改默认的资源</font><font size="3">ID</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">标识</font><font size="3">IDB_BITMAP1</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">为</font><font size="3">IDB_BACKBMP</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">。然后修改对话框的</font><font size="3">Style</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">为</font><font size="3">Popup</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">，</font><font size="3">Border</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">为</font><font size="3">None</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">，如图</font><font size="3">1</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">。</font><p align="justify"></p><p align="justify"><img alt="Image90.jpg" height="173" src="http://www.vckbase.com/article/advancedui/Image90.jpg" width="489"/></p><p align="justify"></p><p align="center">图</p><font size="3">1</font><p align="center"></p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"></font><p align="justify">向</p><font size="3">CTransDlg</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">类添加区域处理功能模块</font><font size="3">void CTransDlg::SetupRegion(CDC *pDC /*</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">对话框窗口</font><font size="3">DC*/, UINT BackBitmapID /*</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">背景位图资源</font><font size="3">ID*/, UINT MaskBitmapID /*</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">区域处理位图资源</font><font size="3">ID*/, COLORREF TransColor = 0x00000000 /*</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">透明颜色值，默认为黑色</font><font size="3">*/)</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">。到目前为止，我们暂时认为</font><font size="3">MaskBitmapID</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">等同于</font><font size="3">BackBitmapID</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">。其核心工作是根据</font><font size="3">MaskBitmapID</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">指示位图的象素颜色进行区域组合。完整的代码如下：</font><font size="3"></font><p align="justify">void CTransDlg::SetupRegion(CDC *pDC /*</p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">对话框窗口</font><font size="3">DC*/, </font><p align="justify">UINT BackBitmapID /*</p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">背景位图资源</font><font size="3">ID*/,</font><p align="justify">UINT MaskBitmapID /*</p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">区域处理位图资源</font><font size="3">ID*/,</font><p align="justify">COLORREF TransColor /*</p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">透明颜色值</font><font size="3">*/)</font><p align="justify">{</p><p align="justify">CDC memDC;</p><p align="justify">CBitmap cBitmap;</p><p align="justify">CBitmap* pOldMemBmp = NULL;</p><p align="justify">COLORREF cl;</p><p align="justify">CRect cRect;</p><p align="justify">UINT x, y;</p><p align="justify">CRgn wndRgn, rgnTemp;</p><p align="justify"></p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"></font><p align="justify"></p><font size="3">//</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">取得窗口大小</font><font size="3"></font><p align="justify">GetWindowRect(&amp;cRect);</p><p align="justify"></p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"></font><p align="justify"></p><font size="3">//</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">背景位图资源</font><font size="3">ID</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"></font><p align="justify"></p><font size="3">m_BackBitmapID = BackBitmapID</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"></font><p align="justify"></p><font size="3">//</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">装载位图</font><font size="3"></font><p align="justify">cBitmap.LoadBitmap(MaskBitmapID);</p><p align="justify">memDC.CreateCompatibleDC(pDC);</p><p align="justify">pOldMemBmp = memDC.SelectObject(&amp;cBitmap);</p><p align="justify"></p><p align="justify">//</p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">首先创建默认的完整区域为完整的窗口区域</font><p align="justify"></p><font size="3">wndRgn.CreateRectRgn(0, 0, cRect.Width(), cRect.Height());</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"></font><p align="justify"></p><p align="justify"></p><font size="3">//</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">下面的两层循环为检查背景位图象素颜色，进行透明区域处理；</font><p align="justify"></p><font size="3">//</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">当象素颜色为指定的透明值时，即将该点从区域中剪裁掉。</font><p align="justify"></p><font size="3">//</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">其中用到的几个成员变量</font><font size="3">m_MaskLeftOff</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">、</font><font size="3">m_MaskTopOff</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">、</font><font size="3"></font><p align="justify">//m_MaskRightOff</p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">、</font><font size="3">m_MaskBottomOff</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">、</font><font size="3">m_FrameWidth</font><p align="justify">//</p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">和</font><font size="3">m_CaptionHeight</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">，其作用后面再作说明，此时可全部当作</font><font size="3">0</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">来处理。</font><font size="3"></font><p align="justify">for(x= m_FrameWidth+m_MaskLeftOff;</p><p align="justify">x&lt;=cRect.Width() - m_FrameWidth-m_MaskRightOff; x++){</p><p align="justify">for(y = m_CaptionHeight+m_MaskTopOff; </p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"><br/></font><font size="3">y&lt;=cRect.Height() - m_FrameWidth-m_MaskBottomOff; y++){</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"></font><p align="justify"></p><font size="3">//</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">取得坐标处象素的颜色值</font><font size="3"></font><p align="justify">cl = memDC.GetPixel(x - m_FrameWidth-m_MaskLeftOff,</p><p align="justify">y - m_CaptionHeight-m_MaskTopOff);</p><p align="justify">if(col == TransColor)</p><p align="justify">{</p><p align="justify">//</p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">象素颜色为指定的透明色，创建透明“微区域”</font><font size="3"></font><p align="justify">rgnTemp.CreateRectRgn(x, y, x+1, y+1);</p><p align="justify">//</p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">“扣像”，从完整的区域中“扣除”透明的“微区域”</font><font size="3"></font><p align="justify">wndRgn.CombineRgn(&amp;wndRgn, &amp;rgnTemp, RGN_XOR);</p><p align="justify">//</p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">删除刚创建的透明“微区域”，释放系统资源</font><font size="3"></font><p align="justify">rgnTemp.DeleteObject(); </p><p align="justify">}</p><p align="justify">}</p><p align="justify">}</p><p align="justify">if (pOldMemBmp) memDC.SelectObject(pOldMemBmp);</p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"></font><p align="justify"></p><p align="justify"></p><font size="3">//</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">用设定窗口为指定的区域</font><font size="3"></font><p align="justify">SetWindowRgn((HRGN)wndRgn, TRUE);</p><p align="justify">}</p><p align="justify"></p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"></font><p align="justify">重置系统默认的背景擦除操作，即添加</p><font size="3">WM_ERASEBKGND</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">消息处理过程，这一步可以借助</font><font size="3">ClassWizard</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">来简化操作。</font><font size="3"></font><p align="justify">BOOL CTransDlg::OnEraseBkgnd(CDC* pDC) </p><p align="justify">{</p><p align="justify">// TODO: Add your message handler code here and/or call default</p><p align="justify">CRect rect;</p><p align="justify">CDC memDC;</p><p align="justify">CBitmap cBitmap;</p><p align="justify">CBitmap* pOldMemBmp = NULL;</p><p align="justify"></p><p align="justify">GetWindowRect(&amp;rect);</p><p align="justify"></p><p align="justify">//</p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">装载背景位图</font><p align="justify"></p><font size="3">cBitmap.LoadBitmap(m_BackBitmapID);</font><p align="justify">memDC.CreateCompatibleDC(pDC);</p><p align="justify">pOldMemBmp = memDC.SelectObject(&amp;cBitmap);</p><p align="justify"></p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"></font><p align="justify"></p><font size="3">//</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">将背景位图复制到窗口客户区</font><p align="justify"></p><font size="3">pDC-&gt;BitBlt(0, 0, rect.Width(), rect.Height(), </font><p align="justify">&amp;memDC, 0, 0, SRCCOPY);</p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"></font><p align="justify"></p><p align="justify"></p><font size="3">if (pOldMemBmp) memDC.SelectObject( pOldMemBmp );</font><p align="justify"></p><p align="justify">//</p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">删除系统却省的</font><font size="3">OnEraseBkgnd</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">功能</font><p align="justify"></p><font size="3">//return CDialog::OnEraseBkgnd(pDC);</font><p align="justify">return TRUE;</p><p align="justify">}</p><p align="justify"></p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"></font><p align="justify">接下来是在</p><font size="3">WM_PAINT</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">的消息处理函数</font><font size="3">OnPaint()</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">中添加代码。由于当背景位图比较大时，进行区域处理比较耗时，所以只在启动时进行一次处理。一种方法是</font><font size="3">OnInitDialog()</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">处理，但这样会在从启动程序到窗口出现有相当的延迟，易引起程序尚未启动的误解。再一种方法就是在</font><font size="3">OnPaint()</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">处理，但为了避免重复处理，可以加上一个判断标志。以下是</font><font size="3">OnPaint()</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">的代码，正体为</font><font size="3">AppWizard</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">生成，粗体为自己添加内容。</font><p align="justify"></p><font size="3"></font><p align="justify">void CTransDlg::OnPaint() </p><p align="justify">{</p><p align="justify">if (IsIconic())</p><p align="justify">{</p><p align="justify"></p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">……</font><p align="justify">}</p><p align="justify"></p><font size="3">else</font><p align="justify">{</p><b><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"></font></b><p align="justify"><b></b></p><b><font size="3">if(m_nFirstRun){</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"> </font><font size="3">//</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">首次运行标志</font><font size="3"></font></b><p align="justify"><b>//</b></p><b><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">修改鼠标光标为等待方式</font></b><p align="justify"><b></b></p><b><font size="3">BeginWaitCursor();</font></b><p align="justify"><b>//</b></p><b><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">设置背景区域</font></b><p align="justify"><b></b></p><b><font size="3">SetupRegion(GetWindowDC(),</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"><br/></font><font size="3">IDB_BACKBMP, </font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"><br/></font><font size="3">IDB_BACKBMP,<br/>0x00FFFFFF /*</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">白色</font><font size="3">*/);</font></b><p align="justify"><b>//</b></p><b><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">恢复鼠标光标为正常模式</font></b><p align="justify"><b></b></p><b><font size="3">EndWaitCursor();</font></b><p align="justify"><b>m_nFirstRun = 0;</b></p><b></b><p align="justify"><b>}</b></p><b></b><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"></font><p align="justify"></p><font size="3">CDialog::OnPaint();</font><p align="justify">}</p><p align="justify">}</p><p align="justify"></p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"></font><p align="justify">剩下的工作就是根据背景位图的大小来设置对话框窗口的大小和位置，这可以在</p><font size="3">OnInitDialog()</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">中通过调用</font><font size="3">MoveWindow</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">（）来实现。再添加一些变量的声名和初始化，即可编译运行。图</font><font size="3">2</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">为运行结果示例：</font><p align="justify"></p><p align="center"><img alt="Image91.jpg" height="97" src="http://www.vckbase.com/article/advancedui/Image91.jpg" width="496"/></p><p align="center">图</p><font size="3">2</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"></font><p align="justify"></p><font size="3"></font><p align="justify">4</p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">．进一步的讨论</font><p align="justify">前面实现了单一模式的异形对话框，但有些情况下又需要不同的样式，如有标题栏、边框等，或者只作局部的处理，这就是前面两个成员变量</p><font size="3">m_FrameWidth</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">和</font><font size="3">m_CaptionHeight</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">作用，通过在</font><font size="3">OnInitDialog()</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">判断窗口样式，使</font><font size="3">m_FrameWidth</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">和</font><font size="3">m_CaptionHeight</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">取不同的值。这部分的代码为：</font><p align="justify"></p><font size="3"></font><p align="justify">BOOL CTransBmpDlg::OnInitDialog()</p><p align="justify">{</p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"></font><p align="justify">……</p><p align="justify"></p><font size="3">// TODO: Add extra initialization here</font><b><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"></font></b><p align="justify"><b></b></p><b><font size="3">m_nFirstRun = 1;</font></b><p align="justify"><b></b></p><b></b><p align="justify"><b>//</b></p><b><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">数据设置，窗口左上角坐标：</font><font size="3">m_Left=0</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">，</font><font size="3">m_Top=0</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"><br/></font><font size="3">//</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">背景位图宽高：</font><font size="3">m_Width=535</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">，</font><font size="3">m_Height=105</font></b><p align="justify"><b>SetSize(0, 0, 535, 105);</b></p><b></b><p align="justify"><b></b></p><b></b><p align="justify"><b>//</b></p><b><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">蒙板处理区域与窗口边框的距离</font></b><p align="justify"><b></b></p><b><font size="3"></font></b><p align="justify"><b>m_MaskLeftOff=m_MaskTopOff=m_MaskRightOff=m_MaskBottomOff=0;</b></p><b><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"></font></b><p align="justify"><b></b></p><b><font size="3"></font></b><p align="justify"><b>//</b></p><b><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">窗口边框与标题栏象素值</font></b><p align="justify"><b></b></p><b><font size="3">m_FrameWidth = m_CaptionHeight = 0;</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"></font></b><p align="justify"><b></b></p><b></b><p align="justify"><b></b></p><b><font size="3">//</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">取得窗口样式</font></b><p align="justify"><b></b></p><b><font size="3">LONG style = ::GetWindowLong(this-&gt;m_hWnd, GWL_STYLE);</font></b><p align="justify"><b></b></p><b></b><p align="justify"><b>//</b></p><b><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">如保留窗口风格样式，则根据不同的窗口边框类型<br/></font><font size="3">//</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">选取不同的</font><font size="3">m_FrameWidth</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">和</font><font size="3">m_CaptionHeight</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">值，<br/></font><font size="3">//</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">也可以根据处理位置的需要进行付值</font></b><p align="justify"><b></b></p><b><font size="3">if((style &amp; WS_BORDER) == WS_BORDER)</font></b><p align="justify"><b>m_FrameWidth = ::GetSystemMetrics(SM_CXBORDER);</b></p><b></b><p align="justify"><b>if((style &amp; WS_THICKFRAME) == WS_THICKFRAME)</b></p><b></b><p align="justify"><b>m_FrameWidth = ::GetSystemMetrics(SM_CXFIXEDFRAME);</b></p><b></b><p align="justify"><b>if((style &amp; DS_MODALFRAME) == DS_MODALFRAME)</b></p><b></b><p align="justify"><b>m_FrameWidth = ::GetSystemMetrics(SM_CXFIXEDFRAME);</b></p><b></b><p align="justify"><b>if((style &amp; WS_CAPTION) == WS_CAPTION){</b></p><b></b><p align="justify"><b>m_FrameWidth = ::GetSystemMetrics(SM_CXFIXEDFRAME);</b></p><b></b><p align="justify"><b>m_CaptionHeight = ::GetSystemMetrics(SM_CYSMCAPTION);</b></p><b></b><p align="justify"><b>}</b></p><b></b><p align="justify"><b></b></p><b></b><p align="justify"><b>m_CaptionHeight += m_FrameWidth * 2;</b></p><b></b><p align="justify"><b></b></p><b></b><p align="justify"><b>//</b></p><b><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">重置窗口的位置和大小</font></b><p align="justify"><b></b></p><b><font size="3">MoveWindow(m_Left, m_Top, </font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"><br/></font><font size="3">m_Width + m_FrameWidth * 2, </font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"><br/></font><font size="3">m_Height + m_CaptionHeight, TRUE);</font></b><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"></font><p align="justify">……</p><p align="justify"></p><p align="justify"></p><font size="3">return TRUE; // return TRUE unless you set the focus to a control</font><p align="justify">}</p><p align="justify"></p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"></font><p align="justify">另外，为进一步增加灵活性，使窗口样式不仅仅受背景位图颜色的控制。通过指定</p><font size="3">SetupRegion()</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">的</font><font size="3">MaskBitmapID </font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">为一个我们称之为“蒙板”的双色位图（多色彩也可以，但一般没有必要），即可实现需要的操作。图</font><font size="3">4</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">为在同一背景位图上，通过图</font><font size="3">3</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">的蒙板位图实现的效果，并且增加了对话框窗体的边框和标题栏属性。</font><p align="justify"></p><p align="center"><img alt="Image92.jpg" height="97" src="http://www.vckbase.com/article/advancedui/Image92.jpg" width="496"/></p><p align="center"></p><p align="center">图</p><font size="3">3</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"></font><p align="center"></p><p align="center"><img alt="Image93.gif" height="115" src="http://www.vckbase.com/article/advancedui/Image93.gif" width="499"/></p><p align="justify"></p><p align="center">图</p><font size="3">4</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn"></font><p align="justify">利用这种蒙板技术，可以创建出任意形状的窗口，而与背景位图无关。需要注意的是，对于对话框中的控件如按钮等，如处在或部分处在通明区域中，则通明区域中部分一并被剪裁掉，是否剪裁和剪裁位置与大小，利用蒙板可以很方便地进行控制。</p><p align="justify">需要特别指出的是，</p><font size="3">SetWindowRgn</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">（）所指定的区域是针对整个窗口的，而</font><font size="3">Bitblt</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">（）</font><font size="3">/ StretchBlt</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">（）的输出区域是针对于客户区，两者在定位上是不同的，编程中应加以注意并灵活应用，这也是前面之所以设置边框大小等变量的原因。</font><p align="justify"></p><font size="3"></font><p align="justify">5</p><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">．结束语</font><p align="justify">这种异形窗口的创建不仅适应于对话框，而且适应于所有的基于</p><font size="3">CWnd</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">类的派生窗口。采用这一方法，你可以创建出任何只要你能够画出的窗体，实现只要可以画出，就可以做出的目标。</font><p align="justify">本文代码在</p><font size="3">Visual C++ 5.0</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">、</font><font size="3">6.0</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">下调试通过，运行正常，操作系统为</font><font size="3">Windows98SE</font><font face="宋体" lang="zh-cn" size="3" xml:lang="zh-cn">。</font><p align="justify"></p><p align="justify">　</p><p align="justify">参考文献：</p><font size="3"></font><p align="justify"></p>Microsoft, MSDN Library Visual Studio 6.0 release, 1998 <p></p><p></p>                </div>                    </div>
3338	 制作伸展自如、收缩随意的对话框	delete  stream  wpf  windows  null  数据结构  	982025940	1663	ghj1976	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p>制作伸展自如、收缩随意的对话框 <br/><br/><br/><br/>菡冰 <br/><br/>Visual C++以其可视化的编程风格成为目前Windows程序设计与开发的主流开发工具。而对话框在Visual C++编程中使用的尤其多。诸如模式对话框、无模式对话框、基于对话框的应用程序等。绝大部分的VC++的书籍中都花费大量的篇幅与笔墨来讲解对话框，这充分证明了对话框在Windows应用程序中的作用。 <br/>很多人可能都用过Bitware软件，不知大家还记不记得其界面对话框就可以伸展自如。按下一个按钮，对话框就向水平方向或垂直方向扩展。再按一下按钮，对话框又回复到原来的大小。其实这并不是一个很复杂的问题，下面我们就来讲解如何制作伸展自如的对话框。 <br/>1 打开VisualC++工作台，新建工程设为aaa。 <br/><br/>2 创建基于对话框的应用程序如下所示： <br/>其余选择皆为缺省即可。 <br/><br/>3 在对话框资源中增加控件资源，如下图所示： <br/><br/>其中，最靠右边的一排控件和最靠近下面的两排控件将在对话框伸展或收缩时显示出来或被遮盖。并且为了示例方便，我们有意将他们的值对应起来。并且我们需要通过ClassWizard给每个控件分别关联成员变量，如下所示： <br/>参考DoDataExchange()函数我们就可以知道每个控件所关联的变量了，如下所示： <br/>DDX_Text(pDX, IDC_HEIGHT, m_wHeight); <br/>DDX_Text(pDX, IDC_STREAM_ID, m_wStreamID); <br/>DDX_Text(pDX, IDC_WIDTH, m_wWidth); <br/>DDX_Text(pDX, IDC_SEQUENCE_ORDER, m_wSequenceOrder); <br/>DDX_Text(pDX, IDC_MAX_RATE, m_dwMaxRate); <br/>DDX_Text(pDX, IDC_MIN_RATE, m_dwMinRate); <br/>DDX_Text(pDX, IDC_HEIGHT2, m_wHeight2); <br/>DDX_Text(pDX, IDC_MAX_RATE2, m_dwMaxRate2); <br/>DDX_Text(pDX, IDC_MIN_RATE2, m_dwMinRate2); <br/>DDX_Text(pDX, IDC_SEQUENCE_ORDER2, m_wSequenceOrder2); <br/>DDX_Text(pDX, IDC_STREAM_ID2, m_wStreamID2); <br/>DDX_Text(pDX, IDC_WIDTH2, m_wWidth2); <br/>DDX_Check(pDX, IDC_HORIZONTAL, m_bHorizontal); <br/>DDX_Check(pDX, IDC_VERTICAL, m_bVertical); <br/>实际上，我们也可以不用ClassWizard而直接将上面的一段代码copy到DoDataExchange()函数的 <br/>//{{AFX_DATA_MAP(CAaaDlg) <br/>...... <br/>//}}AFX_DATA_MAP <br/>之间，(注意一定要在“//{{AFX_DATA_MAP(CAaaDlg)”与“//}}AFX_DATA_MAP”之间)。 <br/>同时在aaaDlg.h文件中，在 <br/>//{{AFX_DATA(CAaaDlg) <br/>enum { IDD = IDD_AAA_DIALOG }; <br/>...... <br/>//}}AFX_DATA <br/>之间增加如下变量定义即可： <br/>(注意一定要在“//{{AFX_DATA(CAaaDlg)”与“//}}AFX_DATA”之间) <br/>UINT m_wHeight; <br/>UINT m_wStreamID; <br/>UINT m_wWidth; <br/>UINT m_wSequenceOrder; <br/>DWORD m_dwMaxRate; <br/>DWORD m_dwMinRate; <br/>UINT m_wHeight2; <br/>DWORD m_dwMaxRate2; <br/>DWORD m_dwMinRate2; <br/>UINT m_wSequenceOrder2; <br/>UINT m_wStreamID2; <br/>UINT m_wWidth2; <br/>BOOL m_bHorizontal; <br/>BOOL m_bVertical; <br/><br/>5 在完成上面的步骤后，我们就可以定义几个新的变量用来保存窗口伸展状态时的信息以及收缩状态时的信息。如下： <br/>WORD m_wOrigrinWidth; //原始状态下的窗口宽度 <br/>WORD m_wReducedWidth; //收缩状态下的窗口宽度 <br/><br/>WORD m_wOrigrinHeight; //原始状态下的窗口高度 <br/>WORD m_wReducedHeight; //收缩状态下的窗口高度 <br/><br/>WORD m_screenWidth; //屏幕宽度 <br/>WORD m_screenHeight; //屏幕高度 <br/><br/>在完成以上所有的步骤后，就可以对窗口的伸展与收缩进行随心所欲的控制了，首先我们来侃侃具体的代码，下面再进行具体的解释。代码为： <br/>CenterWindow(NULL); <br/><br/>m_screenWidth = GetSystemMetrics(SM_CXSCREEN); <br/>m_screenHeight = GetSystemMetrics(SM_CYSCREEN); <br/><br/>WINDOWPLACEMENT* lpwndpl=new WINDOWPLACEMENT; <br/>GetWindowPlacement(lpwndpl); <br/>m_wOrigrinWidth = lpwndpl-&gt;rcNormalPosition.right; <br/>m_wOrigrinWidth -= lpwndpl-&gt;rcNormalPosition.left; <br/>m_wOrigrinHeight = lpwndpl-&gt;rcNormalPosition.bottom; <br/>m_wOrigrinHeight -= lpwndpl-&gt;rcNormalPosition.top; <br/><br/>LPRECT lpRect1,lpRect2; <br/>lpRect1=new RECT; <br/>lpRect2=new RECT; <br/>GetDlgItem(IDC_PROGRESS_BAR)-&gt;GetWindowRect(lpRect1); <br/>GetDlgItem(IDC_STREAM_ID)-&gt;GetWindowRect(lpRect2); <br/><br/>lpwndpl-&gt;rcNormalPosition.right=(lpRect1-&gt;right+lpRect2-&gt;left)/2; <br/>m_wReducedWidth = lpwndpl-&gt;rcNormalPosition.right; <br/>m_wReducedWidth -= lpwndpl-&gt;rcNormalPosition.left; <br/><br/>GetDlgItem(IDC_PROGRESS_BAR)-&gt;GetWindowRect(lpRect1); <br/>GetDlgItem(IDC_SEQUENCE_ORDER2)-&gt;GetWindowRect(lpRect2); <br/>lpwndpl-&gt;rcNormalPosition.bottom=(lpRect1-&gt;bottom+lpRect2-&gt;top)/2; <br/>m_wReducedHeight = lpwndpl-&gt;rcNormalPosition.bottom; <br/>m_wReducedHeight -= lpwndpl-&gt;rcNormalPosition.top; <br/><br/>delete lpRect1; <br/>delete lpRect2; <br/><br/>if(m_bHorizontal == TRUE) <br/>{ <br/>lpwndpl-&gt;rcNormalPosition.right = lpwndpl-&gt;rcNormalPosition.left; <br/>lpwndpl-&gt;rcNormalPosition.right += m_wOrigrinWidth; <br/><br/>lpwndpl-&gt;rcNormalPosition.bottom = lpwndpl-&gt;rcNormalPosition.top; <br/>lpwndpl-&gt;rcNormalPosition.bottom += m_wReducedHeight; <br/>} <br/>else <br/>{ <br/>lpwndpl-&gt;rcNormalPosition.right = lpwndpl-&gt;rcNormalPosition.left; <br/>lpwndpl-&gt;rcNormalPosition.right += m_wReducedWidth; <br/><br/>lpwndpl-&gt;rcNormalPosition.bottom = lpwndpl-&gt;rcNormalPosition.top; <br/>lpwndpl-&gt;rcNormalPosition.bottom += m_wReducedHeight; <br/>} <br/><br/>if(m_bVertical == TRUE) <br/>{ <br/>lpwndpl-&gt;rcNormalPosition.right = lpwndpl-&gt;rcNormalPosition.left; <br/>lpwndpl-&gt;rcNormalPosition.right += m_wReducedWidth; <br/><br/>lpwndpl-&gt;rcNormalPosition.bottom = lpwndpl-&gt;rcNormalPosition.top; <br/>lpwndpl-&gt;rcNormalPosition.bottom += m_wOrigrinHeight; <br/>} <br/>else <br/>{ <br/><br/>lpwndpl-&gt;rcNormalPosition.right = lpwndpl-&gt;rcNormalPosition.left; <br/>lpwndpl-&gt;rcNormalPosition.right += m_wReducedWidth; <br/><br/>lpwndpl-&gt;rcNormalPosition.bottom = lpwndpl-&gt;rcNormalPosition.top; <br/>lpwndpl-&gt;rcNormalPosition.bottom += m_wReducedHeight; <br/>} <br/><br/>SetWindowPlacement(lpwndpl); <br/><br/>上面这段代码首先将窗口置于屏幕中间，这可以通过函数CenterWindow(GetDesktopWindow()) 来实现，函数 CenterWindow()的用法为： <br/>void CenterWindow( CWnd* pAlternateOwner = NULL ); <br/>其中参数pAlternateOwner指向所想居中的窗口的指针。 <br/>然后利用函数GetSystemMetrics( int nIndex )得到系统当前设置如屏幕分辨率等。 <br/>nIndexs= SM_CXSCREEN 时函数返回屏幕的宽度；返回值单位为像素点。 <br/>nIndexs= SM_CYSCREEN 时函数返回屏幕的高度；返回值单位为像素点。 <br/>函数BOOL GetWindowPlacement( WINDOWPLACEMENT* lpwndpl ) 是最重要的。他的参数为一个指向结构变量WINDOWPLACEMENT的指针(lpwndpl)；其中WINDOWPLACEMENT结构变量数据结构具体为： <br/>typedef struct tagWINDOWPLACEMENT { /* wndpl */ <br/>UINT length; <br/>UINT flags; <br/>UINT showCmd; <br/>POINT ptMinPosition; <br/>POINT ptMaxPosition; <br/>RECT rcNormalPosition; <br/>} WINDOWPLACEMENT; <br/>他包含了窗口在屏幕上的定位信息。其中成员变量的含义为： <br/>length：指结构变量的长度，单位字节。 <br/>flags: 标志值，控制窗口最小化或窗口还原的方法，可以取如下值： <br/>WPF_SETMINPOSITION：指定窗口最小化时的x位置和y位置。 <br/>WPF_RESTORETOMAXIMIZED：指定窗口以最大化方式还原，尽管可能窗口并不是在最大化时最小化的。不改变窗口的缺省还原方式。 <br/>showCmd：指定窗口的当前显示状态。可以取值： <br/>SW_HIDE：隐藏窗口并激活另一窗口。 <br/>SW_MINIMIZE：最小化指定窗口并激活系统窗口列表中最顶层窗口。 <br/>SW_RESTORE：激活并显示窗口，如果窗口处于最小化或最大化状态，则窗口还原到原始大小和位置。 <br/>SW_SHOW：以窗口的当前大小和位置激活并显示窗口。 <br/>SW_SHOWMAXIMIZED：以最大化方式激活并显示窗口。 <br/>SW_SHOWMINIMIZED：以图标方式激活并显示窗口。 <br/>SW_SHOWMINNOACTIVE：以图标方式窗口。 但不改变窗口的活动状态。 <br/>SW_SHOWNA：以窗口的当前状态显示窗口。 <br/>SW_SHOWNOACTIVATE：以窗口最近一次的大小和位置显示窗口。 但不改变窗口的活 动状态。 <br/>SW_SHOWNORMAL：激活并显示窗口。如果窗口被最大化或最小化，则窗口还原到原始大小和位置。 <br/>ptMinPosition：指定窗口最小化时的左伤角坐标。 <br/>ptMaxPosition：指定窗口最大化时的左伤角坐标。 <br/>rcNormalPosition：指定窗口在还原时的坐标。 <br/>通过灵活使用函数GetWindowPlacement()就可以得到窗口的配置信息。 <br/>看到这，可能有些读者已经想到了GetWindowPlacement()函数的姐妹函数SetWindowPlacement()，不用多说，其用法如下： <br/>BOOL SetWindowPlacement( WINDOWPLACEMENT* lpwndpl )； <br/>显然，通过函数SetWindowPlacement()，再加以简单的计算，我们就可以来设置窗口的位置、大小以及状态等，从而可以自如地控制窗口显示与否以及窗口的大小、位置等。这里我们就不再多解释了。 <br/><br/>6 利用ClassWizard对控件IDC_HORIZONTAL和IDC_VERTICAL增加消息映射BB_CLICKED, <br/><br/>并分别在消息映射函数中增加如下代码如下： <br/>void CAaaDlg::OnHorizontal() <br/>{ <br/>// TODO: Add your control notification handler code here <br/>m_bHorizontal = !m_bHorizontal; <br/><br/>UpdateData(FALSE); <br/><br/>WINDOWPLACEMENT* lpwndpl=new WINDOWPLACEMENT; <br/>GetWindowPlacement(lpwndpl); <br/>if(m_bHorizontal == TRUE) <br/>{ <br/>lpwndpl-&gt;rcNormalPosition.right = lpwndpl-&gt;rcNormalPosition.left; <br/>lpwndpl-&gt;rcNormalPosition.right += m_wOrigrinWidth; <br/>/* <br/>lpwndpl-&gt;rcNormalPosition.bottom = lpwndpl-&gt;rcNormalPosition.top; <br/>lpwndpl-&gt;rcNormalPosition.bottom += m_wReducedHeight; <br/>*/ <br/>} <br/>else <br/>{ <br/>lpwndpl-&gt;rcNormalPosition.right = lpwndpl-&gt;rcNormalPosition.left; <br/>lpwndpl-&gt;rcNormalPosition.right += m_wReducedWidth; <br/>/* <br/>lpwndpl-&gt;rcNormalPosition.bottom = lpwndpl-&gt;rcNormalPosition.top; <br/>lpwndpl-&gt;rcNormalPosition.bottom += m_wReducedHeight; <br/>*/ <br/>} <br/><br/>SetWindowPlacement(lpwndpl); <br/>delete lpwndpl; <br/>} <br/><br/>void CAaaDlg::OnVertical() <br/>{ <br/>// TODO: Add your control notification handler code here <br/>m_bVertical = !m_bVertical; <br/><br/>UpdateData(FALSE); <br/><br/>WINDOWPLACEMENT* lpwndpl=new WINDOWPLACEMENT; <br/>GetWindowPlacement(lpwndpl); <br/><br/>if(m_bVertical == TRUE) <br/>{ <br/>lpwndpl-&gt;rcNormalPosition.bottom = lpwndpl-&gt;rcNormalPosition.top; <br/>lpwndpl-&gt;rcNormalPosition.bottom += m_wOrigrinHeight; <br/>} <br/>else <br/>{ <br/>lpwndpl-&gt;rcNormalPosition.bottom = lpwndpl-&gt;rcNormalPosition.top; <br/>lpwndpl-&gt;rcNormalPosition.bottom += m_wReducedHeight; <br/>} <br/><br/>SetWindowPlacement(lpwndpl); <br/>delete lpwndpl; <br/>} <br/><br/>7 最后利用ClassWizard对控件IDC_BEGIN_SIMULATE增加消息映射BB_CLICKED。在这里我们模拟了一个100次循环的随机数显示程序。具体大妈如下： <br/>void CAaaDlg::OnBeginSimulate() <br/>{ <br/>// TODO: Add your control notification handler code here <br/>srand((unsigned)time(NULL)); <br/>char temp[10]; <br/>SetDlgItemText(IDC_STATIC11,"Now Beginning ..."); <br/>for(int i=0;i&lt;m_maxRange;i++) <br/>{ <br/>m_pProgressCtrl-&gt;SetPos(i); <br/>m_wSequenceOrder = m_wSequenceOrder2 = i; <br/>m_wStreamID = m_wStreamID2 = rand(); <br/>m_wHeight = m_wHeight2 = rand(); <br/>m_wWidth = m_wWidth2 = rand(); <br/>m_dwMaxRate = m_dwMaxRate2 = rand(); <br/>m_dwMinRate = m_dwMinRate2 = rand(); <br/>switch(i%4) <br/>{ <br/>case 0: <br/>sprintf(temp,"欢 迎 使 用"); <br/>break; <br/>case 1: <br/>sprintf(temp,"迎 使 用 欢"); <br/>break; <br/>case 2: <br/>sprintf(temp,"使 用 欢 迎"); <br/>break; <br/>case 3: <br/>sprintf(temp,"用 欢 迎 使"); <br/>break; <br/>} <br/>SetDlgItemText(IDC_WELCOME,temp); <br/>UpdateData(FALSE); <br/>UpdateWindow(); <br/>Sleep(50); <br/>} <br/>SetDlgItemText(IDC_WELCOME,"欢 迎 使 用"); <br/>SetDlgItemText(IDC_STATIC11,"Now Finnished ..."); <br/>} <br/><br/>8 完成以上所有的步骤之后，我们就可以编译程序并运行。运行结果如下： <br/><br/>(a) (b) <br/>(a): 程序启动时对话框状态 <br/>(b): 点击Horizontal框后对话框状态。 <br/><br/>(c) (d) <br/>(c): 点击Vertical框后对话框状态。 <br/>(d): 点击BeginSimulating按钮后系统模拟运行对话框状态。 <br/><br/>在本程序中，我们还用到了一些其它的技巧如修改窗口标题，进程状态条的显示、动态字符串显示以及不通过ClassWizard而直接通过在.cpp和.h文件中增加代码的方法来关联控件与成员变量和消息映射等，这些都是一些很实用的技巧，读者可以参考上面的代码以及源程序细细体会，这里我们就不多说了。 <br/>程序源工程文件见aaa.zip。在VisualC++6.0下编译通过。 <br/></p><p> </p>                </div>                    </div>
3541	 Beta1到Beta2改变详细列表（英文）	interop  compiler  asp.net  security  library  list  	1003897560	1657	ghj1976	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p> </p><h1>Beta 1 to Beta 2 Changes</h1>Here's the first thing I would do if you are a developer of .NET <br/>1. <b>BOOKMARK THIS PAGE!</b> <br/>It will save you a ton of time as you migrate your apps. Then as you find a broken namespace in your app, or something else that no longer works in Beta2, click one of the links below and search the page (Ctrl-F for IE users) for your term. These documents are part of the downloads found at www.asp.net. <p>Here is the change list </p><p><br/><b>API Changes</b> (thanks to Alex Lowe from <a href="http://www.aspalliance.com/aldotnet/">http://www.aspalliance.com/aldotnet/</a>) </p><ul><li><a href="http://www.123aspx.com/b1to2changes/APIChanges.asp">API changes broken down by Namespace</a> </li></ul><br/><b>Compiler and Language Changes</b> <ul><li><a href="http://www.123aspx.com/b1to2changes/csharp.asp">C#</a>   (size 83k) </li><li><a href="http://www.123aspx.com/b1to2changes/vbnet.asp">Visual Basic.NET</a>   (size 13k) </li><li><a href="http://www.123aspx.com/b1to2changes/jscript.asp">JScript.NET</a>   (size 10k) </li><li><a href="http://www.123aspx.com/b1to2changes/cplusplus.asp">Managed Extensions for C++</a>   (size 39k) </li><li><a href="http://www.123aspx.com/b1to2changes/toolchanges.asp">SDK Tools Changes</a>   (size 55k) </li></ul><br/><b>Framework Class Library Changes</b> <ul><li><a href="http://www.123aspx.com/b1to2changes/aspnet.asp">ASP.NET</a>   (size 274k) </li><li><a href="http://www.123aspx.com/b1to2changes/classlib.asp">ClassLib</a>   (size 410k) </li><li><a href="http://www.123aspx.com/b1to2changes/netclasses.asp">Net Classes</a>   (size 35k) </li><li><a href="http://www.123aspx.com/b1to2changes/frameworkchanges.asp">Framework</a>   (size 390k) </li><li><a href="http://www.123aspx.com/b1to2changes/clr.asp">Common Language Runtime</a>   (size 39k) </li><li><a href="http://www.123aspx.com/b1to2changes/interop.asp">Interop</a>   (size 45k) </li><li><a href="http://www.123aspx.com/b1to2changes/jit.asp">JIT</a>   (size 3k) </li><li><a href="http://www.123aspx.com/b1to2changes/metadata.asp">Metadata</a>   (size 5k) </li><li><a href="http://www.123aspx.com/b1to2changes/misc.asp">Miscellaneous</a>   (size 41k) </li><li><a href="http://www.123aspx.com/b1to2changes/security.asp">Security</a>   (size 92k) </li></ul><p></p><p>If you have alot of bandwidth, you can <a href="http://www.123aspx.com/b1to2changes/allchanges.asp"><b>view the whole list</b></a>, but it is 1.6MEG. <br/><a href="http://www.123aspx.com/b1to2changes/allchanges.asp"><b>CLICK HERE</b></a> to view the list. </p><p>说明：这只是页面的连接开始页，进去后，不下100个页面的连接，实在太恐怖，无法完全转贴过来，更不是一个人可以翻译完成的。所以就只转贴这个连接。需要的可以自己根据连接去查找。</p>                </div>                    </div>
3781	 在对话框中使用ON_UPDATE_COMMAND_UI更新菜单	command  ui  null  microsoft  menu  mfc  	997078620	3710	jiangsheng	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <table><tbody><tr><td><h2>本文翻译自<a href="http://support.microsoft.com/kb/242577">http://support.microsoft.com/kb/242577</a></h2><h2>问题: 更新处理函数在对话框的菜单中不能工作</h2></td></tr></tbody></table><b>ID: Q242577</b> <p></p><hr/>此文章的信息应用于:<br/><ul><li>Microsoft Visual C++, 32位版本, version 6.0, 使用: <ul><li>The Microsoft Foundation Classes (MFC)</li></ul></li></ul><hr/><br/><h2>症状</h2><p>从命令用户界面处理函数(Command UI handler)改变菜单状态(启用/禁用,选择/取消选择,更改文字)在由对话框处理时没有正常工作。</p><pre class="CODESAMP"><code>void CTestDlg::OnUpdateFileExit(CCmdUI* pCmdUI{    pCmdUI-&gt;Enable(FALSE); //没有显示为禁用.    pCmdUI-&gt;SetCheck(TRUE); // 没有文字前显示选定标记.    pCmdUI-&gt;SetRadio(TRUE); // 没有在文字前显示点.    pCmdUI-&gt;SetText("Close"); //没有更改菜单文字.} </code></pre><p></p><br/><h2>原因</h2><p>在下拉菜单显示的时候, WM_INITMENUPOPUP消息被先发送以显示菜单项。MFC <b>CFrameWnd::OnInitMenuPopup</b> 函数遍历菜单项并为每个菜单项调用更新命令处理函数（如果有的话）.菜单的外观被更新以反映它的状态（启用/禁用,选择/取消选择） <br/>更新用户界面机制在基于对话框的应用程序中不能工作，因为<b>CDialog没有</b><b>OnInitMenuPopup</b> 处理函数，而使用<b>CWnd</b>'s 默认处理函数,该函数没有为菜单项调用更新命令处理函数。</p><br/><h2>解决</h2><p>适用下列步骤解决此问题  </p><ol><li>在消息映射中添加<b>ON_WM_INITMENUPOPUP</b> 项: <pre class="CODESAMP"><code>BEGIN_MESSAGE_MAP(CTestDlg, CDialog) //{{AFX_MSG_MAP(CTestDlg)                        ........................                        ........................ //}}AFX_MSG_MAP ON_WM_INITMENUPOPUP()END_MESSAGE_MAP() </code></pre><br/><br/></li><li>在你的对话框类中添加<b>OnInitMenuPopup</b>成员函数且复制下列代码到该函数（注意：代码基本上是从CFrameWnd::OnInitMenuPopup（在WinFrm.cpp中)复制过来的）: <pre class="CODESAMP"><code>void CTestDlg::OnInitMenuPopup(CMenu *pPopupMenu, UINT nIndex,BOOL bSysMenu){    ASSERT(pPopupMenu != NULL);    // Check the enabled state of various menu items.    CCmdUI state;    state.m_pMenu = pPopupMenu;    ASSERT(state.m_pOther == NULL);    ASSERT(state.m_pParentMenu == NULL);    // Determine if menu is popup in top-level menu and set m_pOther to    // it if so (m_pParentMenu == NULL indicates that it is secondary popup).    HMENU hParentMenu;    if (AfxGetThreadState()-&gt;m_hTrackingMenu == pPopupMenu-&gt;m_hMenu)        state.m_pParentMenu = pPopupMenu;    // Parent == child for tracking popup.    else if ((hParentMenu = ::GetMenu(m_hWnd)) != NULL)    {        CWnd* pParent = this;           // Child windows don't have menus--need to go to the top!        if (pParent != NULL &amp;&amp;           (hParentMenu = ::GetMenu(pParent-&gt;m_hWnd)) != NULL)        {           int nIndexMax = ::GetMenuItemCount(hParentMenu);           for (int nIndex = 0; nIndex &lt; nIndexMax; nIndex++)           {            if (::GetSubMenu(hParentMenu, nIndex) == pPopupMenu-&gt;m_hMenu)            {                // When popup is found, m_pParentMenu is containing menu.                state.m_pParentMenu = CMenu::FromHandle(hParentMenu);                break;            }           }        }    }    state.m_nIndexMax = pPopupMenu-&gt;GetMenuItemCount();    for (state.m_nIndex = 0; state.m_nIndex &lt; state.m_nIndexMax;      state.m_nIndex++)    {        state.m_nID = pPopupMenu-&gt;GetMenuItemID(state.m_nIndex);        if (state.m_nID == 0)           continue; // Menu separator or invalid cmd - ignore it.        ASSERT(state.m_pOther == NULL);        ASSERT(state.m_pMenu != NULL);        if (state.m_nID == (UINT)-1)        {           // Possibly a popup menu, route to first item of that popup.           state.m_pSubMenu = pPopupMenu-&gt;GetSubMenu(state.m_nIndex);           if (state.m_pSubMenu == NULL ||            (state.m_nID = state.m_pSubMenu-&gt;GetMenuItemID(0)) == 0 ||            state.m_nID == (UINT)-1)           {            continue;       // First item of popup can't be routed to.           }           state.DoUpdate(this, TRUE);   // Popups are never auto disabled.        }        else        {           // Normal menu item.           // Auto enable/disable if frame window has m_bAutoMenuEnable           // set and command is _not_ a system command.           state.m_pSubMenu = NULL;           state.DoUpdate(this, FALSE);        }        // Adjust for menu deletions and additions.        UINT nCount = pPopupMenu-&gt;GetMenuItemCount();        if (nCount &lt; state.m_nIndexMax)        {           state.m_nIndex -= (state.m_nIndexMax - nCount);           while (state.m_nIndex &lt; nCount &amp;&amp;            pPopupMenu-&gt;GetMenuItemID(state.m_nIndex) == state.m_nID)           {            state.m_nIndex++;           }        }        state.m_nIndexMax = nCount;    }} </code></pre><br/><br/></li></ol><p></p><br/><h2>状态</h2><p>设计使然。</p><h2>更多信息</h2><p>命令用户界面处理函数也被<b>CWnd::OnCommand</b> 调用以确认命令在传递之前没有被禁用。这就是禁用的菜单项的命令处理没有被调用的原因(虽然没有以灰色显示（不可用）)。在这种情况下，菜单项没有被重画以反映菜单项的状态.这是Wincore.cpp 文件中的相关代码: </p><pre class="CODESAMP"><code>   //在传递命令之前，确定命令没有被禁用</code></pre><pre class="CODESAMP"><code>   CTestCmdUI state;   state.m_nID = nID;   OnCmdMsg(nID, CN_UPDATE_COMMAND_UI, &amp;state, NULL);   if (!state.m_bEnabled)   {      TRACE1("Warning: not executing disabled command %d/n", nID);      return TRUE;   } </code></pre><h3>重现此行为的步骤</h3><ol><li>使用应用程序向导建立一个基于对话框的应用程序<br/><br/></li><li>建立一个新的菜单资源，并且向其上添加文件和文件/退出菜单项。<br/><br/></li><li>在对话框的属性中设置对话框的菜单为上述菜单.<br/><br/></li><li>使用类向导为文件/退出菜单项添加一个UPDATE_COMMAND_UI处理并添加下列语句之一到处理函数。<br/><pre class="CODESAMP"><code>pCmdUI-&gt;Enable(FALSE); //没有显示为禁用.pCmdUI-&gt;SetCheck(TRUE); // 没有文字前显示选定标记.pCmdUI-&gt;SetRadio(TRUE); // 没有在文字前显示点.pCmdUI-&gt;SetText("Close"); //没有更改菜单文字.</code></pre></li><li>编译运行此程序。</li></ol><p></p><br/><h2>参考</h2><p>要获取更多信息,请查看微软知识库中的文章: </p><blockquote><a href="http://support.microsoft.com/kb/141751">Q141751 示例: 使用MFC为对话框添加控制栏</a></blockquote><p>© 微软公司9/29/1999, 保留所有权利.<br/>微软公司 Sreedhar Pelluru 投稿 </p><p></p><p></p><p> </p><!--CONVLEGACY DELIMITER-->                </div>                    </div>
3796	 使用虚列表和自画实现文件夹的缩略图显示	null  文档  shell  path  mfc  delete  	1069259100	15355	jiangsheng	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p>本示例演示了列表控件的虚列表和自画功能，也演示了一些系统外壳的函数和接口的使用方法。</p><p>单击 <a href="http://download.csdn.net/source/236507">这里</a> 下载本文的代码。如果在编译示例程序的时候出现问题，你需要去<a href="http://www.microsoft.com/msdownload/platformsdk/sdkupdate/">http://www.microsoft.com/msdownload/platformsdk/sdkupdate/</a> 升级你的头文件和库文件</p><h2>预备性阅读</h2><p>在阅读本文之前，建议先对列表视图控件和系统外壳有一个基本的了解。建议阅读以下SDK文章</p><ul><li><a href="http://msdn.microsoft.com/library/en-us/shellcc/platform/shell/programmersguide/shell_faq.asp">Shell FAQ</a>  </li>    <li><a href="http://msdn.microsoft.com/library/en-us/shellcc/platform/commctls/listview/listview_overview.asp">List-View Controls Overview</a>  </li>    <li><a href="http://msdn.microsoft.com/library/en-us/shellcc/platform/commctls/listview/listview_using.asp">Using List-View Controls</a>  </li>    <li><a href="http://msdn.microsoft.com/library/en-us/shellcc/platform/commctls/custdraw/custdraw.asp">Customizing a Control's Appearance Using Custom Draw</a></li></ul><h2>创建应用程序</h2><p>使用MFC应用程序向导创建一个SDI应用程序，在最后一步选择视图的基类为CListView。创建完成之后，在资源中去掉保存、编辑和打印等功能的菜单和工具栏按钮（因为这些功能没有实现）。</p><h2>虚列表的创建</h2><p>本文采用虚列表技术，使得显示信息是在第一次显示的时候才被获取。为了创建虚列表，在创建之前需要指定列表的风格</p><p>BOOL CPicViewView::PreCreateWindow(CREATESTRUCT&amp; cs)<br/>{<br/>    cs.style&amp;=~LVS_TYPEMASK;<br/>    cs.style|=LVS_ICON|LVS_OWNERDATA;<br/>    return CListView::PreCreateWindow(cs);<br/>}<br/>同时，因为列表项的Overlay图标也是被动态获取的，所以需要设置动态Overlay图标</p><p>void CPicViewView::OnInitialUpdate()<br/>{<br/>    CListView::OnInitialUpdate();<br/>    GetListCtrl().SetCallbackMask(LVIS_OVERLAYMASK);<br/>}</p><h2>缓存显示信息</h2><p>在列表需要显示一个范围的项目之前，列表会发送LVN_ODCACHEHINT通知，应用程序可以捕获这个消息来缓存部分列表的显示信息，以提高性能。</p><p>void CPicViewView::OnOdcachehint(NMHDR* pNMHDR, LRESULT* pResult) <br/>{<br/>    NMLVCACHEHINT* pCacheHint = (NMLVCACHEHINT*)pNMHDR;<br/>    PrepCache(0,min(5,m_arpFolderItems.GetSize()));<br/>    PrepCache(pCacheHint-&gt;iFrom,pCacheHint-&gt;iTo);<br/>    PrepCache(max(0,m_arpFolderItems.GetSize()-5),m_arpFolderItems.GetSize());<br/>    *pResult = 0;<br/>}<br/>在列表需要显示一个项目之前，列表会发送LVN_GETDISPINFO通知，应用程序可以捕获这个消息来提供项目的显示信息。如果显示时需要显示的列表项在缓存中，那么可以从缓存中获取显示信息。否则需要重新从文件获得。</p><p>void CPicViewView::OnGetdispinfo(NMHDR* pNMHDR, LRESULT* pResult) <br/>{<br/>    LV_DISPINFO* pDispInfo = (LV_DISPINFO*)pNMHDR;<br/>    if(pDispInfo-&gt;item.iItem==-1)return;<br/>    HRESULT hr=S_OK;<br/>    LPCITEMIDLIST pidlItem=m_arpFolderItems[pDispInfo-&gt;item.iItem];<br/>    CFolderItemInfo* pFolderItemInfo=FindItemInCache(pidlItem);<br/>    BOOL bCached=TRUE;<br/>    if(pFolderItemInfo==NULL){<br/>        bCached=FALSE;<br/>        pFolderItemInfo=new CFolderItemInfo;<br/>        GetItemInfo(pidlItem,pFolderItemInfo);<br/>    }<br/>    if(pDispInfo-&gt;item.mask&amp;LVIF_TEXT){<br/>        lstrcpyn(pDispInfo-&gt;item.pszText,pFolderItemInfo-&gt;tszDisplayName,pDispInfo-   &gt;item.cchTextMax);<br/>    }<br/>    if(pDispInfo-&gt;item.mask&amp;LVIF_IMAGE){<br/>        pDispInfo-&gt;item.iImage=pFolderItemInfo-&gt;iIcon;<br/>    }<br/>    if(pDispInfo-&gt;item.mask&amp;LVIF_STATE){<br/>        pDispInfo-&gt;item.state=pFolderItemInfo-&gt;state;<br/>    }<br/>    if(!bCached)<br/>        delete pFolderItemInfo;<br/>    *pResult = 0;<br/>}</p><h2><br/>文件图标的显示</h2><p>默认情况下，列表项的图标就是其系统图标。首先获得系统图像列表</p><p>int CPicViewView::OnCreate(LPCREATESTRUCT lpCreateStruct) <br/>{<br/>    if (CListView::OnCreate(lpCreateStruct) == -1)<br/>        return -1;<br/>    HRESULT hr = SHGetMalloc(&amp;m_pMalloc); if(FAILED(hr)) return -1;<br/>    hr = SHGetDesktopFolder(&amp;m_psfDesktop);if(FAILED(hr)) return -1;<br/>    SHFILEINFO shfi;<br/>    ZeroMemory(&amp;shfi,sizeof(SHFILEINFO));<br/>    HIMAGELIST hi=(HIMAGELIST)SHGetFileInfo(NULL,0,&amp;shfi,sizeof(SHFILEINFO),SHGFI_ICON |SHGFI_SYSICONINDEX|SHGFI_SMALLICON);<br/>    GetListCtrl().SetImageList(CImageList::FromHandle(hi),LVSIL_SMALL);<br/>    hi=(HIMAGELIST)SHGetFileInfo(NULL,0,&amp;shfi,sizeof(SHFILEINFO),SHGFI_ICON |SHGFI_SYSICONINDEX|SHGFI_LARGEICON);<br/>    GetListCtrl().SetImageList(CImageList::FromHandle(hi),LVSIL_NORMAL);<br/>    return 0;<br/>}</p><p>然后在获取文件信息时，从文件获得其图标在系统图像列表中的索引。</p><p>如果列表项是图像文件，并且从文件成功载入图像，那么使用自画功能以替换默认的图标。</p><p>void CPicViewView::OnCustomDraw(NMHDR* pNMHDR, LRESULT* pResult)<br/>{<br/>    LPNMLVCUSTOMDRAW lpNMCustomDraw = (LPNMLVCUSTOMDRAW) pNMHDR;<br/>    switch(lpNMCustomDraw -&gt;nmcd.dwDrawStage) {<br/>        case CDDS_PREPAINT : *pResult=CDRF_NOTIFYITEMDRAW;return;<br/>        case CDDS_ITEMPREPAINT:*pResult=CDRF_NOTIFYPOSTPAINT;return;<br/>        case CDDS_ITEMPOSTPAINT:<br/>        {<br/>            int iItem=lpNMCustomDraw -&gt;nmcd.dwItemSpec;<br/>            if(iItem==-1){<br/>                *pResult=CDRF_DODEFAULT;return;<br/>            }<br/>            CFolderItemInfo* pItemInfo=FindItemInCache(m_arpFolderItems[iItem]);<br/>            if(pItemInfo==NULL||pItemInfo-&gt;bFailLoadPic||pItemInfo-&gt;pic.m_pPict==NULL){<br/>                *pResult=CDRF_DODEFAULT;return;<br/>            }<br/>            CRect rectIcon;<br/>            GetListCtrl().GetItemRect(iItem,&amp;rectIcon,LVIR_ICON);<br/>            CDC* pDC=CDC::FromHandle(lpNMCustomDraw-&gt;nmcd.hdc);<br/>            pItemInfo-&gt;pic.Render(pDC,rectIcon,rectIcon);<br/>        }<br/>        *pResult=CDRF_NEWFONT;return;<br/>    }<br/>    * pResult=0;<br/>}</p><p>上面的代码是使用获取的文件显示信息中的图像，在列表项图标的区域画图。</p><h2>获取显示信息</h2><p>为了缓存列表项的显示信息，或者显示列表项，需要获取列表项的文字、图标、Overlay图标和缩略图等信息。这里使用了ILCombine来把缓存中的相对PIDL转化为完整的Pidl,再据此获得文件的完整路径，然后调用OleLoadPicturePath函数载入图像。</p><p>void CPicViewView::GetItemInfo(LPCITEMIDLIST pidl,CFolderItemInfo* pItemInfo)<br/>{<br/>    HRESULT hr = theApp.SHGetDisplayNameOf(pidl,pItemInfo-&gt;tszDisplayName);<br/>    IShellIcon* pShellIcon=NULL;<br/>    hr=m_psfFolder-&gt;QueryInterface(IID_IShellIcon,(LPVOID*)&amp;pShellIcon);<br/>    if (SUCCEEDED(hr)&amp;&amp;pShellIcon){<br/>        pShellIcon-&gt;GetIconOf(pidl,0,&amp;pItemInfo-&gt;iIcon);<br/>        pShellIcon-&gt;Release();<br/>    }<br/>    IShellIconOverlay* pShellIconOverlay =NULL;<br/>    hr=m_psfFolder-&gt;QueryInterface(IID_IShellIconOverlay,(LPVOID*)&amp;pShellIconOverlay);<br/>    if (SUCCEEDED(hr)&amp;&amp;pShellIconOverlay){<br/>        int nOverlay=0;<br/>        pShellIconOverlay-&gt;GetOverlayIndex(pidl,&amp;nOverlay);<br/>        pItemInfo-&gt;state=INDEXTOOVERLAYMASK (nOverlay);<br/>        pShellIconOverlay-&gt;Release();<br/>    }<br/>    LPITEMIDLIST pidlItemFull=ILCombine(m_pidlFolder,pidl);<br/>        if(pidlItemFull){<br/>            if(SHGetPathFromIDList(pidlItemFull,pItemInfo-&gt;tszPath)){<br/>                USES_CONVERSION;<br/>                hr=OleLoadPicturePath(<br/>                    T2OLE(pItemInfo-&gt;tszPath)<br/>                    ,NULL,0,RGB(255,255,255)<br/>                    ,IID_IPicture,(LPVOID*)&amp;pItemInfo-&gt;pic.m_pPict);<br/>            if(FAILED(hr)){<br/>                    pItemInfo-&gt;bFailLoadPic=TRUE;<br/>                    TRACE("OleLoadPicturePath failed %s/r/n",pItemInfo-&gt;tszPath);<br/>                }<br/>            }<br/>        }<br/>        m_pMalloc-&gt;Free(pidlItemFull);<br/>    }<br/>}</p><h2>缓存目录的数据</h2><p>在更改目录时，需要重建目录内容的缓存。这包括目录的pidl和IShellFolder接口指针，目录内容的相对pidl，以及列表项的显示信息（基于性能上的考虑，列表项的显示信息是在接收到LVN_ODCACHEHINT通知的时候缓存的）。</p><p>LPITEMIDLIST m_pidlFolder;<br/>IShellFolder * m_psfFolder;<br/>CTypedPtrArray&lt;CPtrArray,LPITEMIDLIST&gt; m_arpFolderItems;<br/>CTypedPtrMap&lt;CMapPtrToPtr,LPITEMIDLIST,CFolderItemInfo*&gt; m_mapCache;<br/> </p><p>void CPicViewView::EnterFolder(LPCITEMIDLIST pidl)<br/>{<br/>    USES_CONVERSION;<br/>    m_pidlFolder=ILClone(pidl);<br/>    if(m_pidlFolder){<br/>        LPENUMIDLIST ppenum = NULL;<br/>        LPITEMIDLIST pidlItems = NULL;<br/>        ULONG celtFetched;<br/>        HRESULT hr;<br/>        hr = m_psfDesktop-&gt;BindToObject(m_pidlFolder, NULL, IID_IShellFolder, (LPVOID *) &amp;m_psfFolder);<br/>        if(SUCCEEDED(hr)){<br/>            hr = m_psfFolder-&gt;EnumObjects(NULL,SHCONTF_FOLDERS | SHCONTF_NONFOLDERS, &amp;ppenum);<br/>            if(SUCCEEDED(hr)){<br/>                while( hr = ppenum-&gt;Next(1,&amp;pidlItems, &amp;celtFetched) == S_OK &amp;&amp; (celtFetched) == 1){<br/>                    m_arpFolderItems.Add(pidlItems);<br/>                    }<br/>            }<br/>        }<br/>        GetListCtrl().SetItemCount(m_arpFolderItems.GetSize());<br/>    }<br/>}</p><p> </p><h2>打开文件夹</h2><p>本应用程序显示文件夹的内容而不是显示文档的内容，所以我重载了打开文件时的处理，显示目录选择对话框而不是文件打开对话框。</p><p>void CPicViewApp::OnFileOpen() <br/>{<br/>    TCHAR tszDisplayName[_MAX_PATH];<br/>    TCHAR tszPathSelected[_MAX_PATH];<br/>    LPITEMIDLIST pidlSelected=PidlBrowse(m_pMainWnd-&gt;GetSafeHwnd(),0,tszDisplayName);<br/>    if(pidlSelected){<br/>        if(SHGetPathFromIDList(pidlSelected,tszPathSelected)){<br/>            CDocument* pDocument=OpenDocumentFile(tszPathSelected);<br/>            pDocument-&gt;SetTitle(tszDisplayName);<br/>            ILFree(pidlSelected);<br/>        }<br/>    }<br/>}</p><p>注意从外壳调用获得的PIDL一般都需要调用ILFree或者IMalloc::Free释放。一个例外是调用函数SHBindToParent获得的相对pidl，因为它是输入的参数完整pidl的一部分，所以不必另外释放。</p><p>在新建或者打开“文件”时候，文档需要通知视图当前文件夹的更改，这是通过调用CDocument::UpdateAllViews和重载CView::OnUpdate实现的。视图对这个通知的处理是清除上一个目录的缓存数据，缓存新目录的数据，以及更新文档标题。<br/> </p><h2>打开文件或者目录</h2><p>为了使用方便，双击列表项时可以在同一窗口打开子目录，或者调用系统的默认处理程序打开文件。如果文件是快捷方式，那么打开快捷方式的目标。</p><p>void CPicViewView::OnDblclk(NMHDR* pNMHDR, LRESULT* pResult) <br/>{<br/>    LPNMLISTVIEW lpnm=(LPNMLISTVIEW)pNMHDR;<br/>    if(lpnm-&gt;iItem==-1)return;<br/>    *pResult = 0;<br/>    HRESULT hr=S_OK;<br/>    LPCITEMIDLIST pidlItem=m_arpFolderItems[lpnm-&gt;iItem];<br/>    LPITEMIDLIST pidlItemFull=ILCombine(m_pidlFolder,pidlItem);<br/>    LPITEMIDLIST pidlItemTarget=NULL;<br/>    hr=theApp.SHGetTargetFolderIDList(pidlItemFull,&amp;pidlItemTarget);<br/>    if(pidlItemTarget){<br/>        if(theApp.ILIsFolder(pidlItemTarget)){<br/>            CFolderChange FolderChange;<br/>            FolderChange.m_pidlFolder=pidlItemTarget;<br/>            OnFolderChange(&amp;FolderChange);<br/>        }<br/>        else{<br/>            SHELLEXECUTEINFO ShExecInfo;<br/>            ShExecInfo.cbSize = sizeof(SHELLEXECUTEINFO);<br/>            ShExecInfo.fMask = SEE_MASK_IDLIST;<br/>            ShExecInfo.hwnd = NULL;<br/>            ShExecInfo.lpVerb = NULL;<br/>            ShExecInfo.lpFile = NULL;<br/>            ShExecInfo.lpIDList= pidlItemTarget;<br/>            ShExecInfo.lpParameters = NULL;<br/>            ShExecInfo.lpDirectory = NULL;<br/>            ShExecInfo.nShow = SW_MAXIMIZE;<br/>            ShExecInfo.hInstApp = NULL;<br/>            ShellExecuteEx(&amp;ShExecInfo);<br/>        }<br/>        m_pMalloc-&gt;Free(pidlItemTarget);<br/>        m_pMalloc-&gt;Free(pidlItemFull);<br/>    } <br/>}<br/> </p><h2>性能的优化</h2><p>为了更好的用户体验，可以使用自定义的图标大小（这需要完全自行绘制列表项的图标区域），用单独的线程来载入图像，或者使用调整到图标大小的缩略图缓冲（这样每次绘制时不必拉伸图像）。但是这超出了本文的范围。有兴趣的读者可以自己试一下。</p><h1>参考</h1><p>需要更多信息的话，可以参考</p><ul><li><a href="http://msdn.microsoft.com/library/en-us/shellcc/platform/shell/programmersguide/shell_faq.asp">Shell FAQ</a>  </li>    <li><a href="http://msdn.microsoft.com/library/en-us/shellcc/platform/commctls/listview/listview_overview.asp">List-View Controls Overview</a>  </li>    <li><a href="http://msdn.microsoft.com/library/en-us/shellcc/platform/commctls/listview/listview_using.asp">Using List-View Controls</a>  </li>    <li><a href="http://msdn.microsoft.com/library/en-us/shellcc/platform/commctls/custdraw/custdraw.asp">Customizing a Control's Appearance Using Custom Draw</a></li></ul>                </div>                    </div>
3825	 巧算星期几	算法  数据结构  语言  日历  数据库  编程  	975054720	8206	ycrao	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                         <p class="MsoNormal"><b><i><span style="font-family:'宋体';font-size:16pt;">巧算星期几</span><span lang="en-us" xml:lang="en-us">&lt;?xml:namespace prefix = o ns = "urn:schemas-microsoft-com:office:office" /&gt;</span></i></b></p><p><b><i></i></b></p><b><i></i></b><p class="MsoNormal"><b><i><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></i></b></p><p><b><i></i></b></p><b><i></i></b><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">基姆。拉尔森<span lang="en-us" xml:lang="en-us"></span></span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">基姆拥有计算机学科的博士学位。他对数据库，算法和数据结构有着浓厚的兴趣。他的联系地址是 <span lang="en-us" xml:lang="en-us"><span class="msoDel"><del cite="mailto:wxz"><span>    </span></del></span><span>       </span>（<i>原文为丹麦文－－译者注</i>） 31，DK－5270，Odense N,Denmark,或发 E-mail 至 :kslarsen@imada.ou.dk。</span></span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><i><span style="font-family:'宋体';font-size:9pt;">简介</span></i><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"></span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">布鲁斯 施耐尔<span lang="en-us" xml:lang="en-us"></span></span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">“四，六，九，十一，三十天就齐……”儿歌是这么唱的；或许你也曾经掰着手指头翻来覆去地数，让赶上单数的指头代表只有<span lang="en-us" xml:lang="en-us">30天的短月吧？这样的口诀对我们是很管用的（<ins cite="mailto:wxz">我就是念叨着这首傻乎乎的儿歌</ins><ins cite="mailto:wxz">长大的</ins>），可是电脑就没有这份“灵感”了。当然，我们可以用一大堆IF－THEN－ELSES的语句或几个CASE来编写计算程序，让它计算某个指定日期是星期几。</span></span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">不过我更喜欢基姆拉尔森在本月的“算法小径”中为我们带来的新技巧，因为他的方法另辟蹊径，从一个全新的方向着手解决日期计算的问题。其实，并没有什么数学公式能算出<span class="msoDel"><del cite="mailto:wxz">某个</del></span>指定日期是星期几，不过我们可以试着拼凑一个，如果我们的尝试成功了，你就能拥有一个易于编程的数学公式，并能用它自动计算哪天是星期几了。<span lang="en-us" xml:lang="en-us"></span></span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">顺便说一句，如果你已经设计出更巧妙的算法，或是在已有的方法上有了新突破的话，不妨告诉我，我一定洗耳恭听。我的联系方法是<span lang="en-us" xml:lang="en-us">schneier@chinet.com，或者在DJJ编辑部给我留张便条就行。</span></span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">你有没有<ins cite="mailto:wxz">疑惑</ins>过你的电脑怎么就知道今天是星期三呢？就算你的电脑<ins cite="mailto:wxz">关</ins>机了，你重启后设定了新日期，它也能立即知道这天是星期几。<span lang="en-us" xml:lang="en-us"></span></span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">在你还是个孩子的时候，你可能见过一种<span class="msoDel"><del cite="mailto:wxz">纪录</del></span><ins cite="mailto:wxz">记录</ins>着年，月，日的表格，只要加上几个数字，和它相连的另一张表格就会告诉你这个日期是星期几。当然，计算机硬盘的操作系统里也可以加入这样的计算表。不过有一种简单的方法可以轻松地算出某天是星期几；而且这个方法只占用很少的内存空间，而那些只能推算几百年的表格可就太占地方了。<span lang="en-us" xml:lang="en-us"></span></span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">如果目前你的电脑还不具备推算与日期对应的星期数的功能，现在就不妨在自己的程序中试试下面的公式。<span lang="en-us" xml:lang="en-us"></span></span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"><span class="msoDel"><del cite="mailto:wxz"> </del></span><span class="msoDel"><del cite="mailto:wxz"></del></span></span></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><i><span style="font-family:'宋体';font-size:9pt;">创建公式<span lang="en-us" xml:lang="en-us"></span></span></i></p><p><i></i></p><i></i><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">首先，我们要用变量<span lang="en-us" xml:lang="en-us">D，M和Y来表示日期。比如，1994年3月1日就用“D＝1，M＝3，Y＝4”记录。我们的目标是让计算结果在0到6之间。0代表星期一，1代表星期二，2代表星期三，依此类推。</span></span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us">1994年3月1日是个星期二，那么“D mod 7(日期变量除以7<ins cite="mailto:wxz">的余数</ins><span class="msoDel"><del cite="mailto:wxz">）</del></span><ins cite="mailto:wxz">))</ins><ins cite="mailto:wxz">)</ins>”这个公式对于整个三月份都有效。比如3月18日是星期五，18 mod 7＝4；而4正代表星期五。别忘了，<ins cite="mailto:wxz">整数的除法</ins>和求模有着密切的关系。比方说，26除以7商3余5，这就是说，26除以7商数取整等于3，而26除以7求模（简写为26 mod 7）等于5。以上这些意味着19 mod 7=12 mod 7= 5 mod 7=5。在运算规则中，负数求模<ins cite="mailto:wxz">运</ins>算<span class="msoDel"><del cite="mailto:wxz">法</del></span>相似，所以依此类推，-2 mod 7=5, -9 mod 7=5。</span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">在更正式的表达法中，统一用任意整数<span lang="en-us" xml:lang="en-us">n和k表达上述关系，那么这个过程可以表达为n=qk+r，这里的q和r的取值范围同样是整数和0。<u>表1</u>中列出了所有月份的<span style="color:#FF0000;"><ins cite="mailto:wxz">变换</ins>数据</span><i>（shift information此处试译为“档级数据”，还请进一步校对－－译者注）</i>。为了尽可能地得出规律，二月被排在最后，同理，一月也是如此。</span></span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin-top:12pt;"><u><span style="font-family:'宋体';font-size:9pt;">例<span lang="en-us" xml:lang="en-us">1（a）</span></span></u><span style="font-family:'宋体';font-size:9pt;">中的公式是仿照表<span lang="en-us" xml:lang="en-us">1中的<span style="color:#FF0000;"><ins cite="mailto:wxz">变换</ins>数据</span>栏所描述的模式而创建的。这个公式中的除法一律是商数取整。所以得数是最接近真正商数的整数。表2得出了此功能得出的有趣的数值。凭直觉，我们不难发现，当M(代表月份的变量)的值以1为单位递增时，2M就成倍增长，而3(M+1)/5就以3/5为增长倍数。</span></span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">这正是我们仿制<span lang="en-us" xml:lang="en-us">3,2,3,2,3这个重复格式所需要的（表中右边的弯括号表明了这一点）。请注意，我们在以7为除数求模，那么从6到2的求模结果就会逐个增加3（顺序是6,0,1,2）。</span></span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">现在，我们发现了适用于逐月向下推算的校正方法，并希望把它加入刚才的尝试中，就是那个<span lang="en-us" xml:lang="en-us">mod7公式。还以1994年3月1日为例，这个日期的M＝3。请注意，在例1（b）中，8 mod 7＝1，所以当整个公式合并时，必须减去1。在做以7为除数求模的运算时，减1和加6是一样的，因为-1 mod 7=6 mod 7=6。</span></span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">这样，例<span lang="en-us" xml:lang="en-us">1（c）中的公式就可以计算这一年中剩下的月份了。其实，既然我们把一月和二月排在表1的最后，那么只要我们把它们看成是十三月和十四月，就能接着推算1995年的前两个月了。这是因为，虽然它们并不是一个完整的3,2,3,2,3结构，但恰好可以是这个结构的开始，为了使这个公式更完善，我们还是最好把一月和二月看成是上一年的十三月和十四月。</span></span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><i><span style="font-family:'宋体';font-size:9pt;">加入年份</span></i><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"></span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">顺着年份向下找，我们观察到<span lang="en-us" xml:lang="en-us">1995年3月1日是星期三。这说明，每增加一年，我们公式的计算结果就会增加1。这太简单了，我们只要简单地把年份加上去就行了。再提醒你一次，我们必须确保出发点是正确的。由于1994 mod 7=6，我们在把Y加入已有的公式时就必须减去6。由此改进的例2(a)就更完善了。</span></span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us">1996年是个闰年，这带来了我们的下一个问题。这一年的3月1日是星期五，而不是刚才的公式推算出的星期四。所以每当我们碰上闰年时还得多加上1。判断闰年的规则是，能被4整除，并能被100和400同时整除的年份就是闰年。就这样，我们在原有的基础上添加Y/4--Y/100+Y/400。再强调一下，我们必须从一开始就确保正确。既然(1994/4--1994/100+1994/400) mod 7=(498--19+4) mod 7=483 mod 7=0,所以就不用再做任何调整了。这样，例2(b)就是我们最终的成果了。这个公式能一直工作下去，除非改变现行的日历系统。作为示例，让我们试着推算一下2000年7月4日：(4+2*3+(7+1)/5+2000+2000/4--2000/100+2000/400) mod 7= (4+14+2000+500--20+5) mod 7=2507 mod 7=1，所以那一天是星期二。</span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">这个公式还能推算过去的日期；然而计算范围有限，让我们看看<span lang="en-us" xml:lang="en-us">1752年9月14号这个星期四吧，我们的公式最远只能推算到这里了。不过像“1963年11月22日你在哪里”这样的日常问题中提到的日期还是可以轻松应对的：(22+2*11+3(11+1)/5+1963+1963/4--1963/100+1963/400) mod 7=(22+22+7+1963+490--19+4) mod 7=2489 mod 7=4。那天就是星期五。</span></span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">例<span lang="en-us" xml:lang="en-us">3<ins cite="mailto:wxz">例子3是一个</ins><ins cite="mailto:wxz">C语言程序，按照</ins><span class="msoDel"><del cite="mailto:wxz">把</del></span>这个公式自动推算<ins cite="mailto:wxz">给定日期是</ins>星期<ins cite="mailto:wxz">几</ins>。</span></span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"><span class="msoDel"><del cite="mailto:wxz"> </del></span><span class="msoDel"><del cite="mailto:wxz"></del></span></span></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"><span class="msoDel"><del cite="mailto:wxz"> </del></span><span class="msoDel"><del cite="mailto:wxz"></del></span></span></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">表<span lang="en-us" xml:lang="en-us">1：每月<span style="color:#FF0000;"><ins cite="mailto:wxz">变换</ins>数据</span></span></span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">月份<span lang="en-us" xml:lang="en-us"><span>         </span>天数<span>       </span><span>  </span><span style="color:#FF0000;"><ins cite="mailto:wxz">变换</ins></span></span></span></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">三月<span lang="en-us" xml:lang="en-us"><span>          </span>31<span>            </span>3</span></span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">四月<span lang="en-us" xml:lang="en-us"><span>          </span>30<span>            </span>2</span></span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">五月<span lang="en-us" xml:lang="en-us"><span>          </span>31<span>            </span>3</span></span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">六月<span lang="en-us" xml:lang="en-us"><span>          </span>30<span>            </span>2</span></span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">七月<span lang="en-us" xml:lang="en-us"><span>          </span>31<span>            </span>3</span></span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">八月<span lang="en-us" xml:lang="en-us"><span>          </span>31<span>            </span>3</span></span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">九月<span lang="en-us" xml:lang="en-us"><span>          </span>30<span>            </span>2</span></span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">十月<span lang="en-us" xml:lang="en-us"><span>          </span>31<span>            </span>3</span></span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">十一月<span lang="en-us" xml:lang="en-us"><span>        </span>30<span>            </span>2</span></span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">十二月<span lang="en-us" xml:lang="en-us"><span>        </span>31<span>            </span>3</span></span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">一月<span lang="en-us" xml:lang="en-us"><span>          </span>31<span>            </span>3</span></span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">二月<span lang="en-us" xml:lang="en-us"><span>          </span>28<span>            </span>3</span></span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"><span class="msoDel"><del cite="mailto:wxz"> </del></span><span class="msoDel"><del cite="mailto:wxz"></del></span></span></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"><span class="msoDel"><del cite="mailto:wxz"> </del></span><span class="msoDel"><del cite="mailto:wxz"></del></span></span></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">表<span lang="en-us" xml:lang="en-us">2：仿制<span style="color:#FF0000;"><ins cite="mailto:wxz">变换</ins>数据</span>形式的功能。例1中建立的公式可以适用于1994年。例2把这个公式的功能扩展到可以应用在不同的年份进行推算。</span></span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span style="font-family:'宋体';font-size:9pt;">例<span lang="en-us" xml:lang="en-us">3：用C语言程序表达上述公式</span></span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us">/*计算指定日期是星期几。默认输入的*/</span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us">/*数字代表正确的日期*/</span></p><p></p><pre><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz">/* </ins></span><span style="font-size:9pt;"><ins cite="mailto:wxz">推算给定日期是星期几，假定输入是正确的数据</ins></span><span style="font-family:'宋体';font-size:9pt;"><ins cite="mailto:wxz"> </ins></span><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz">*/</ins></span></pre><pre><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz">#include </ins></span></pre><pre><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz">char *name[] = { "Monday",</ins></span></pre><pre><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz"><span>                 </span>"Tuesday",</ins></span></pre><pre><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz"><span>                 </span>"Wednesday",</ins></span></pre><pre><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz"><span>                </span>"Thursday",</ins></span></pre><pre><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz"><span>                </span>"Friday",</ins></span></pre><pre><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz"><span>                </span>"Saturday",</ins></span></pre><pre><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz"><span>                </span>"Sunday"</ins></span></pre><pre><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz"><span>               </span>};</ins></span></pre><pre><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz">void main(){</ins></span></pre><pre><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz"><span>  </span>int D,M,Y,A;</ins></span></pre><pre><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz"><span>  </span>printf("Day: "); fflush(stdout);</ins></span></pre><pre><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz"><span>  </span>scanf("%d",&amp;D);</ins></span></pre><pre><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz"><span>  </span>printf("Month: "); fflush(stdout);</ins></span></pre><pre><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz"><span>  </span>scanf("%d",&amp;M);</ins></span></pre><pre><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz"><span>  </span>printf("Year: "); fflush(stdout);</ins></span></pre><pre><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz"><span>  </span>scanf("%d",&amp;Y);</ins></span></pre><pre><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz">/* January and February are treated as month 13 and 14, */</ins></span></pre><pre><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz">/* respectively, from the year before.<span>                  </span>*/</ins></span></pre><pre><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz"><span>  </span>if ((M == 1) || (M == 2)){</ins></span></pre><pre><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz"><span>    </span>M += 12;</ins></span></pre><pre><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz"><span>    </span>Y--;</ins></span></pre><pre><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz"><span>  </span>}</ins></span></pre><pre><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz"><span>  </span>A = (D + 2*M + 3*(M+1)/5 + Y + Y/4 - Y/100 + Y/400) % 7;</ins></span></pre><pre><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz"><span>  </span>printf("It's a %s./n",name[A]);</ins></span></pre><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"><ins cite="mailto:wxz">}</ins></span><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"><ins cite="mailto:wxz"></ins></span></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"><span class="msoDel"><del cite="mailto:wxz"> </del></span><span class="msoDel"><del cite="mailto:wxz"></del></span></span></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us">/*一月和二月被当作前一年的*/</span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us">/*十三月和十四月分别处理*/<span class="msoDel"><del cite="mailto:wxz"></del></span></span></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"><ins cite="mailto:wxz"> </ins></span></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"><span class="msoDel"><del cite="mailto:wxz"> </del></span><span class="msoDel"><del cite="mailto:wxz"></del></span></span></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';font-size:9pt;" xml:lang="en-us"> </span></p><p></p>                </div>                    </div>
3998	 让ListBox控件支持拖动	file  construction  attributes  代码分析  macros  insert  	996806760	881	heyongzhou	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        通常我们通过ListBox控件来显示我们的信息列表，然后我们可以通过鼠标来选择我们的条目信息，但VC中的ListBox控件是不支持拖动的。也许我们有时需要改变我们的列表顺序，已适应我们的要求，下面是实现的方法。<br/><br/>　　<b>设计思路：</b><br/><br/><br/>　　1． 如果通过鼠标左键选中某一条目并拖动，此时我们通过变量记录当前选中条目的位置和条目字符串以及此条目的副值。<br/><br/>　　2． 鼠标移动到要移动到的位置后放开左键，此时我们把以前选中的条目插入到此处，同时，删掉原位置的条目。<br/><br/>　　<b>实现步骤：</b><br/><br/>　　1. 定义一个从ClistBox类扩展的类CMyListBox，代码下面分析。<br/><br/>　　2. 通过新类定义我们的列表控件变量。<br/><br/>　　代码分析：<br/><br/><br/><table align="center" border="0" cellpadding="0" cellspacing="0" width="500"><tbody><tr bgcolor="#ebe9eb"><td><b>// MyListBox.h : header file<br/>// <br/>// CMyListBox window<br/><br/>class CMyListBox : public CListBox<br/>{<br/>　// Construction<br/>　public:<br/>　CMyListBox();<br/><br/>　// Attributes<br/>　private:<br/>　　BOOL m_LButtonDownFlag;<br/>　　BOOL m_MouseMoveFlag;<br/>　　int m_OldPosition;<br/>　　int m_NewPosition;<br/>　　CString m_DragString;<br/>　　DWORD m_ItemData;<br/>　public:<br/><br/>　　// Operations<br/>　public:<br/><br/>　　// Overrides<br/>　　// ClassWizard generated virtual function overrides<br/>　　file://{{AFX_VIRTUAL(CMyListBox)<br/>file://}}AFX_VIRTUAL<br/><br/>　// Implementation<br/>　public:<br/>　　virtual ~CMyListBox();<br/><br/>　　// Generated message map functions<br/>　protected:<br/>　　file://{{AFX_MSG(CMyListBox)<br/>　　afx_msg void OnLButtonDown(UINT nFlags, CPoint point);<br/>　　afx_msg void OnLButtonUp(UINT nFlags, CPoint point);<br/>　　afx_msg void OnMouseMove(UINT nFlags, CPoint point);<br/>　　// NOTE - the ClassWizard will add and remove member functions here.<br/>file://}}AFX_MSG<br/><br/>　DECLARE_MESSAGE_MAP()<br/>};<br/><br/>file://{{AFX_INSERT_LOCATION}}<br/><br/>　#endif // 　!defined(AFX_MYLISTBOX_H__CF3EDAA5_BBD7_43CD_80CB_A86B65D9A607__INCLUDED_)<br/><br/><br/>　// MyListBox.cpp : implementation file<br/>　file://<br/><br/>　#include "stdafx.h"<br/>　#include "sditest.h"<br/>　#include "MyListBox.h"<br/>　<br/>　#ifdef _DEBUG<br/>　#define new DEBUG_NEW<br/>　#undef THIS_FILE<br/>　static char THIS_FILE[] = __FILE__;<br/>　#endif<br/><br/>　// CMyListBox<br/><br/>　CMyListBox::CMyListBox()<br/>　　{<br/>　　　m_LButtonDownFlag = FALSE;<br/>　　　m_MouseMoveFlag = FALSE;<br/>　　}<br/><br/>　CMyListBox::~CMyListBox()<br/>　　{<br/>　}<br/><br/><br/>　BEGIN_MESSAGE_MAP(CMyListBox, CListBox)<br/>　file://{{AFX_MSG_MAP(CMyListBox)<br/>　ON_WM_LBUTTONDOWN()<br/>　ON_WM_LBUTTONUP()<br/>　ON_WM_MOUSEMOVE()<br/>　// NOTE - the ClassWizard will add and remove mapping macros here.<br/>　file://}}AFX_MSG_MAP<br/>END_MESSAGE_MAP()<br/><br/>　// CMyListBox message handlers<br/>　void CMyListBox::OnLButtonDown(UINT nFlags, CPoint point) <br/>　　{<br/>　　　CListBox::OnLButtonDown(nFlags, point);<br/>　　　file://如果选中一个条目，此时进行处理，否则会出错。<br/>　　if(GetCurSel() != -1)<br/>　　　m_LButtonDownFlag = TRUE;<br/>　　}<br/><br/>　void CMyListBox::OnLButtonUp(UINT nFlags, CPoint point) <br/>　　{<br/>　　　CListBox::OnLButtonUp(nFlags, point);<br/>　　　m_LButtonDownFlag = FALSE;<br/>　　　if(m_MouseMoveFlag)<br/>　　　{<br/>　　　　m_MouseMoveFlag = FALSE;<br/>　　　　POINT pt;<br/>　　　　::GetCursorPos(&amp;pt);<br/>　　　　CRect iRect;<br/>　　　　this-&gt;GetWindowRect(iRect);<br/>　　　　if(iRect.PtInRect(pt))//确定鼠标移动到了合适的位置<br/>　　　　{<br/>　　　　　m_NewPosition = GetCurSel();<br/>　　　　　if(m_NewPosition &lt; m_OldPosition)<br/>　　　　　{<br/>　　　　　　InsertString(m_NewPosition,m_DragString);<br/>　　　　　　DeleteString(m_OldPosition+1);<br/>　　　　　　this-&gt;SetCurSel(m_NewPosition);<br/>　　　　　　file://设置移动条目的副值，如果删除或者添加一条记录，副值会随字符串一起移动<br/>　　　　　　SetItemData(m_NewPosition,m_ItemData);<br/>　　　　　　TRACE("%d%d%d%d%d%d%d%d",GetItemData(0),GetItemData(1),_<br/>GetItemData(2),GetItemData(3),GetItemData(4),_<br/>GetItemData(5),GetItemData(6),GetItemData(7));<br/>}<br/>　　　　　else<br/>　　　　　　{<br/>　　　　　　　InsertString(m_NewPosition+1,m_DragString);<br/>　　　　　　　DeleteString(m_OldPosition);<br/>　　　　　　　this-&gt;SetCurSel(m_NewPosition);<br/>　　　　　　　SetItemData(m_NewPosition,m_ItemData);<br/>　　　　　　　TRACE("%d%d%d%d%d%d%d%d",GetItemData(0),GetItemData(1),_<br/>GetItemData(2),GetItemData(3),GetItemData(4),_<br/>GetItemData(5),GetItemData(6),GetItemData(7));<br/>}<br/>　　　　　}<br/>　　　}<br/><br/>　　}<br/><br/>　　void CMyListBox::OnMouseMove(UINT nFlags, CPoint point) <br/>　　　{<br/>　　　　CListBox::OnMouseMove(nFlags, point);<br/>　　　　if(m_LButtonDownFlag)<br/>　　　　{<br/>　　　　　m_MouseMoveFlag = TRUE;<br/>　　　　　m_OldPosition = GetCurSel();<br/>　　　　　GetText(m_OldPosition,m_DragString);<br/>　　　　　try{<br/>　　　　　　m_ItemData = GetItemData(m_OldPosition);<br/>　　　　　}<br/>　　　　catch(...)<br/>　　　　{<br/>　　　　　AfxMessageBox("Wrong!");<br/>　　　　}<br/><br/>　　　　m_LButtonDownFlag = FALSE;<br/>　　　　SetCursor(AfxGetApp()-&gt;LoadCursor(IDC_CURSOR1));<br/>　　　}<br/>　　}<br/></b></td></tr></tbody></table><br/>　　实现了上面的代码后，我们就可以在列表框中随便改变我们的条目的顺序了，赶快试一下吧！在例程中弹出关于对话框，在列表中就可以改变顺序了。<br/>                </div>                    </div>
4092	 如何分析问题和需求？如何界定问题主次？。。。。	数据结构  扩展  产品  图形  工作  任务  	982746960	1209	yoursoft	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <font color="#000000"></font><h1 align="center">如何分析问题和需求</h1><p align="center"> </p><p><font size="2">        万事开头难，需求没有完全分析清楚，系统设计很难满意。面对项目，我们如何提出问题，如何界定问题主次，哪些问题必须定义，哪些问题可暂时不理......。</font></p><p><font size="2">                                                                                                                                  （梦郎个人观点）</font></p><p>一、提出问题<br/>１.树状遍历式寻找问题<br/>　　每个问题都不是单一存在的，它都有相关问题，犹如一棵树一样，主问题就是主树杆，主问题伴随的其他问题，就是支树杆，以次类推。首先不要怕麻烦，每当一个问题提出，必须提出尽量多的相关新问题。提出问题的方法：顺藤摸瓜。<br/>　　比如：写一个通用编辑器程序，此程序为自己或别人开发其他专业编辑器打下可靠稳定的基础。<br/>　　１）问题：什么是通用编辑器。编辑器面向的对象应该是不确定的。<br/>　　２）如果数据类型不确定，我们如何确定程序编写的对象。可以举出一些可能的假设。假设我们将此通用编辑器用作程序源代码编辑，那么就应该有中断、单步执行等设置，这导致数据不能封装在编辑器内部，应该由后期开发指定数据结构。<br/>　　３）如果是程序编辑器，关键字的特显必不可少，所以显示的属性应该给出接口。<br/>　　４）诸如关键字此类的是否还有其他需要特显的，那么，应该注意到特显类不仅仅是一种，程序设计时，最好抽象出特显的方法与数据结构（不管以后有多少不可预知的特显内容）。可以深入考虑特显接口应该如何给出，才能支持任意特显方式，它还需要哪些信息。<br/>　　５）抽象特显类时，应该举出尽量多的可能性，综合考虑。<br/>　　６）问题：哪些内容需要特显。编辑器很难知道，数据类应该自己了解。所以，特显内容的定义必须有一个机制让后期开发时使用。<br/>　　７）问题：源代码编辑器有自动缩排、词法、语法分析，这些操作如何在编辑器中体现。考虑语法类接口。是否有收缩与展开操作，接口又如何。<br/>　　８）又假设：后期要扩展成字处理程序。数据有文本、图象、特殊公式编辑、段落概念、表格等。<br/>　　９）送进编辑器的数据可能是一组含有控制字的数据，问题：如何获得让编辑器知道不同数据的不同显示操作。编辑器肯定无法全知，所以，干脆交给后期开发需求处理。<br/>　　１０）未知数据应该有：显示方法、光标定位处理等<br/>　　１１）光标定位需要当前坐标，所以，必须有接口让编辑器知道数据宽高。<br/>　　１２）综合结论：应该有一个接口机制。凡特殊操作的内容，交给后期处理，但通用编辑器应该做好数据管理和传送的工作，而这些工作，不管哪种编辑器都需要。<br/>　　首先任其深入提问，虽然问题可能多得十分复杂或凌乱，但它对即将做的系统设计绝对有帮助，最好把每个问题都有一个清楚的了解，千万不要急于设计系统。通过这些提问和假设，就可清楚地分析我们所作的软件应该实现哪些内容，哪些内容实现有难度，实现这些内容的大体方法，通用编辑器能作什么。通过上列系列提问和解答，我们可以认为，通用编辑器仅仅是一个以行为基本编辑单位的编辑器摸板。编辑器不仅自己有编辑操作，同时允许外部提供特殊数据对象的编辑操作，最终实现文本编辑、图形编辑、表格编辑、公式编辑一体化。数据外部实现，将允许后期确定内容属性。<br/>　　上述方法基本上确保了软件有好的可靠性、扩展能力、性能、重用性和系统化。想高效率生产系列软件，确实应该考虑的更多。<br/><br/>２.直接切入目标问题<br/>　　直接提出软件要完成的系列任务，通过考虑任务的实现，罗列问题，在问题的解答过程中反思任务的需求。这样的方法可以快速设计出软件开发方案。<br/>　　仍然以通用编辑器为例：<br/>　　１）编辑对象有：文本、图形、图象、表格等。<br/>　　２）操作有：焦点移动、增加、删除、存取盘、选择块、粘贴拷贝、缩进、展开收缩、书签、中断设置、单步执行标记等。操作有分文本、图形图象、表格等的操作编辑。<br/>　　３）显示：文本的不同字体风格显示、图形的显示、图象的显示、表格等的显示。<br/>　　４）状态设置：改写插入、段落格式设置、标题控制、编辑器专业化的设置等<br/>　　５）考虑各项功能的实现方案，发现问题。<br/>　　６）如果有没有考虑到的，增加进去。<br/>　　７）经过许多的方案设计，综合考虑和优化方案，提出最后的设计方案<br/>　　８）综合结论：程序考虑了诸多功能，通用编辑器是众多功能的集合体，内部详细规划了各种类型数据的操作、显示和排版分析。<br/>　　经过一系列的方案定义，将问题逐步减少，最后获得一个规模较大的系统设计早期方案。我们可以较早地进入系统设计，并且提前进入程序代码级开发工作，同时逐步实现各项内容。<br/>　　此方法分析需求，有助于我们尽早实现想法，同时较好地控制住程序开发方向和基本功能完成的进度。但遗憾的是提高开发速度的代价是降低程序的可靠性、扩展性和重用性。过去，我们往往觉得所作的程序基本上不能再次使用，原因就在于没有抽象问题，寻找问题的根本解决方案。就问题实现问题的方法，忽略了深入分析问题的过程。对于针对开发某专业的应用软件采用此方法分析需求比较合适，但对系统性强的软件，最好采用树状遍历式寻找问题的方法。<br/><br/>二、分析问题和需求<br/>　　在没有分析清楚问题和需求的来由就匆匆下定论是非常危险的。忽略问题和需求就可能埋下了潜在的程序或系统设计问题。我们也常常犯这样的错误：由于没有分析清楚问题和需求，结果到头来更改系统设计。能够提出的问题和需求，就一定要扎扎实实分析它，否则后果难料。<br/>　　分析问题和需求的能力大小与思路和经验有关。好的思路来源于严谨、逻辑和跳跃的思考习惯。严谨要求不要放过任何一个小问题，逻辑要求思考的过程应该是一种符合规则的推导过程，跳跃思维要求思考的路子不是一走到底而是多条路子并行着走。经验来自于编写调试大量程序和善于总结，要求程序员不断地开发新程序和创造新思路，并且敢于尝试和接受失败，当然还有一条重要的方面：跟踪最新技术。<br/>　　如何正确分析问题，有以下几个要素值得注意：<br/>１.所有问题和需求都有发生的根源。<br/>　　问题和需求的表面现象总是与开发者思路切入点相关，如果切入点是狭隘的，那么围绕着问题和需求的分析往往局限于自身的思路范围，问题和需求产生的原因就很难发觉。所以当不能理解分析问题和需求时，不妨先找一找为什么存在这样的问题和需求，它的存在是否合理，然后再分析理解它就不难了。思路一定要跳出惯例。<br/>２.交替反复分析多个问题和需求，寻找问题间的共性和特性<br/>　　看似问题和需求间没有联系，而且分析不清各自意义，那么建议交替反复分析考虑这些问题。勤能补拙，不要担心它将花费开发者多少时间，只有开发者仔细分析问题需求，以后的工作越来越简单明了。<br/>３.复杂化问题，<br/>　　问题复杂化，是一个抽象问题或需求的逆过程，提出问题需求的许多可能的假设，丰富了问题需求的形式。能够复杂化问题，本身就体现了分析问题和需求的能力。比如：做一个加法程序，两个数相加，返回结果。简单的问题，但，我们一般都按两整数加法，有时考虑了浮点加法。为什么不是两个复数相加，或者是两个字符串相加等。这是一个使用操作符重载或类模板解决的简单例子，在这里我的意图是许多问题应该从更多的方面去验证问题是否同样存在。<br/>４.问一问自己：问题是否能够抽象化，继而简化问题。<br/>　　众多的问题和需求变成程序代码的过程，就是公式化问题和需求。如果象上例加法一样，不管三七二十一，什么样的数据就写一段什么的代码，不同类型数据间的加法同样又要写一段代码，这样下去就写不完了。抽象问题，简化问题，类模板就是一个抽象问题很好的例子。在分析问题和需求的过程中，同样采用面向对象的思维方式去求解，会获得一个非常满意的需求报告。<br/>５.问题和需求分类分主次考虑<br/>１）软件产品的性能指标：可靠、功能全、速度、易扩展。<br/>　　易扩展：一种是产品升级换代快、系列化产品丰富。另一种是用户的二次开发扩展产品的再生功能。<br/>　　速度：表示软件执行速度不仅要快，同时操作中的速度要均衡。<br/>　　功能全：大而全不一定是不好，有能力和实力，最好做到功能尽量全。功能全直接体现软件开发商的实力。<br/>　　可靠：这是最为重要的一点，软件首要考虑的应该是可靠。测试时，极限、异常操作都应该考虑进去。<br/>２）问题和需求根据软件产品的性能指标和实现难度分类：核心需求，基本功能需求，高级功能需求、组合功能需求。<br/>　　核心需求：直接影响速度、可靠、易扩展指标的好坏。比如：ＣＡＤ刷屏要求速度、ＣＡＤ命令行机制提高了易扩展性能、ＣＡＤ内部数据结构的管理机制直接影响软件的可靠性。核心需求将定义出软件的本质内容，它主要以程序设计原理为基础，结合软件任务需求定义数据结构和管理机制。核心需求是首先要确定下来的，是最主要的工作。<br/>　　基本功能需求：完成任务的最基本的操作功能集合，这些基本功能是软件产品的底层处理功能，是众多问题和需求中抽象出的共性部分，它是其他功能的基础。基本功能需求也是非常重要的，它的好坏直接影响到后面高级功能的质量和能力。<br/>　　高级功能：是众多问题和需求中的特性部分，这些功能对某个应用是非常有用，但在另一个应用中可能没有用。比如：ＣＡＤ中的图形计算：求面积或体积，在建筑施工图设计中没有使用，但在计算路基方面则非常有用。高级功能的需求应该放在较次要的位置，<br/>　　组合功能：通过基本功能和高级功能组合操作后的功能。例如：ＣＡＤ中的ＬＩＳＰ语言，ＣＡＤ的批命令输入，ＣＡＤ的图块功能等。这些借助于基本功能和高级功能的组合功能是一种后期行为，没有这些功能，软件一样可以使用，所以，这些需求开发并不需要急于实现，但一定要在核心中考虑组合机制。<br/><br/>　　总之，需求分析是导致软件产品好坏的关键工作，导致软件开发难易程度大小的绝对因数。宁可将需求分析的时间给充足一些，也不愿以后在编程阶段补充修改需求（虽然修改需求是不可避免的事实）。</p><p align="right"><font color="#000000">梦郎<br/></font></p>                </div>                    </div>
4096	 中国人自己的开发语言HB++<语句介绍>	语言  function  module  class  struct  vb.net  	992855220	1053	yoursoft	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <h3>这些是基本的开发语言语句,HB++对面向对象作了不少支持工作,在这方面,比VB.NET最新版的面向对象支持方面更加出色.这里将分段介绍HB++,供同行业朋友指正和帮助</h3><h3>3.2 语句</h3><h4>1. 顺序语句</h4><h5>a) 赋值语句</h5><dl><dt>    Let基本类型赋值语句 <br/>    [Let] 变量名 | 类成员变量名 = 表达式 <br/>    Set非基本类型赋值语句 <br/>    Set 变量名 | 类成员变量名 = 表达式 <br/>    Set 变量名 | 类成员变量名 = New 非基本类型名[(构造时的参数表)] </dt></dl><h5>b) 调用函数</h5><dl><dt>    Call调用函数语句 <br/>    [Call] 函数名 | 类成员函数名(参数表) <br/>    即使函数有返回值，使用Call语句后，返回值将自动丢失。如果返回的是类实例，HB++将自动释放类实例空间。 </dt></dl><h4>2. 条件语句</h4><p>  a)If语句 <br/>    If语句标准格式： <br/>        If 逻辑表达式 Then <br/>        [Else If 逻辑表达式 Then] <br/>        [Else] <br/>        End If <br/>    b)Select语句 <br/>      Select语句标准格式： <br/>        Select 算术表达式 <br/>        Case 逻辑表达式 <br/>        [Case Else] <br/>        End Select <br/>      注意：此处的逻辑表达式的第一个逻辑运算符不需要左边的算式。例如： <br/>        Dim a As Long </p><p>        a=10 <br/>        Select a+3 <br/>        Case &lt;2 <br/>        Case &gt;2 And a+3&lt;10 <br/>        Case &gt;10 And a+3&lt;100 <br/>        CaseElse <br/>        End Select </p><h4>3. 循环语句</h4><h5>a)For循环语句</h5><dl><dt>    标准格式： <br/>     For 循环变量 = 初始值 To 终止值 [Step 步长值] <br/>        Next 循环变量 <br/>    循环变量只能是单独的变量，不能是类的成员属性或函数。步长值缺省值等于1。 <br/>Next语句的循环变量一定要与For语句中的循环变量相同。 <br/>    Exit For语句将跳出循环 </dt></dl><h5>b)ForSet集合专用循环语句</h5><dl><dt>    ForSet 集合变量 <br/>    NextSet <br/>    集合变量只能是集合类的实例变量。其初始值是集合的第一个元素。此循环将自动从第一个元素循环道集合的最后一个元素。循环体中直接使用集合变量操作元素内容。 <br/>    Exit For语句将跳出循环 </dt></dl><h5>c)Do While...Loop当条件为真循环语句</h5><dl><dt>    Do While 逻辑表达式 <br/>    Loop <br/>    条件先于循环，当外部进入循环时，条件不成立，循环将跳过。 <br/>    Exit Do语句将跳出循环 </dt></dl><h5>d)Do Until...Loop当条件为真跳出循环语句</h5><dl><dt>    Do Until 逻辑表达式 <br/>    Loop <br/>    条件先于循环，当外部进入循环时，条件成立，循环将跳过。 <br/>    Exit Do语句将跳出循环 </dt></dl><h5>e)Do...Loop While后判断当条件为真循环语句</h5><dl><dt>    Do <br/>    Loop While 逻辑表达式 <br/>    条件后于循环，当外部进入循环时，至少循环一遍，然后判断条件是否成立，如果成立，循环将跳出。 <br/>    Exit Do语句将跳出循环 </dt></dl><h5>f)Do...Loop Until后判断当条件为真跳出循环语句</h5><p>    Do <br/>    Loop Until 逻辑表达式 <br/>    条件后于循环，当外部进入循环时，至少循环一遍，然后判断条件是否成立，如果不成立，循环将跳出。 <br/>    Exit Do语句将跳出循环 </p><h4>4. 定义语句</h4><h5>a)Function函数定义语句</h5><p>    标准格式： <br/>      [Virtual] [Public | Private]Function 函数名([[ByVal | ByRef] 参数名 As 类型名][，[ByVal | ByRef] [Optional] 参数名 As 类型名[= 常量表达式]]...) As 类型名 <br/>      End Function <br/>    函数名：必选，必须是有效字母：26个大小写英文字母、10个数字、下划线、所有中文，第一个字母必须是英文字母或中文、下划线； <br/>    参数名：同变量名； <br/>    类型名：基本数据类型、非基本数据类型（对象类）、类模板类型； <br/>    [Virtual]：虚拟函数定义，仅仅只能在类的成员函数中定义； <br/>    [Public | Private]：可选，公有私有说明； <br/>    [ByVal | ByRef]：可选，参数按值或按地址传。缺省是按地址传ByRef； <br/>    [Optional]：可选，表示此参数可以写可以不写，即可选参数。可选参数可以对其给一个缺省值，方法是在其定义后跟一个等号和常量算式。 <br/>    [= 常量表达式]：可选，当前面定义的参数是可选参数时，才能使用缺省值定义。常量表达式中不能使用变量。 <br/>    End Funciton：结束函数定义 </p><h5>b)Class类自定义语句</h5><p>    标准格式： <br/>      Class 自定义的类型名 [From 已有的对象类型名] <br/>      End Class <br/>    自定义的类型名同变量名的字母组成，自定义类型名不能与已有类型名相同。此类型将是对象类。 <br/>    [From 已有的对象类型名]：From继承语句，说明自定义类型是需要从已有的对象类型继承过来的。 <br/>    类型定义必须放在模块定义的内部 </p><h5>c)Module模块定义语句</h5><p>    标准格式： <br/>      Module 模块名 <br/>      End Module <br/>    模块内部将可以定义以下内容： <br/>      自定义对象类型、全局变量、全局函数、模块内局部变量、模块内局部函数。 <br/>    模块内部不能定义窗口类，窗口类是独立与所有定义形式。 <br/>    模块定义的内容必须在同一个文件中。 <br/>    模块定义的内容缺省是全局的。 </p><h5>d)Form窗口类定义语句</h5><p>    标准格式：<br/>      Form 窗口类       End Form<br/>    HB++中，Form语句定义的窗口类将在编译后执行前自动创建一个窗口实例，并创建一个全局的静态变量：窗口类。<br/>    在Form...End Form中定义的所有内容，都将是此窗口的成员属性或方法或事件。<br/>    窗口中插入控件的方法很简单，如下面例子：（由于还没有开发完可视化编程部分，所以暂可以使用以下方式）<br/>      Form 窗口类<br/>        Public withEvent button as TButton<br/>        public withEvent treeView as TTReeview<br/>        public withEvent edit as TText<br/>        public withEvent coolBar as TCoolBar<br/>       End Form<br/>    上面例子中，窗口中将自动被插入了一个按钮、显示树、编辑框、工具条。当没有定位，如果想定位，继续写下窗口类的构造函数，在构造函数中将各控件定位。定位方法可以是赋值给Left、Top、Width、Height或指定Align方式定位。<br/>    窗口只有当程序结束时才会被自动释放，如果希望强制释放删除，将上例的窗口类置空即可：<br/>          Set 窗口类 = NULL<br/>    其他对象类的强制释放删除同样如此。 </p><h5>e)TypeDef类型别名定义语句</h5><p>    标准格式：<br/>      TypeDef 已有类型名类型的别名<br/>    已有类型名可以是任何HB++的类型（包括类模板）。<br/>    类型别名的使用方法与类型名相同，虽然它不是一个新的类型，但与它指向的类型完全相同。 </p><h5>f)Struct结构类型定义语句</h5><p>    标准格式：<br/>      Struct 结构名 From 已有的类型名<br/>      End Struct<br/>    在HB++中，Struct和Class的定义几乎完全一样，使用时可以当成一种方式使用。 </p><h5>g)Dim变量定义语句</h5><p>    标准格式：<br/>      Dim 变量名[(数组大小)] As [New] 类型名 [&lt;类型参数表&gt;][，变量名 As [New] 类型名 [&lt;类型参数表&gt;]...]<br/>    变量名：动态变量名称；<br/>    [(数组大小)]：可选，定义数组；<br/>    类型名：HB++所有类型名；<br/>    [&lt;类型参数表&gt;]：可选，如果类型是类模板，此处的类型参数表将是此类模板所需的类参数。参数最多可以是十个。 </p><h5>h)Static静态变量定义语句</h5><p>    标准格式：<br/>      Static 变量名[(数组大小)] As [New] 类型名 [&lt;类型参数表&gt;][，变量名 As [New]类型名 [&lt;类型参数表&gt;]...]<br/>    变量名：静态变量名称<br/>    其他同Dim定义语句说明。 </p><h5>i)Public公有变量定义语句</h5><p>    标准格式：<br/>      Public [Static] 变量名[(数组大小)] As [New] 类型名 [&lt;类型参数表&gt;][，变量名 As [New] 类型名 [&lt;类型参数表&gt;]...]<br/>    变量名：公有变量名称<br/>    使用Static说明变量是公有的静态变量，不使用的缺省是动态标量。<br/>    其他同Dim定义语句说明。 </p><h5>j)Private私有变量定义语句</h5><p>    标准格式：<br/>      Private [Static] 变量名[(数组大小)] As [New] 类型名 [&lt;类型参数表&gt;][，变量名 As [New] 类型名 [&lt;类型参数表&gt;]...]<br/>    变量名：私有变量名称<br/>    使用Static说明变量是私有有的静态变量，不使用的缺省是动态标量。<br/>    其他同Dim定义语句说明。<br/><br/>    注意：在变量定义中，如果是对象类型的变量，可以使用New来直接创建类实例，但New不能在类属性定义中使用。<br/>    如果变量定义中没有使用New，可以在执行程序体中使用New语句来创建对象类。例如：<br/>           Dim a as TForm<br/>           Set a = New TForm </p><h4>5. 事件定义语句</h4><h5>a)Event事件定义语句</h5><p>    标准格式：<br/>      Event 事件函数名([[ByVal | ByRef] 参数名 As 类型名][，[ByVal | ByRef] [Optional] 参数名 As 类型名[= 常量表达式]]...)<br/>    Event事件定义语句定义了事件函数的函数名和参数形式。<br/>    Event语句必须在类定义中使用。<br/>    当定义类实例的此事件函数时，事件函数名定义格式如下：<br/>        类实例变量名_事件函数名<br/>    例如：<br/>      Module 例子模块<br/>        Class 例子类<br/>          Pulic Event Over(ByVal X as Long,ByVal  Y as Long)<br/>          Public OldX as Long,OldY as Long<br/>          Function  Line(ByVal X as Long,ByVal Y as Long)<br/>            RaiseEvent Over(X,Y)<br/>            窗口类.Line(OldX,OldY,X,Y)<br/>          End Function<br/><br/>          '预先定义事件过程函数的方法：<br/>          '有了预先定义的事件函数，此类的类实例在创建构造后，自动拥有此事件函数的处理过程。<br/>          Function _Over(ByVal X as Long,ByVal  Y as Long)<br/>            if X&gt;0 And X &lt;100 And Y&gt;0 And Y&lt;150 Then<br/>              Msgbox ("进入此区域有效！")<br/>            end if<br/>          End Function<br/><br/>        End Class<br/>      End Module<br/>      Form 窗口类 From TForm<br/>        Public withEvent b as TButton<br/>        Punlic c as 例子类<br/>        Public withEvent d as 例子类<br/><br/>        function b_Click()<br/>        end Function<br/><br/>        Function c_Over(ByVal X as Long,ByVal  Y as Long)<br/>          if X&gt;100 And X &lt;200 And Y&gt;150 And Y&lt;300 Then<br/>            Msgbox ("不能进入此区域！")<br/>          end if<br/>        End Function<br/>      End Form </p><h5>b)RaiseEvent激发事件语句</h5><p>    标准格式：<br/>      RaiseEvent 事件函数名(参数表)<br/>    如Event中讲述的例子。 </p><h5>c)WithEvent定义带事件的对象类实例变量</h5><p>    WithEvent语句在定义变量中说明使用，它表示定义的变量将在构造时自动获取类实例，如果是控件类实例，还将插入到窗口类中。<br/>    WithEvent说明的变量必须定义是对象类型，如果是基本数据类型，HB++将报错。<br/>    如Event中讲述的例子。 </p><h4>6. 错误处理语句</h4><h5>a)OnError开启错误处理语句</h5><p>    标准格式：<br/>      OnError<br/>    OnError表示从此行开始如果有错误，将自动转到DoError处执行。 </p><h5>b)DoError错误处理语句</h5><p>    标准格式：<br/>      DoError [函数名(参数表)]<br/>    DoError如果后面没有跟函数，当在OnError到DoError之间的代码中出错时，将自动执行DoError语句后面到CloseError之间的程序代码。<br/>    如果后面使用了函数，当出错，将自动调用此函数。 </p><h5>c)CloseError关闭错误处理语句</h5><p>    标准格式：<br/>      CloseError<br/>    关闭错误处理。关闭后，执行出错，HB++不会激发DoError处理错误，将系统报错。 </p><h5>d)Resume恢复执行语句</h5><p>    标准格式：<br/>      Resume [Next | Exit]<br/>    Resume：错误处理完毕后，使用此语句将返回到出错的语句上继续执行<br/>    Resume Next：错误处理完毕后，使用此语句将返回到出错的下一条语句<br/>    Resume Exit：错误处理完毕后，使用此语句将退出当前函数。<br/><br/>    注意：HB++的错误处理机制允许嵌套使用。当出错时，HB++会自动寻找最近的错误处理的DoError。例如下例：<br/>      Function abc(a as long,b as long)<br/>        dim c as long<br/>        OnError<br/>          a=10<br/>          b=0<br/>          c=a/b<br/>          OnError<br/>            a=5<br/>            c=a/b<br/>          DoError<br/>            Msgbox(a)<br/>            Resume Next<br/>          CloseError<br/>          a=20<br/>          c=a/b<br/>        DoError<br/>          MsgBox(a)<br/>          Resume Next<br/>        ClsoeError<br/>      end function<br/>    运行结果：第一次提示“10”，第二次提示“5”，第三次提示“20”。 </p><h4>7. 属性函数定义</h4><h5>a)Property Get读操作函数定义语句</h5><p>    标准格式：<br/>      Property Get 属性函数名() As 类型名[&lt;&gt;]<br/>      End Property </p><h5>b)Property Let基本数据类型写操作函数定义语句</h5><p>    标准格式：<br/>      Property Let 属性函数名([ByVal | ByRef] 参数名 As 基本数据类型名[&lt;&gt;])<br/>      End Property </p><h5>c)Property Set对象类型写操作函数定义语句</h5><p>    标准格式：<br/>      Property Set 属性函数名([ByVal | ByRef] 参数名 As 对象类型名[&lt;&gt;])<br/>      End Property<br/>    注意：Property Get与Property Let配对或Property Get与Property Set配对，当配对两个同名属性函数名的类型一定要相同 </p><h5>d)只读属性或只写属性</h5><p>    只读属性：仅仅使用Property Get定义属性读函数。<br/>    只写属性：仅仅使用Property Let或Property Set定义属性写函数。<br/>    例子：<br/>      Module 例子模块<br/>        Class 例子类<br/>          Private FData as Long<br/><br/>          Property Get Data() as Long<br/>            Data=FData<br/>          End Property<br/><br/>          Property Let Data(ByVal Value as Long)<br/>            FData=Value<br/>          End Property<br/>        End Class<br/><br/>        Function Dispaly()<br/>          dim d as New 例子类<br/>          d.Data=10<br/>          Msgbox(d.Data)<br/>        end Function<br/>      End Module </p><p>　</p>                </div>                    </div>
4137	 极限编程与敏捷开发	敏捷开发  编程  工作  敏捷  单元测试  	1075647900	1220	jz_x	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p align="center"><span style="font-size:24px;">极限编程与敏捷开发</span><br/></p><p align="center"><span style="color:#262626;">作者：<a href="https://github.com/xujingzhou">徐景周</a></span><br/></p><p>在按照我的理解方式审查了软件开发的生命周期后，我得出一个结论：实际上满足工程设计标准的惟一软件文档，就是源代码清单。 </p><div>-- Jack Reeves</div><div> </div><p><strong>简介</strong><br/>　　2001年，为了解决许多公司的软件团队陷入不断增长的过程泥潭，一批业界专家一起概括出了一些可以让软件开发团队具有快速工作、响应变化能力的价值观和原则，他们称自己为敏捷联盟。敏捷开发过程的方法很多，主要有：SCRUM，Crystal,特征驱动软件开发（Feature Driven Development，简称FDD），自适应软件开发(Adaptive Software Development，简称ASD)，以及最重要的极限编程(eXtreme Programming,简称XP)。极限编程(XP)是于1998年由Smalltalk社群中的大师级人物Kent Beck首先倡导的。</p><p><br/><br/> <strong>极限编程</strong><br/><br/>　　设计和编程都是人的活动。忘记这一点，将会失去一切。 </p><div>-- Bjarne Stroustrup </div><p><br/>　　极限编程(XP)是敏捷方法中最著名的一个。它是由一系列简单却互相依赖的实践组成。这些实践结合在一起形成了一个胜于部分结合的整体。<br/><br/>下面是极限编程的有效实践： </p><ol><li>完整团队 XP项目的所有参与者（开发人员、客户、测试人员等）一起工作在一个开放的场所中，他们是同一个团队的成员。这个场所的墙壁上随意悬挂着大幅的、显著的图表以及其他一些显示他们进度的东西。</li><li>计划游戏计划是持续的、循序渐进的。每2周，开发人员就为下2周估算候选特性的成本，而客户则根据成本和商务价值来选择要实现的特性。 </li><li>客户测试作为选择每个所期望的特性的一部分，客户可以根据脚本语言来定义出自动验收测试来表明该特性可以工作。 </li><li>简单设计团队保持设计恰好和当前的系统功能相匹配。它通过了所有的测试，不包含任何重复，表达出了编写者想表达的所有东西，并且包含尽可能少的代码。 </li><li>结对编程所有的产品软件都是由两个程序员、并排坐在一起在同一台机器上构建的。 </li><li>测试驱动开发编写单元测试是一个验证行为，更是一个设计行为。同样，它更是一种编写文档的行为。编写单元测试避免了相当数量的反馈循环，尤其是功功能能验证方面的反馈循环。程序员以非常短的循环周期工作，他们先增加一个失败的测试，然后使之通过。</li><li>改进设计随时利用重构方法改进已经腐化的代码，保持代码尽可能的干净、具有表达力。 </li><li>持续集成团队总是使系统完整地被集成。一个人拆入（Check in）后，其它所有人责任代码集成。 </li><li>集体代码所有权任何结对的程序员都可以在任何时候改进任何代码。没有程序员对任何一个特定的模块或技术单独负责，每个人都可以参与任何其它方面的开发。 </li><li>编码标准 系统中所有的代码看起来就好像是被单独一人编写的。 </li><li>隐喻 将整个系统联系在一起的全局视图；它是系统的未来影像，是它使得所有单独模块的位置和外观变得明显直观。如果模块的外观与整个隐喻不符，那么你就知道该模块是错误的。</li><li>可持续的速度 团队只有持久才有获胜的希望。他们以能够长期维持的速度努力工作，他们保存精力，他们把项目看作是马拉松长跑，而不是全速短跑。 极限编程是一组简单、具体的实践，这些实践结合在形成了一个敏捷开发过程。极限编程是一种优良的、通用的软件开发方法，项目团队可以拿来直接采用，也可以增加一些实践，或者对其中的一些实践进行修改后再采用。</li></ol><p><strong>敏捷开发</strong><br/>　　人与人之间的交互是复杂的，并且其效果从来都是难以预期的，但却是工作中最重要的方面。 </p><div>-- Tom DeMacro和Timothy Lister </div><p><br/>敏捷软件开发宣言： </p><ul><li>个体和交互     胜过 过程和工具 </li><li>可以工作的软件 胜过 面面俱到的文档 </li><li>客户合作       胜过 合同谈判 </li><li>响应变化       胜过 遵循计划 </li></ul><p>虽然右项也有价值，但是我们认为左项具有更大的价值。 </p><ul><li>我们最优先要做的是通过尽早的、持续的交付有价值的软件来使客户满意。 </li><li>即使到了开发的后期，也欢迎改变需求。敏捷过程利用变化来为客户创造竞争优势。 </li><li>经常性地交付可以工作的软件，交付的间隔可以从几个星期到几个月，交付的时间间隔越短越好。 </li><li>在整个项目开发期间，业务人员和开发人员必须天天都在一起工作。 </li><li>围绕被激励起来的个体来构建项目。给他们提供所需的环境和支持，并且信任他们能够完成工作。 </li><li>在团队内部，最具有效果并富有效率的传递信息的方法，就是面对面的交谈。 </li><li>工作的软件是首要的进度度量标准。 </li><li>敏捷过程提倡可持续的开发速度。责任人、开发者和用户应该能够保持一个长期的、恒定的开发速度。 </li><li>不断地关注优秀的技能和好的设计会增强敏捷能力。 </li><li>简单是最根本的。 </li><li>最好的构架、需求和设计出于自组织团队。 </li><li>每隔一定时间，团队会在如何才能更有效地工作方面进行反省，然后相应地对自己的行为进行调整。 </li></ul><p>当软件开发需求的变化而变化时，软件设计会出现坏味道，当软件中出现下面任何一种气味时，表明软件正在腐化。 </p><ul><li>僵化性： 很难对系统进行改动，因为每个改动都会迫使许多对系统其他部分的其它改动。 </li><li>脆弱性： 对系统的改动会导致系统中和改动的地方在概念上无关的许多地方出现问题。 </li><li>牢固性： 很难解开系统的纠结，使之成为一些可在其他系统中重用的组件。 </li><li>粘滞性： 做正确的事情比做错误的事情要困难。 </li><li>不必要的复杂性： 设计中包含有不具任何直接好处的基础结构。 </li><li>不必要的重复性： 设计中包含有重复的结构，而该重复的结构本可以使用单一的抽象进行统一。 </li><li>晦涩性： 很难阅读、理解。没有很好地表现出意图。 </li></ul><p>敏捷团队依靠变化来获取活力。团队几乎不进行预先设计，因此，不需要一个成熟的初始设计。他们更愿意保持设计尽可能的干净、简单，并使用许多单元测试和验收测试作为支援。这保持了设计的灵活性、易于理解性。团队利用这种灵活性，持续地改进设计，以便于每次迭代结束生成的系统都具有最适合于那次迭代中需求的设计。为了改变上面软件设计中的腐化味，敏捷开发采取了以下面向对象的设计原则来加以避免，这些原则如下：</p><ul><li>单一职责原则(SRP) <br/>就一个类而言，应该仅有一个引起它变化的原因。 </li><li>开放-封闭原则(OCP) <br/>软件实体应该是可以扩展的，但是不可修改。 </li><li>Liskov替换原则(LSP) <br/>子类型必须能够替换掉它们的基类型。 </li><li>依赖倒置原则(DIP) <br/>抽象不应该依赖于细节。细节应该依赖于抽象。 </li><li>接口隔离原则(ISP) <br/>不应该强迫客户依赖于它们不用的方法。接口属于客户，不属于它所在的类层次结构。 </li><li>重用发布等价原则(REP) <br/>重用的粒度就是发布的粒度。 </li><li>共同封闭原则(CCP) <br/>包中的所有类对于同一类性质的变化应该是共同封闭的。一个变化若对一个包产生影响，则将对该包中的所有类产生影响，而对于其他的包不造成任何影响。 </li><li>共同重用原则(CRP) <br/>一个包中的所有类应该是共同重用的。如果重用了包中的一个类，那么就要重用包中的所有类。 </li><li>无环依赖原则(ADP) <br/>在包的依赖关系图中不允许存在环。 </li><li>稳定依赖原则(SDP) <br/>朝着稳定的方向进行依赖。 </li><li>稳定抽象原则(SAP) <br/>包的抽象程度应该和其稳定程度一致。 </li></ul><p>　　上述中的包的概念是：包可以用作包容一组类的容器，通过把类组织成包，我们可以在更高层次的抽象上来理解设计，我们也可以通过包来管理软件的开发和发布。目的就是根据一些原则对应用程序中的类进行划分，然后把那些划分后的类分配到包中。<br/><br/>下面举一个简单的设计问题方面的模式与原则应用的示例：<br/><br/>问题：<br/>　　选择设计运行在简易台灯中的软件，台灯由一个开关和一盏灯组成。你可以询问开关开着还是关着，也可以让灯打开或关闭。<br/><br/>解决方案一：<br/>　　下面图1是一种最简单的解决方案，Switch对象可以轮询真实开关的状态，并且可以发送相应的turnOn和turnOff消息给Light。<br/><br/><img alt="" border="0" src="http://writeblog.csdn.net/document/journal/vckbase29/images/xproimg1.JPG"/><br/>解决方案二：<br/>　　上面这个设计违反了两个设计原则：依赖倒置原则(DIP)和开放封闭原则(OCP)，DIP原则告诉我们要优先依赖于抽象类，而Switch依赖了具体类Light，对OCP的违反是在任何需要Switch的地方都要带上Light，这样就不能容易扩展Switch去管理除Light外的其他对象。为了解决这个方案，可以采用ABSTRACT SERVER模式，在Switch和Light之间引入一个接口，这样就使得Switch能够控制任何实现了这个接口的东西，这也就满足了DIP和OCP原则。如下面图2所示：<br/><br/><img alt="" border="0" src="http://writeblog.csdn.net/document/journal/vckbase29/images/xproimg2.JPG"/><br/><br/>解决方案三：<br/>　　上面图2所示解决方案，违返了单一职责原则(SRP)，它把Switch和Light绑定在一起，而它们可能会因为不同的原因而改变。这种问题可以采用ADAPTER模式来解决，适配器从Switchable 派生并委托给Light，问题就被优美的解决了，现在，Switch就可以控制任何能够被打开或者关闭的对象。但是这也需要会出时间和空间上的代价来换取。如下面图3所示：<br/><br/><img alt="" border="0" src="http://writeblog.csdn.net/document/journal/vckbase29/images/xproimg3.JPG"/><br/><br/>　　敏捷设计是一个过程，不是一个事件。它是一个持续的应用原则、模式以及实践来改进软件的结构和可读性的过程。它致力于保持系统设计在任何时间都尽可能得简单、干净和富有表现力。</p><p><br/><br/> <strong>参考文献</strong> </p><ol><li>设计模式-可复用面向对象软件的基础 -- 李英军等译 </li><li>重构-改善既有代码的设计 -- 侯捷等译 </li><li>敏捷软件开发-原则、模式与实现 -- 邓辉译 </li></ol><p> </p><p><strong>联系方式</strong> </p><ul><li>地址：陕西省西安市劳动路90号院(台板厂家属院)六单元 </li><li>邮编：710082 </li><li>Email: jingzhou_xu@163.net </li><li>未来工作室(Future Studio) </li></ul><p> </p>                </div>                    </div>
4140	 使用dom4j和XMLHTTP轻松解决多条记录操作	iterator  function  servlet  xml  object  文档  	1086920340	950	andiyang	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p>/////////////////////////////<br/>// XML Http Function      //<br/>////////////////////////////<br/>function postXmlDocument(sUri, xmlDoc) {<br/>   var xmlHttp = XmlHttp.create();<br/>   var async = true;<br/>   xmlHttp.open("POST", sUri, async);<br/>   xmlHttp.setRequestHeader("Content-Type","text/xml");<br/>   xmlHttp.setRequestHeader("charset","UTF-8");<br/>   xmlHttp.onreadystatechange = function () {<br/>      if (xmlHttp.readyState == 4)<br/>         postHandleCallback(xmlHttp.responseText); // responseXML : XmlDocument<br/>   }<br/>   xmlHttp.send(xmlDoc);<br/>}<br/>Servlet端代码，只需要把xml流读进来，然后直接进行解析处理就可以了</p> <p>  SAXReader xmlReader = new SAXReader();<br/>  InputStream in = ServletActionContext.getRequest().getInputStream();<br/>  document = xmlReader.read(in);</p> <p>下面是对xml文档的遍历</p> <p>for (Iterator i = root.elementIterator(modelName); i.hasNext();) {<br/>    Element element = (Element) i.next();<br/>    Object entityIns = instanceModel(modelName);<br/>    Iterator subnodes = element.elementIterator();<br/>    while (subnodes.hasNext()) {<br/>     Element subnode = (Element) subnodes.next();<br/>     dynamicPopulate(subnode.getName(), subnode.getText(), entityIns);<br/>    }</p> <p>}<br/></p>                </div>                    </div>
4288	 用HTML实现COMBOX 下拉选择框	html  input  	1010970780	3646	squirrel	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p>在VC里叫作COMBOX，既可以象文本框般输入，又可以选择。<br/><br/>HTML里本来没有这功能，但可以婉转一点实现。<br/><br/>&lt;INPUT TYPE=TEXT&gt;&lt;SELECT NAME=TEMP&gt;<br/>&lt;OPTION&gt;......&lt;/SELECT&gt;<br/>这样就能在页面上显示两个框。<br/>第一个框是你要实现的地方。第二个则是一个下拉菜单。<br/>在SELECT 框里选择后用ONCHANGE事件把选择的值放到&lt;TEXT&gt;框中<br/></p><p>&lt;input TYPE="TEXT" NAME="TT" ID="KK"&gt;<br/>&lt;select NAME="TEMP" onchange="KK.innerText =this.options[this.selectedIndex].value"&gt;<br/>&lt;option value&gt;&lt;/option&gt;<br/>&lt;option value="AAAAAA"&gt;AAAAAA&lt;/option&gt;<br/>&lt;option value="BBBBBB"&gt;BBBBBB&lt;/option&gt;<br/>&lt;option value="CCCCCC"&gt;CCCCCC&lt;/option&gt;<br/>&lt;option value="DDDDDD"&gt;DDDDDD&lt;/option&gt;<br/>&lt;option value="EEEEEE"&gt;EEEEEE&lt;/option&gt;<br/>&lt;option value="FFFFFF"&gt;FFFFFF&lt;/option&gt;</p><p>&lt;/select&gt;<br/></p>                </div>                    </div>
4335	 JSP标签库介绍（1）什么是标签库？	jsp  include  xml  扩展  文档  xsl  	991197720	1508	asper	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p>JSP标签库（也被称作定制标签）是一种通过JavaBean生成基于XML的脚本的方法。从概念上将，标签就是很简单而且可重用的代码结构。比方说，在我们最新发布的<a href="http://www.jspinsider.com/jspkit/about.html">JSPKit</a>（在<a href="http://www.jspinsider.com/">JSP Insider</a>内）中，我们就使用XML标签实现了对XML文档的轻松访问。请看以下的清单A。</p><p><b>清单</b><b>A</b><b>：</b>执行XML/XSL 转换的示例标签及其所在的HTML页面</p><table align="center" bgcolor="#cccc99" border="0" cellpadding="0" width="90%"><tbody><tr><td><font face="Courier New, Courier, mono" size="2">&lt;%@ taglib uri="http://www.jspinsider.com/jspkit/JAXP" </font><font face="Courier New, Courier, mono" size="2">prefix="JAXP"%&gt;</font><br/><font face="Courier New, Courier, mono" size="2">  &lt;JAXP:TransformerTag&gt;</font><br/><font face="Courier New, Courier, mono" size="2">  &lt;JAXP:XMLFile&gt;c:/xml/example.xml&lt;/JAXP:XMLFile&gt;</font><br/><font face="Courier New, Courier, mono" size="2">  &lt;JAXP:XSLFile&gt;c:/xml/example.xsl&lt;/JAXP:XSLFile&gt;</font><br/><font face="Courier New, Courier, mono" size="2">&lt;/JAXP:TransformerTag&gt;</font> </td></tr></tbody></table><p>以上的示例使用了简单的标签来访问处在幕后的更强大代码。在以上的事例中首先装载了一个XML文件，然后应用了一个XSL文件来创建一个将被发送到客户端的结果——这一切不过仅仅只是用了一个很简单的标签。</p><p><b>定制标签使得</b><b>JSP</b><b>项目中很容易创建重用的开放源代码模块。而你的全部需要不过就是标签库及其文档。标签库的重要特性如下所示：</b></p><ol type="1"><li><b>易于安装在多个项目上</b><br/>标签很容易从一个JSP项目迁移到其他项目。一旦建立了一个标签库，你只需要把这个个标签库包装成一个JAR文件就可以在其他JSP项目中重新使用了。不能重用的是你作为程序员在建立标签时所加进标签的内容。因为标签可以重新使用，所以标签库可以轻松地用于你自己的项目。目前，最好的标签资源可以在<a href="http://jsptags.com/tags/">JSPTags.com</a>这个站点找到。. </li><li><b>扩展</b><b>JSP</b><br/>标签库可以具备JSP规范(JSP 1.2)中的任何特性和功能。这也意味着你拥有了无限的能力可以扩展和增加JSP的强大功能却无需等待新版本JSP的发布。所以说，你完全可以取消页面上的JSP <i>include</i>调用了——只需用<i>include</i>标签建立自己的规范就可以了。 </li><li><b>易于维护</b><br/>标签库使得JSP Web应用程序变得很容易维护。主要有以下几个原因： </li></ol><br clear="all"/><ul type="disc"><li>标签对任何人而言都很容易使用、易于理解。 </li><li>你的所有逻辑都驻留在处于中心的标签处理器和JavaBean内。这样一来，如果你不得不更新你的代码，你只需要处理这些中心文件而无需修正使用这些代码的其他页面。 </li><li>如果你需要增加新的功能，你不必改变任何已经存在的页面。你可以把额外的属性包含到你的标签内从而引进新的行为同时保留以前的属性，实现旧页面的正常运行。<br/><br/>比方说，你可能有如下的一个标签，它让你的文本都显示蓝色：<br/><br/><font face="Verdana, Arial, Helvetica, sans-serif" size="2">&lt;BlueText&gt;</font><font color="#0000ff" face="Verdana, Arial, Helvetica, sans-serif" size="2">My Text</font><font face="Verdana, Arial, Helvetica, sans-serif" size="2">&lt;/BlueText&gt; </font><br/><br/>但是随着项目的进行，你又想让蓝色变暗。于是你保留自己的标签但是为其增加了一个新的属性：<i>shade</i> <br/><br/><font face="Verdana, Arial, Helvetica, sans-serif" size="2">&lt;BlueText shade="teal"&gt;</font><font color="#008080" face="Verdana, Arial, Helvetica, sans-serif" size="2">My Text</font><font face="Verdana, Arial, Helvetica, sans-serif" size="2">&lt;/BlueText&gt;</font> <br/><br/>所有的老标签继续显示蓝色，但现在你可以使用同一标签来产生变暗的蓝色文本了。<br/><br/></li><li>标签提升了代码的重用性。那些经过多次测试和使用的代码肯定具有更少的bug。所以，使用定制标签的JSP页面也同样具有更少的缺陷，维护起来自然方便多了。 </li></ul><ol start="4" type="1"><li><b>更快的开发速度</b><br/>标签库是一种重用代码的好办法。我们知道，服务器端语言标准的重用代码方式是使用模版。标签库和模版库这种方式相比则好得多。采用模版库，你就需要针对每个项目修改模版或者建立生硬的接口。标签库则没有这些限制，而其所具有的面向对象特性则让标签库不仅用法灵活而且扩展能力极为强大。还有，因为你重用代码，结果在项目开发上花费的时间就大大降低了，而更多的时间则可以用来设计自己的Web应用程序。标签库的简单接口使得这些代码用法简单、易于调试。 </li></ol><p>虽然标签库用起来特别简单，但是，建立其内部支持层次可比建立简单的JavaBean复杂多了。这种复杂性的主要原因在于标签库包含了好几个部分。而你所需要掌握的技能不过是理解、熟悉Java和JSP。</p><!-- end of storybody -->                </div>                    </div>
4461	 语音识别技术面临的问题	语言  工作  	977302560	1964	tchaikov	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <table border="0" width="90%"><tbody><tr><td valign="top" width="74%"><p></p><p align="center"><font face="宋体"><span class="name00"><font color="#ff3333"><b>语音识别技术面临的问题</b></font><br/><br/></span><span class="Name01">高皓 2000/12/19</span></font></p><p><br/><font face="宋体"><span class="content">　　凭心而论，语音识别是一项复杂的技术，特别对于汉语语音识别尤其如此。因此，尽管多年前就有众多公司和研究机构开始了语音技术，包括语音识别和语音合成技术的研究，但直到最近一两年，在国内应该说是今年，才开始有规模的商用。 <br/><br/>　　国外已经有了不少较大规模的语音识别IVR系统或者呼叫中心的应用，然而在国内，虽然有将语音识别和呼叫中心结合起来的趋势，但仍没有多少应用。这其中虽然有诸多影响因素，但重要的一点就是汉语语音识别技术还不够完善。那么，语音识别技术要进入大规模商用，还要跨越哪些障碍呢？ <br/><br/>　　<strong>■用户的独立性</strong> <br/>　　所谓用户的独立性，就是语音识别软件能够识别有不同嗓音和口音的用户，而无需通过训练软件来使其识别一个特殊用户的声音。目前的许多语音识别软件，是基于标准的发音来进行识别的。而实际上，人们说话千差万别，发音也各不相同，特别对于有口音的语音来说，更是对语音识别软件提出了严峻的挑战。目前的语音识别软件大部分是通过自学习功能，不断的训练来达到软件对于特定用户语音的识别。 <br/><br/>　　将来，语音识别软件的一个发展趋势就是加强处理性，可以识别在一定范围内的各种发音。而实际上，现在有许多语音软件公司在从事这方面的工作，尽量将所有可能的方言发音收入语音库。这样，无需经过专门的特殊训练，软件就能识别用户的发音。 <br/><br/>　　<strong>■自然的语言能力</strong> <br/>　　许多语音识别系统还具有自然的语言能力，这就是软件理解讲话者的能力。这种能力不仅表现在特定的单词上，甚至还表现在短语和完整的句子上。自然的语言意味着两点：第一，它可让用户用句子来表达意思。例如，为表达checking account，用户可使用有更多单词的自然句子，如I'd like my checking account balance。 第二指用户可使用包含多义词的句子。例如，我们可说I want to transfer $500 dollars from my savings account to my checking account。这是自然语言的一个主要准则，用户可在一个单句中使用多个多义词。 <br/><br/>　　有少数复杂的语音识别系统使用提示性对话。在这里，语音识别系统提示用户用一个单词或记号来回答。根据专门机构的调查，多数人更喜欢用约定俗成的自然语言，而不喜欢使用提示性对话。人们讨厌的是不完善的自然语言，当能使用完善的自然语言时，人们当然不可抗拒地选择了它。 <br/><br/>　　<strong>■处理插入的能力</strong> <br/>　　新增的插入的能力是语音识别软件的另一个主要进步。插入的能力允许用户在系统提示时中断系统，但系统依然能知道用户的请求。 <br/><br/>　　这点对于实际的应用来说是有相当意义的。因为人们在说话时，总是在自觉不自觉地思考，经常会在打断语言的连续性，而插入一些补充性的语言。这样的语言，在语法上来说经常不正确的，常规的语音识别系统会很难处理这些语音。 <br/><br/>　　<strong>■软件身份验证的能力</strong> <br/>　　语音识别销售商最近还介绍了软件身份验证的能力，即根据用户的嗓音和语言特点，来达到识别用户的能力。这在实际中是一个非常有价值的特点，如可用于人事管理上。</span></font></p><!-- #EndEditable --></td></tr></tbody></table>                </div>                    </div>
4485	 视频传输技术	internet  电话  网络  工作  电信  终端  	984499800	1305	tchaikov	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <div align="center"><font color="#004080"><big><big><strong>视 频 传 输 技 术</strong></big></big></font></div><div align="left"><p align="center"><strong>许平沧</strong></p><p><font color="#ffffff">－－</font>随着Internet的不断发展，人们希望在网上传送更多的多媒体信息。视频信号的传输是多媒体信息传输的核心。视频信号在计算机终端播放已不成问题，关键问题在于信号的压缩及传输技术。例如，传输MPG－1方式的普通电视信号，要求速率为120～140kbit/s；传输相当于S－VSH的MPG－2电视信号，要求500kbit/s的速率；传输双工或更高质量的信号，对带宽的要求还要高。另外，视频传输对延迟及延迟抖动要求较高。所以，视频传输不但要有较宽的带,还要有较好的稳定性和可伸缩性。</p></div><div align="left"><font color="#ffffff">－－</font><strong>1．电话线传输视频信息</strong></div><div align="left"><font color="#ffffff">－－</font>用电话系统传输视频信号，主要应用的是各种数字用户线路xDSL技术。它提供一种直接接入Internet方案的不中断服务。按照ITU G.902定义，接入网由业务节点接口（SNI）和用户网络接口（UNI）之间一系列传送实体（如网络设施和传输设施等）组成，是能为电信业务的实现提供所需传输能力的实施系统，可经由管理接口（Q3）配置和管理。它实际上是本地局与用户设备间的信息传送实施系统，可以部分或全部替代传统的用户本地线路，含复用、交叉连续和传输等功能。原则上，接入网可实现的SNI和UNI的类型、数目没有限制。整个通信网分为3部分：传送网、交换网和接入网。最新的 xDSL技术利用电话线路的双铜线实现每秒数兆比特的数据传输，比普通拨号上网及ISDN适配器的速率高得多。</div><div align="left"><font color="#ffffff">－－</font>ADSL（非对称用户数字线）是xDSL技术之一。它可传输高品质的视频信号。其上行传输速率要低于下行传输速率。下行传输速率受传输距离的影响，距离为2.7km时，传输速率8.4Mbit/s，5.5km时便降到 1.54Mbit/s。上行传输速率在16～64kbit/s之间。所以ADSL更适合点播的分布式服务。ADSL的关键技术在于高速信道的调制，可选用的调制技术有3种：正交幅度调制（QAM）、无载波幅度相位调制（CAP）和离散多频（DMT）调制。与QAM、CAP相比，DMT可提供更高的工作速率，是一种多载波调制方法。它将电话网中双绞线的可用频带（1MHz）划分为256个子信道，每个子信道带宽为 4kHz。它可根据各子信道的性能来动态地分配各信道每字符可携带的比特数，关闭那些不能携带数据的子信道，这样使可用频带的平均传输率大大提高。ADSL将下行高速信道分为4个子承载信道 AS0－AS3，将双工中速信道分为3个子信道LS0－LS2。各个信道的选择在ADSL初始化中完成。 ADSL可提供符合欧洲、北美标准的数据速率，也可为ATM提供信道。系统工作时，4路下行单向高速数据信号AS0－AS3和3路双工中速信号LS0－LS2经过同步混合，进入两个分离的缓存器——快速缓存器和交织缓存器，分别进行循环码校验、量化和前向纠错编码（FEC）。交织缓存器出来的数据还需经过交织处理。两路信号在经过频率分配，均衡后，再进行星座编码和增益控制，最后经反傅立叶变化（IDFT）来完成多载波的调制，再经过并／串变换和D／A转换，发送到信道上去。接收端经相反处理，即可恢复数据。</div><div align="left"><font color="#ffffff">－－</font>HDSL（高速率用户数字线）亦是xDSL技术的一种，由于采用了先进的调制技术，所以对带宽的要求较少，在传输的同时也不用中继器，仅使用两对双绞线。HDSL用两对双绞铜线传送双向对称数字信号，传输速率为 168kbit/s，提供2048kbit/s的E1业务。HDSL无中继传输距离为3～5km，比传统的PCM要长一倍以上。它对双绞铜线的要求没有传统技术严格，所以安装方便。HDSL采用了若干编码和调制方式，如基带编码方式（PAM）、正交幅度调制（QAM）、无载波调幅调相（CAP）等，以提高传送质量，延长传输距离。HDSL用多对线并行传输，光将2Mbit/s的数据流均匀分配在若干对双绞铜线上传输，然后再还原成2Mbit/s。</div><div align="left"><font color="#ffffff">－－</font>目前ADSL和HDSL技术较为成熟，用得较多。其他还有RDSL（自适应用户数字线），它可根据传输线的质量和传输距离动态地调整访问速度；VDSL（甚高速用户数字线），这是传输速率最快的一种，在一对双绞线上可支持上行传输速率13～52Mbit/s和下行传输速率1.5～2.3Mbit/s，但传输距离只有300～1 400m，可以支持高清晰度电视（HDTV）信号；SDSL（单用户数字线），也支持T1 线路及E1线路，传输距离在304m内时，可以满足上、下行传输速率相等的要求，在无负载铜质电话线上，支持廉价1.1Mbit/s的数据传输，并很快达到2Mbit/s；IDSL（ISDN用户数字线），在无负载铜质电话线上支持双向144kbit/s的数据速率，能在标准ISDN的距离上实现ISDN的质量，很适合传输距离超过5km的用户。</div><div align="left"><font color="#ffffff">－</font><font color="#ffffff">－</font><strong>2．利用无线技术传输视频信息</strong></div><div align="left"><font color="#ffffff">－－</font>无线接入的下行速度要高于上行速度，可达到400kbit/s，这是因为用户上行多采用模拟调制解调器，通过标准 SLIP／PPP联接到本地ISP。实际速度根据调制解调器速率而定。</div><div align="left"><font color="#ffffff">－－</font>另一种无线技术是局域性多点分布服务（LDMS），它是一种双向的数字式广播系统，主要利用地面设备进行数据收发。LMDS使用G波段，由于频率高，所以集线站和网络中心的转发器传输数据。这个通信中心的作用是处理所有的路径选择、线路交换以及桥接到Internet上的一些问题。虽然LMDS不是一个完全的交换式网络，但是它可以建立虚拟的点对点连接。正如其他高速访问方案一样，LMDS也是非对称的系统。它将1GHz的带宽分出850MHz用于下行通信，其余的150MHz用于上行通信。根据设计的要求，LMDS会将许多用户指定到不同的信道上，而这些信道的带宽大约在20～40MHz之间。 </div><div align="left"><font color="#ffffff">－－</font><strong>3．其他可利用的视频传输技术</strong></div><div align="left"><font color="#ffffff">－－</font>现在，与传送视频数据有关的协议和标准都处在完善中。例如，ATM可以集成视频、数据和音频，其信元的长度为 53bit，其中包含5bit的首标，用于错误控制、地址信息以及优先权控制等，其余的48bit用来携带数据。由于ATM是一种面向连接的通信方式，因此就像打电话一样，ATM会把第一个寄存器中的内容传送给连接在通道上的所有交换机，由交换机负责传送每一个信元到下一个节点，数据流本身不必考虑路径选择的问题，这种透明的传输方式使ATM具有很强的可伸缩性。另外，ATM的连接成本由所传送的数据量大小而定，与传送距离没有关系。ATM网络能够提供的速率达25Mbit/s～ 1Gbit/s。除此之外，ATM的交换装置能以透明的方式来动态调整各个设备之间的数据传输速率，因此它非常适宜于点对点对传输。</div><div align="left"><font color="#ffffff">－－</font>除ATM外，还有一些其他的通信协议可用于视频网络。分布式排队双总线技术（DQDB）在双工的模式下可以提供34～ 140Mbit/s的传输速率，它采用两条总线将数据传送到所有的连接点上，总线的端节点能够产生空数据封包，该包被传送到其他的节点上以查询是否有需要传输的信息。DQDB是一种非连接的网络，各端点之间的通信速率也不一样，每一个信元的长度也是53bit，其中5bit为地址信息，这和 ATM信元的长度和格式一样，因此，它们彼此的结构能够兼容。双总线结构增加了重复性，从而可以大大提高DQDB的稳定性。这样，一旦一条通道完全不通，系统即可在数秒之内完成重新设置。 </div><div align="left"><font color="#ffffff">－－</font>宽带ISDN （B－ISDN）也可以用于视频传输，它能够以高于150Mbit/s的速率传送视频和其他数据。B-ISDN 主要采用的技术是光纤加上时分多路复用（TDM）。在美国，它是以（SONET）为基础的，在欧洲则是以同步数字分级技术为基础的。</div>                </div>                    </div>
4641	 一个投票程序	input  database  border  microsoft  vbscript  variables  	966582660	593	elife	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        1. vote.asp<br/><br/>&lt;%@ LANGUAGE="VBSCRIPT"%&gt;<br/>&lt;%OPTION EXPLICIT%&gt;<br/>&lt;%Response.Buffer = True%&gt;<br/><br/>&lt;!-- #INCLUDE FILE="adovbs.inc" --&gt;<br/><br/>&lt;%<br/>'*** Remember to create those variables before trying to use them.<br/><br/>    Dim objConn    <br/>    Dim objRec3<br/>    Dim strConnect<br/>    Dim    varTopic, varTopicID, varSelectionNum, varSelected<br/>    Dim i, varTotal, varThis, varThisTitle, varAlreadyVote<br/><br/>    strConnect = "DRIVER={Microsoft Access Driver (*.mdb)};DBQ=" &amp; Server.MapPath("vote.mdb") &amp; ";DefaultDir=" &amp; Server.MapPath(".") &amp; ";DriverId=25;FILE=MS Access;MaxBufferSize=512;PageTimeout=5;SafeTransactions=0;Threads=3;UID=admin;UserCommitSync=Yes;;User Id=admin;"<br/>    <br/>    Set objConn = Server.CreateObject ("ADODB.Connection")     '*** Create an ADO database connection object.<br/>    Set objRec3 = Server.CreateObject ("ADODB.Recordset")     '** Create an ADO RecordSet object.<br/>    <br/>    objConn.Open strConnect    '*** Open the connection to the database<br/>    objRec3.Open "vote", objConn, adOpenForwardOnly, adLockPessimistic, adUseServer '*** Open the recordset<br/><br/>    varTopic = Request.Form("topic")<br/>    varTopicID = Request.Form("topicID")<br/>    if varTopicID="" then<br/>        varTopicID = Request.QueryString("topicID")<br/>    end if<br/>    varSelectionNum = Request.Form("selectionNum")<br/>    varSelected = Request.Form("selected")<br/><br/>    objRec3.Filter = 0 <br/>    objRec3.Filter = "topicID=" &amp; varTopicID    'only number can be filter?<br/>    <br/>    If NOT objRec3.EOF then<br/>        if Request.Form("selected") = "" then<br/>        else<br/>            varAlreadyVote="alreadyVote" &amp; "_" &amp; varTopicID<br/>            if Session(varAlreadyVote)&lt;&gt;"true" then <br/>                objRec3("selection" &amp; varSelected &amp; "_count") = objRec3("selection" &amp; varSelected &amp; "_count") +1<br/>                objRec3.Update<br/>                Session(varAlreadyVote)="true"<br/>            end if<br/>        end if<br/>        varTotal=0<br/>        for i=0 to objRec3("selectionNum")-1<br/>            varTotal=varTotal+ objRec3("selection" &amp; i &amp; "_count") <br/>        next<br/>%&gt;<br/><br/>&lt;p align=left&gt;    &lt;% =varTopic %&gt; &lt;/p&gt;<br/>&lt;p align=center&gt;<br/>&lt;table width=480 border=0 cellspacing=0 cellpadding=0 bgcolor=#000000&gt;<br/>&lt;caption align=left&gt;&lt;font size=2&gt;共有 &lt;font color=red&gt;&lt;% =varTotal %&gt;&lt;/font&gt;人参加&lt;/font&gt;&lt;/caption&gt;<br/>&lt;tr&gt;&lt;td&gt;<br/>&lt;table width=480 border=0 cellspacing=1 cellpadding=3&gt;<br/>    &lt;tr bgcolor=#dcdcdc align=center valign=center&gt;<br/>        &lt;th width=120&gt;&lt;font size=2&gt;选项&lt;/font&gt;&lt;/td&gt;<br/>        &lt;th width=300&gt;&lt;font size=2&gt;比   例&lt;/font&gt;&lt;/td&gt;<br/>        &lt;th width=60&gt;&lt;font size=2&gt;人数&lt;/font&gt;&lt;/td&gt;<br/>    &lt;/tr&gt;<br/><br/>&lt;%<br/>        for i=0 to objRec3("selectionNum")-1<br/>            varThisTitle=objRec3("selection" &amp; i &amp; "_title") <br/>            varThis=objRec3("selection" &amp; i &amp; "_count") <br/>%&gt;<br/>&lt;tr bgcolor=#ffffff valign=center&gt;<br/>&lt;td width=120 align=center&gt;&lt;font size=2 color=#ff0000&gt;&lt;% =varThisTitle %&gt;&lt;/font&gt;&lt;/td&gt;<br/>&lt;td width=300 align=left&gt;&lt;img src="color.gif" width=&lt;% =varThis*100/varTotal %&gt; height=12 border=0&gt;&lt;font size=2 color=#ff0000&gt; <br/>    &lt;% = left(varThis*100/varTotal, 5) %&gt;%<br/>    &lt;/font&gt;<br/>&lt;/td&gt;<br/>&lt;td width=60 align=center&gt;&lt;font size=2 color=#ff0000&gt;&lt;% =varThis %&gt;&lt;/font&gt;&lt;/td&gt;<br/>&lt;/tr&gt;<br/>&lt;%<br/>        next<br/>%&gt;<br/><br/>&lt;/table&gt;<br/>&lt;/td&gt;&lt;/tr&gt;<br/>&lt;/table&gt;&lt;/p&gt;<br/><br/>&lt;%<br/>    else    'no this topic yet<br/>        objRec3.AddNew<br/><br/>        objRec3("topicID") = varTopicID<br/>        objRec3("topic") = varTopic<br/>        objRec3("selectionNum") = varSelectionNum<br/><br/>        for i=0 to varSelectionNum<br/>            objRec3("selection" &amp; i &amp; "_title") = Request.Form("selection" &amp; i &amp; "_title")<br/>        next<br/><br/>        objRec3.Update<br/>        response.write "added"<br/>    End If<br/><br/>    objRec3.Close<br/>    objConn.Close<br/><br/>    Set objRec3 = Nothing<br/>    Set objConn = Nothing    <br/>%&gt;<br/><br/>2. vote.htm<br/><br/>&lt;HTML&gt;<br/><br/>&lt;HEAD&gt;<br/><br/>&lt;script language="JavaScript"&gt;<br/>function newswindow(url)<br/>{ContentWindow=window.open(url,"_blank","toolbar=no,width=640,height=400;,directories=no,status=yes,scrollbars=yes,resize=yes,menubar=yes")<br/>}<br/>&lt;/script&gt;<br/><br/>&lt;/HEAD&gt;<br/><br/>&lt;BODY&gt;<br/><br/>您认为"你说我说"栏目<br/>    &lt;form method="post" action="vote.asp" onSubmit="windowOpener('')" target="new"&gt;<br/>    &lt;tr&gt;<br/>    &lt;td width=80&gt;<br/>        &lt;input type="radio" name="selected" value="0" style="background-color:rgb(255,205,96)"&gt;比较混乱&lt;br&gt;<br/>        &lt;input type="radio" name="selected" value="1" style="background-color:rgb(255,205,96)"&gt;马马虎虎&lt;br&gt;<br/>        &lt;input type="radio" name="selected" value="2" style="background-color:rgb(255,205,96)"&gt;秩序井然<br/>    &lt;/td&gt;<br/>    &lt;td width=55&gt;<br/>        &lt;input type=hidden name=topicID value=1&gt;<br/>        &lt;input type=hidden name=topic value=您认为'你说我说'栏目&gt;<br/>        &lt;input type=hidden name=selectionNum value=3&gt;<br/>        &lt;input type=hidden name=selection0_title value=比较混乱&gt;<br/>        &lt;input type=hidden name=selection1_title value=马马虎虎&gt;<br/>        &lt;input type=hidden name=selection2_title value=秩序井然&gt;<br/>        &lt;input type="button" value="查看" style="background-color:rgb(255,205,96)" onClick=newswindow("vote.asp?topicID=1") target=new&gt;<br/>        &lt;input type=submit value="提交" style="background-color:rgb(255,205,96)"&gt;<br/>    &lt;/td&gt;<br/>    &lt;/tr&gt;<br/>    &lt;/form&gt;<br/><br/>&lt;/BODY&gt;<br/><br/>&lt;/HTML&gt;<br/><br/>3. vote.mdb<br/>a Access database file, there is a table named "vote"<br/>fields:<br/>topicID topic selectionNum selection0_title selection0_count ...<br/><br/>                </div>                    </div>
4645	 用ASP做全文检索	全文检索  asp  vbscript  脚本  浏览器  服务器  	968209980	720	acheng	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        摘要：通过词句查找相关的全文是浏览器端常用的方法，ASP类似于CGI，也可以进行简单的文本方式全文检索<br/>　　关键词：ASP检索Intranet网页ADO数据源<br/>　　在Internet/Intranet上对某类信息做详细浏览和全文检索也是常碰到的情况。ASP是微软公司开发的用于制作动态Web页的一种服务器端<br/>脚本型式（或曰编写环境）。它使用VBScript或JavaScript等简易的脚本语言，集成在HTML码中，在服务器端响应浏览器端请求而执行数据访<br/>问和过程（或对象）调用并产生浏览器端执行的脚本语言。本文介绍用ASP编写全文检索代码的方法。<br/>　　方法介绍：<br/>　　确定被检索的文件。将它们保存在同一文件夹中。文件的类型可以是任何文本类型（包括.htm网页文件类型）<br/>　　建立被检索文件的信息库。其中主要包含文件名，文件标题等。<br/>　　用ADO方式访问数据库。建立记录集对象。<br/>　　逐个打开记录集中当前记录所指向的文件。用查找的字串对文件的全文本进行匹配比较。<br/>　　将符合条件的文件标题输出到客户端Web页，并加入指向该文件的超链，以供用户选择浏览。<br/>　　技术要点：<br/>　　数据源。要在创建脚本之前,利用Windows95控制面板中的ODBC指定要访问的数据库及其驱动程序，以数据源名（DSN）标识之。<br/>　　匹配字串的长度。由于浏览器端的数据经过编码传到服务器端，ASP通过其内建对象Request取得的数据也并非完全是用户输入的有用信息<br/>，所以要加以处理。可以在输入字串后附加一标志字符（如#或chr(7)）。本文则采取另一种方法，即计算有效信息的长度。从而截取所需的<br/>字串。<br/>　　创建脚本的文件系统对象Scripting.FileSystemObject，从而打开文本流以读入。<br/>　　特点：<br/>　　直接对.htm文件进行全文检索，省却许多转换过程。.htm文件又用于网页的显示，一举两得。<br/>　　应用ASP，简单明了，易于实现。<br/>　　本例ASP代码：<br/>　　〈%@LANGUAGE="VBSCRIPT"%〉<br/>　　〈html〉<br/>　　〈head〉<br/>　　〈metaNAME="GENERATOR"Content="MicrosoftFrontPage3.0"〉<br/>　　〈metaHTTP-EQUIV="Content-Type"content="text/html;charset=gb_2312-80"〉<br/>　　〈title〉DocumentTitle〈/title〉<br/>　　〈metaname="MicrosoftBorder"content="tl,default"〉〈/head〉<br/>　　〈bodyBACKGROUND="/ie/images/watermrk.gif"BGPROPERTIES="FIXED"BGCOLOR="#00FFFF"〉<br/>　　〈%<br/>　　mousepointer=13<br/>　　SetConn1=Server.CreateObject("ADODB.Connection")<br/>　　conn1.open"DSN=cznj"<br/>　　Setrcst1=conn1.execute("SELECT*FROMpages_catalogue")<br/>　　sch_str=request.form("text1")<br/>　　doubbytes=len(sch_str)/2<br/>　　sch_str=left(sch_str,doubbytes)<br/>　　Response.Write"〈strong〉〈CENTER〉〈H2〉查找结果〈/H2〉〈HR〉〈Br〉〈/strong〉"<br/>　　Dimresult<br/>　　result=false<br/>　　Response.Write"〈UL〉"<br/>　　dowhilenotrcst1.eof<br/>　　tit=rcst1.fields("file_title")<br/>　　fn=rcst1.fields("file_name")<br/>　　file_name=Server.MapPath("/")&amp;"/njweb/private/"&amp;fn<br/>　　to_find=text_match(file_name,sch_str)<br/>　　ifto_findthen<br/>　　url="private/"&amp;fn<br/>　　Response.Write"〈LEFT〉〈LI〉〈H4〉〈AHREF="&amp;url&amp;"〉"&amp;tit<br/>　　endif<br/>　　rcst1.movenext<br/>　　result=resultorto_find<br/>　　loop<br/>　　Response.Write"〈/UL〉"<br/>　　ifnotresultthen<br/>　　Response.Write"〈H3〉〈I〉未找到！〈/I〉〈/H3〉"<br/>　　endif<br/>　　mousepointer=0<br/>　　%〉<br/>　　〈scriptRUNAT="Server"LANGUAGE="VBScript"〉<br/>　　functiontext_match(filename,search_string)<br/>　　dimretstring<br/>　　dimfind_pos<br/>　　Dimfso,a<br/>　　dimdone<br/>　　text_match=false<br/>　　Setfso=Server.CreateObject("Scripting.FileSystemObject")<br/>　　Seta=fso.OpenTextFile(filename,1,FALSE)"ForReading--〉1<br/>　　done=a.AtEndOfStreamortext_match<br/>　　DoWhilenotdone<br/>　　retstring=a.ReadLine<br/>　　find_pos=instr(retstring,search_string)<br/>　　iffind_pos〉0thentext_match=true<br/>　　done=a.AtEndOfStreamortext_match　Loop<br/>　　a.Close<br/>　　endfunction<br/>　　〈/script〉<br/>　　〈/body〉<br/>　　〈/html〉                </div>                    </div>
4653	 鼠标消息处理流程	mfc  文档  windows  框架  	996842820	893	lumg	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p>                                                                                                                                         </p><p>                                                                                                             <br/> 当用户在画板上按下鼠标时，WINDOWS将鼠标消息放在主框架窗口消息队列中<br/>MFC接收到此消息后，先将其转化，然后最先传送鼠标消息给视图<br/>对象，若视图类没有在视图类消息映射表中对此消息进行映射<br/>（即视图没有提供处理器），则MFC重发消息给文档对象。若文档类<br/>消息映射表中没有对此消息进行映射，则MFC重发该消息给主窗口类处理，<br/>若主窗口也没有，则发给应用程序。若还没有映射处理，则按缺省处理。<br/> 因此，应在视图中添加鼠标消息处理函数。<br/>        </p><p>                                                                                                                        </p><p>                                                                                                                                                                                                                                          </p>                </div>                    </div>
4765	 在C#中如何支持Foreach	c#  class  多线程  object  system  vb  	1006996260	795	tansm	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:10pt;font-family:'宋体';" xml:lang="en-us"><span>    </span>在VB6中，我最喜欢For each语句，并让我的类支持这一特性，自然的我也希望C#中也有此功能，一查资料，马上发现C#支持Forcach，可没介绍任何让自己的类支持Foreach。还是看看MSDN吧。&lt;?xml:namespace prefix = o ns = "urn:schemas-microsoft-com:office:office" /&gt;</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:10pt;font-family:'宋体';" xml:lang="en-us"><span>    </span>MSDN指出必须支持System.Collections.IEnumerable接口，而IEnumerable接口中仅有一个方法：GetEnumerator，他要求返回支持System.Collections.IEnumerator接口的对象引用，一看IEnumerator接口就明白了其工作原理，他有MoveNext、Reset方法和Current属性。</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:10pt;font-family:'宋体';" xml:lang="en-us"><span>    </span>老实说一开始我真的很不明白MS为什么不是直接支持IEnumerator接口就可以了，为什么要绕个弯呢，后来仔细一想，的确很有道理，叫我说我说不好，大致的意思是在多线程下提供多个状态，不知道对不对，反正我是这样认为的。</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:10pt;font-family:'宋体';" xml:lang="en-us"><span>    </span>看一下我写的演示代码：</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:10pt;font-family:'宋体';" xml:lang="en-us"><span>    </span></span><span lang="en-us" style="font-size:9pt;color:#0000FF;font-family:'宋体';" xml:lang="en-us">using</span><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"> System;</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"></span></p><p> </p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;color:#0000FF;font-family:'宋体';" xml:lang="en-us">namespace</span><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"> WindowsApplication3</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us">{</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span style="color:#0000FF;">public</span> <span style="color:#0000FF;">class</span> class1</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span>{</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span>[STAThread]</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span style="color:#0000FF;">static</span> <span style="color:#0000FF;">void</span> Main() </span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span>{</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span>     </span>Demo d=<span style="color:#0000FF;">new</span> Demo();</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span>     </span></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span>     </span><span style="color:#008000;">//Foreach演示代码</span></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span>     </span><span style="color:#0000FF;">foreach</span>(<span style="color:#0000FF;">int</span> i <span style="color:#0000FF;">in</span> d)</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span>     </span><span>     </span>Console.WriteLine(i);</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span>}</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span>}</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"></span></p><p> </p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span style="color:#808080;">///</span><span style="color:#008000;"> </span><span style="color:#808080;">&lt;summary&gt;</span><span style="color:#008000;">支持Foreach的演示类</span><span style="color:#808080;">&lt;/summary&gt;</span></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span style="color:#0000FF;">public</span> <span style="color:#0000FF;">class</span> Demo:System.Collections.IEnumerable</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span>{</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span style="color:#008000;">//内部要枚举的数据</span></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span style="color:#0000FF;">int</span>[] intList={1,2,3};</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"></span></p><p> </p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span style="color:#0000FF;">public</span> Demo(){}</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"></span></p><p> </p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span style="color:#008000;">//对象支持IEnumerable接口，返回一个支持IEnumerator接口的实例</span></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span style="color:#0000FF;">public</span><span>  </span>System.Collections.IEnumerator GetEnumerator()</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span>{</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span>     </span>DemoForIEnumerator d=<span style="color:#0000FF;">new</span> DemoForIEnumerator(<span style="color:#0000FF;">this</span>);</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span>     </span><span style="color:#0000FF;">return</span> d;</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span>}</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span style="color:#008000;">//索引器，从1开始索引</span></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span style="color:#0000FF;">public</span> <span style="color:#0000FF;">int</span> <span style="color:#0000FF;">this</span>[<span style="color:#0000FF;">int</span> nIndex]</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span>{</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span>     </span><span style="color:#0000FF;">get</span>{<span style="color:#0000FF;">return</span> intList[nIndex-1];}</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span>}</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"></span></p><p> </p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span style="color:#008000;">//总数</span></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span style="color:#0000FF;">public</span> <span style="color:#0000FF;">int</span> Length</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span>{</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span>     </span><span style="color:#0000FF;">get</span>{<span style="color:#0000FF;">return</span> intList.Length;}</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span>}</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span>}</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"></span></p><p> </p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span style="color:#808080;">///</span><span style="color:#008000;"> </span><span style="color:#808080;">&lt;summary&gt;</span><span style="color:#008000;">支持IEnumerator接口的类</span><span style="color:#808080;">&lt;/summary&gt;</span></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span style="color:#0000FF;">class</span> DemoForIEnumerator:System.Collections.IEnumerator</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span>{</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span>Demo mDemo;</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span style="color:#0000FF;">int</span> per =0;</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"></span></p><p> </p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span style="color:#0000FF;">public</span> DemoForIEnumerator(Demo d)</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span>{mDemo=d;}</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"></span></p><p> </p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span style="color:#008000;">//向前移动，无法继续移动时返回false，否则返回true。</span></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span style="color:#0000FF;">public</span> System.Boolean MoveNext()</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span>{</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span>     </span><span style="color:#0000FF;">if</span> (per&gt;=mDemo.Length)</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span>     </span><span>     </span><span style="color:#0000FF;">return</span> <span style="color:#0000FF;">false</span>;</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span>     </span><span style="color:#0000FF;">else</span></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span>     </span>{</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span>     </span><span>     </span>per++;</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span>     </span><span>     </span><span style="color:#0000FF;">return</span> <span style="color:#0000FF;">true</span>;</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span>     </span>}</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span>}</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"></span></p><p> </p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span style="color:#008000;">//复位</span></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span style="color:#0000FF;">public</span> <span style="color:#0000FF;">void</span> Reset()</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span>{per=0;}</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"></span></p><p> </p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span style="color:#008000;">//当前指针下的值。</span></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span style="color:#0000FF;">public</span> <span style="color:#0000FF;">object</span> Current</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span>{</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span><span>     </span><span style="color:#0000FF;">get</span>{<span style="color:#0000FF;">return</span> mDemo[per];}</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span><span>     </span>}</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"><span>     </span>}</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us">}</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:10pt;font-family:'宋体';" xml:lang="en-us"></span></p><p> </p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span style="font-size:10pt;font-family:'宋体';">在这段代码运行时我发现</span><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us">Reset方法根本不会执行，我不知道他什么时候会调用。其实上面的代码如果你不想额外编写一个类，可以在GetEnumerator方法中返回this，然后自己也支持IEnumerator接口就可以了。</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"></span></p><p> </p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:10pt;font-family:'宋体';" xml:lang="en-us"></span></p><p> </p>                </div>                    </div>
4873	 一次关于C++BuilderX的讨论	borland  opensource  c++  delphi  编译器  .net  	1072408860	3720	Raptor	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p align="center" class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">一次关于C++BuilderX的讨论</span></font></p><p align="center" class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">猛禽（整理）</span></font></p><p align="center" class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us"><a href="http://mental.mentsu.com/">Mental Studio</a></span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us"></span></font> </p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">本来打算把这次的聊天内容整理成文章，但一不小心写得太长，还没写完，加之最近事多，一时半会还写不完。Delphi8又出来了，需要研究一下，所以暂时先把这个聊天记录贴出来将就一下吧。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us"></span></font> </p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:16:12 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：还是谈谈</span><span lang="en-us" xml:lang="en-us">BCB</span><span style="font-family:'宋体';">吧……最近版上对</span><span lang="en-us" xml:lang="en-us">BCB</span><span style="font-family:'宋体';">的怀疑之风很盛啊</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:17:06 </span><span style="font-family:'宋体';">玉笛书生：呵呵，怀疑前途是吧？没办法，哪个叫</span><span lang="en-us" xml:lang="en-us">Borland</span><span style="font-family:'宋体';">不继续追加研发了。</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:17:32 ccrun</span><span style="font-family:'宋体';">：看样子得转行了</span><span lang="en-us" xml:lang="en-us">. </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:17:43 </span><span style="font-family:'宋体';">玉笛书生：恩，都在想换工具。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:18:00 ccrun</span><span style="font-family:'宋体';">：不知道换成什么好。</span><span lang="en-us" xml:lang="en-us">.net? </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:18:50 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：其实</span><span lang="en-us" xml:lang="en-us">BCBX</span><span style="font-family:'宋体';">是个不错的工具。而且</span><span lang="en-us" xml:lang="en-us">BCB5</span><span style="font-family:'宋体';">、</span><span lang="en-us" xml:lang="en-us">6</span><span style="font-family:'宋体';">仍然很好用。我觉得很多人喜欢追最新的，可能是国内盗版太好买了。呵呵。如果要换的话我还是觉得</span><span lang="en-us" xml:lang="en-us">Java</span><span style="font-family:'宋体';">比较好，一来比较成熟，二来</span><span lang="en-us" xml:lang="en-us">Java</span><span style="font-family:'宋体';">的社区力量比</span><span lang="en-us" xml:lang="en-us">.NET</span><span style="font-family:'宋体';">要庞大。</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:20:48 ccrun</span><span style="font-family:'宋体';">：</span><span lang="en-us" xml:lang="en-us">cbx</span><span style="font-family:'宋体';">一上手有些陌生。</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:21:48 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：嗯，要一个习惯的过程是肯定的了，那时候我从</span><span lang="en-us" xml:lang="en-us">VC6</span><span style="font-family:'宋体';">转到</span><span lang="en-us" xml:lang="en-us">VC7</span><span style="font-family:'宋体';">也熟悉了好一阵子的。不过现在</span><span lang="en-us" xml:lang="en-us">BCBX</span><span style="font-family:'宋体';">的战略重点肯定是换了，重点不在可视化开发上了，我感觉更多是面向一些大系统了。包括多编译器、多平台的交叉编译能力，还有</span><span lang="en-us" xml:lang="en-us">Together</span><span style="font-family:'宋体';">的集成、</span> <span style="font-family:'宋体';">等等，都体现了这一点</span> </font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:25:59 ccrun</span><span style="font-family:'宋体';">：恩。其实这是个明智之举。</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:29:33 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：是啊，如今</span><span lang="en-us" xml:lang="en-us">C++</span><span style="font-family:'宋体';">都被用在一些中小型的软件开发上。而假如</span><span lang="en-us" xml:lang="en-us">Borland</span><span style="font-family:'宋体';">能凭借</span><span lang="en-us" xml:lang="en-us">BCBX</span><span style="font-family:'宋体';">整合发展出一套适合企业开发的</span><span lang="en-us" xml:lang="en-us">Framework</span><span style="font-family:'宋体';">，我想对</span><span lang="en-us" xml:lang="en-us">C++</span><span style="font-family:'宋体';">的贡献应该是很大的，可以算是里程碑式的了。现在</span><span lang="en-us" xml:lang="en-us">Borland</span><span style="font-family:'宋体';">正在向这个方向努力，能不能成功就看他了</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:30:16 </span><span style="font-family:'宋体';">玉笛书生：你们试用过了</span><span lang="en-us" xml:lang="en-us">cbx</span><span style="font-family:'宋体';">？</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:30:56 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：我在他出第一个</span><span lang="en-us" xml:lang="en-us">beta</span><span style="font-family:'宋体';">版的时候用过，现在这些看法都是基于外界对他的介绍和评论</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:35:11 </span><span style="font-family:'宋体';">猛禽：呵呵，偶也是用测试版的那个</span><span lang="en-us" xml:lang="en-us">TOMAHAWK</span><span style="font-family:'宋体';">：）其实在</span><span lang="en-us" xml:lang="en-us">OPENSOURCE</span><span style="font-family:'宋体';">领域，现成的东东多的是，看</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">是什么态度了</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:36:03 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：对啊，我就是说，</span><span lang="en-us" xml:lang="en-us">Borland</span><span style="font-family:'宋体';">来把这些东西来一个整合</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:36:08 </span><span style="font-family:'宋体';">猛禽：比如要做多层应用，用标准</span><span lang="en-us" xml:lang="en-us">C++</span><span style="font-family:'宋体';">实现的</span><span lang="en-us" xml:lang="en-us">ACE/TAO</span><span style="font-family:'宋体';">就是一个非常好的东东，但</span><span lang="en-us" xml:lang="en-us">BCBX</span><span style="font-family:'宋体';">只集成了</span><span lang="en-us" xml:lang="en-us">ACE</span><span style="font-family:'宋体';">，没有</span><span lang="en-us" xml:lang="en-us">TAO</span><span style="font-family:'宋体';">，因为</span><span lang="en-us" xml:lang="en-us">TAO</span><span style="font-family:'宋体';">跟</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">的</span><span lang="en-us" xml:lang="en-us">VISIBROKER</span><span style="font-family:'宋体';">有冲突。还有</span><span lang="en-us" xml:lang="en-us">GUI</span><span style="font-family:'宋体';">库，</span><span lang="en-us" xml:lang="en-us">BCBX</span><span style="font-family:'宋体';">如果换成</span><span lang="en-us" xml:lang="en-us">WXWINDOWS</span><span style="font-family:'宋体';">，那对原来用</span><span lang="en-us" xml:lang="en-us">VCL/CLX</span><span style="font-family:'宋体';">的人都是一个重大的打击但</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">也没办法，因为</span><span lang="en-us" xml:lang="en-us">CLX</span><span style="font-family:'宋体';">是基于</span><span lang="en-us" xml:lang="en-us">QT</span><span style="font-family:'宋体';">的，而</span><span lang="en-us" xml:lang="en-us">QT</span><span style="font-family:'宋体';">的协议限制了在商业应用中必须付费</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:37:25 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：现在</span><span lang="en-us" xml:lang="en-us">C++</span><span style="font-family:'宋体';">的问题就在于你有很多的选择，但是每个选择都必须你自己做，而且你选择的东西之间的不兼容需要你自己去解决。而如果这些事情由</span><span lang="en-us" xml:lang="en-us">Borland</span><span style="font-family:'宋体';">帮你完成，那是非常理想的</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:38:35 </span><span style="font-family:'宋体';">猛禽：</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">未必愿意做这样的整合工作</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:38:38 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：不是说了</span><span lang="en-us" xml:lang="en-us">GUI</span><span style="font-family:'宋体';">方面有一个代码生成引擎么？如果这样的话，加入</span><span lang="en-us" xml:lang="en-us">VCL</span><span style="font-family:'宋体';">应该不是难事，只要多加一个对这个引擎的接口就可以恶劣</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:39:00 </span><span style="font-family:'宋体';">猛禽：但是</span><span lang="en-us" xml:lang="en-us">VCL</span><span style="font-family:'宋体';">不是跨平台的，</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">不愿意再在这上面下工夫，因为这有违</span><span lang="en-us" xml:lang="en-us">BCBX</span><span style="font-family:'宋体';">的目，</span><span lang="en-us" xml:lang="en-us">BCBX</span><span style="font-family:'宋体';">必须要有一个平台无关的</span><span lang="en-us" xml:lang="en-us">GUI</span><span style="font-family:'宋体';">库来作为它的</span><span lang="en-us" xml:lang="en-us">FRAMEWORK</span><span style="font-family:'宋体';">。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:40:08 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：对，非</span><span lang="en-us" xml:lang="en-us">windows</span><span style="font-family:'宋体';">平台下不能用</span><span lang="en-us" xml:lang="en-us">VCL</span><span style="font-family:'宋体';">，这是很显而易见的。其实这个事情可以由社团做，</span><span lang="en-us" xml:lang="en-us">Borland</span><span style="font-family:'宋体';">只要负责把那个代码生成引擎做完善就可以了。就像现在的</span><span lang="en-us" xml:lang="en-us">Python</span><span style="font-family:'宋体';">的开发模式</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:40:16 </span><span style="font-family:'宋体';">猛禽：要不然就要把</span><span lang="en-us" xml:lang="en-us">BCBX</span><span style="font-family:'宋体';">定位在后端开发，</span><span lang="en-us" xml:lang="en-us">PYTHON</span><span style="font-family:'宋体';">我不太喜欢，约束太多，还是</span><span lang="en-us" xml:lang="en-us">C++</span><span style="font-family:'宋体';">自由。关键是整合这些</span><span lang="en-us" xml:lang="en-us">OPENSOURCE</span><span style="font-family:'宋体';">的东东，</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">也必须是</span><span lang="en-us" xml:lang="en-us">OPENSOURCE</span><span style="font-family:'宋体';">，而对</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">来说，它必须有利可图，换成</span><span lang="en-us" xml:lang="en-us">IBM</span><span style="font-family:'宋体';">，它可能就会做</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:41:57 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：没必要啊，</span><span lang="en-us" xml:lang="en-us">Java</span><span style="font-family:'宋体';">也不是</span><span lang="en-us" xml:lang="en-us">OpenSource</span><span style="font-family:'宋体';">的，但是社团很强大。关键是你要公开接口。</span><span lang="en-us" xml:lang="en-us">Python</span><span style="font-family:'宋体';">我到是很喜欢，呵呵。现在有空就在琢磨它</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:42:41 </span><span style="font-family:'宋体';">猛禽：</span><span lang="en-us" xml:lang="en-us">JAVA</span><span style="font-family:'宋体';">社团中强大的只有两派：</span><span lang="en-us" xml:lang="en-us">OPENSOURCE</span><span style="font-family:'宋体';">和大公司（</span><span lang="en-us" xml:lang="en-us">IBM/BEA</span><span style="font-family:'宋体';">）。</span><span lang="en-us" xml:lang="en-us">C++</span><span style="font-family:'宋体';">不同，没有哪个大公司能吃下它</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:43:29 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：</span><span lang="en-us" xml:lang="en-us">C++</span><span style="font-family:'宋体';">作为语言是这样，但是类库还是可以有一个领导者的，我认为</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:44:07 </span><span style="font-family:'宋体';">猛禽：现在</span><span lang="en-us" xml:lang="en-us">C++</span><span style="font-family:'宋体';">的类库也有很多了，只是各自为政</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:44:46 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：所以需要一个整合者啊。当然，我希望</span><span lang="en-us" xml:lang="en-us">Borland</span><span style="font-family:'宋体';">能借</span><span lang="en-us" xml:lang="en-us">BCBX</span><span style="font-family:'宋体';">扮演这个角色，至于它自己会不会去扮演，不是我说了算了</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:45:20 </span><span style="font-family:'宋体';">猛禽：但现在</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">只是提供了</span><span lang="en-us" xml:lang="en-us">BCBX</span><span style="font-family:'宋体';">这样一个供整合的平台，整合的工作没有人做。而且据说</span><span lang="en-us" xml:lang="en-us">OPENSOUCE</span><span style="font-family:'宋体';">社团对</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">没有什么好感，传说是始于</span><span lang="en-us" xml:lang="en-us">Denny.Thorpe</span><span style="font-family:'宋体';">和</span><span lang="en-us" xml:lang="en-us">LINUX</span><span style="font-family:'宋体';">社区的那次大吵</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:46:52 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：哎，</span><span lang="en-us" xml:lang="en-us">Borland</span><span style="font-family:'宋体';">毕竟不是大公司，不能像</span><span lang="en-us" xml:lang="en-us">Sun</span><span style="font-family:'宋体';">对</span><span lang="en-us" xml:lang="en-us">java</span><span style="font-family:'宋体';">那么做。而且……，这也是没办法的</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:47:31 </span><span style="font-family:'宋体';">猛禽：所以我们这帮跟</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">混的人也挺惨，难怪别人会看衰</span><span lang="en-us" xml:lang="en-us">BCBX</span><span style="font-family:'宋体';">。其实现在要拿</span><span lang="en-us" xml:lang="en-us">BCBX</span><span style="font-family:'宋体';">做也行，只是把它当一个</span><span lang="en-us" xml:lang="en-us">IDE</span><span style="font-family:'宋体';">环境而已。比如做后端的开发，用</span><span lang="en-us" xml:lang="en-us">TAO</span><span style="font-family:'宋体';">做</span><span lang="en-us" xml:lang="en-us">CORBA</span><span style="font-family:'宋体';">中间层，用</span><span lang="en-us" xml:lang="en-us">DBX</span><span style="font-family:'宋体';">访问数据库，客户端通过</span><span lang="en-us" xml:lang="en-us">IIOP</span><span style="font-family:'宋体';">连接实现</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:50:25 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：它只要提供一个</span><span lang="en-us" xml:lang="en-us">IDE</span><span style="font-family:'宋体';">，全部的开放引擎和</span><span lang="en-us" xml:lang="en-us">OpenSource</span><span style="font-family:'宋体';">的类库就可以了，最重要是那个引擎，有了这个就会有人为它移植其他类库的。哈哈，那时候的</span><span lang="en-us" xml:lang="en-us">BCBX</span><span style="font-family:'宋体';">就可以像现在的</span><span lang="en-us" xml:lang="en-us">Eclipse</span><span style="font-family:'宋体';">那样本身只是一个框架。不知道会不会是这个样子</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:51:29 </span><span style="font-family:'宋体';">猛禽：理想很好，但希望不大，</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">还要靠</span><span lang="en-us" xml:lang="en-us">BCBX</span><span style="font-family:'宋体';">赚钱的。而</span><span lang="en-us" xml:lang="en-us">ECLIPSE</span><span style="font-family:'宋体';">是</span><span lang="en-us" xml:lang="en-us">IBM</span><span style="font-family:'宋体';">靠</span><span lang="en-us" xml:lang="en-us">VISUAL AGE</span><span style="font-family:'宋体';">已经赚不到钱了，才</span><span lang="en-us" xml:lang="en-us">OPENSOURCE</span><span style="font-family:'宋体';">出来诞生的</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:52:40 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：不过其实</span><span lang="en-us" xml:lang="en-us">BCBX</span><span style="font-family:'宋体';">给我们提供了很不错的思路，我想过不了多久就会有类似的</span><span lang="en-us" xml:lang="en-us">OpenSource</span><span style="font-family:'宋体';">项目出现的</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:52:41 </span><span style="font-family:'宋体';">猛禽：如果</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">在</span><span lang="en-us" xml:lang="en-us">BCBX</span><span style="font-family:'宋体';">中没有一点自己的东西，赚钱很难</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:53:18 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：那是当然了。</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:53:31 </span><span style="font-family:'宋体';">猛禽：现在的</span><span lang="en-us" xml:lang="en-us">BCBX</span><span style="font-family:'宋体';">中编译器可以用</span><span lang="en-us" xml:lang="en-us">G++</span><span style="font-family:'宋体';">或</span><span lang="en-us" xml:lang="en-us">INTEL</span><span style="font-family:'宋体';">的，以后</span><span lang="en-us" xml:lang="en-us">GUI</span><span style="font-family:'宋体';">的</span><span lang="en-us" xml:lang="en-us">FRAMEWORK</span><span style="font-family:'宋体';">又用</span><span lang="en-us" xml:lang="en-us">WXWIN</span><span style="font-family:'宋体';">，</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">靠什么赚钱？我很怀疑</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:53:46 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：现在</span><span lang="en-us" xml:lang="en-us">Borland</span><span style="font-family:'宋体';">的实力还只能靠产品赚钱</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:54:12 </span><span style="font-family:'宋体';">猛禽：现在</span><span lang="en-us" xml:lang="en-us">BCBX</span><span style="font-family:'宋体';">里唯一值钱的就是</span><span lang="en-us" xml:lang="en-us">DBX</span><span style="font-family:'宋体';">了，这算是</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">做</span><span lang="en-us" xml:lang="en-us">KYLIX</span><span style="font-family:'宋体';">得到的最大的收获</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:54:48 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：在没有类似产品出现之前，它的这个架构还是很吸引人的。应该会有人感兴趣</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:54:52 </span><span style="font-family:'宋体';">猛禽：关注</span><span lang="en-us" xml:lang="en-us">BCBX2</span><span style="font-family:'宋体';">会有什么表现，除了</span><span lang="en-us" xml:lang="en-us">WXWIN</span><span style="font-family:'宋体';">以外，</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">应该要提供一些更有价值的东东才行，至少应该加入对</span><span lang="en-us" xml:lang="en-us">VCL</span><span style="font-family:'宋体';">的兼容，否则将使绝大部分</span><span lang="en-us" xml:lang="en-us">BCB/KYLIX</span><span style="font-family:'宋体';">用户流失，虽然现在已经流失部分了。</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:56:30 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：</span><span lang="en-us" xml:lang="en-us">VCL</span><span style="font-family:'宋体';">的兼容是肯定有的，问题是以什么形式提供。</span><span lang="en-us" xml:lang="en-us">Borland</span><span style="font-family:'宋体';">不可能这么傻。它的</span><span lang="en-us" xml:lang="en-us">BCB3</span><span style="font-family:'宋体';">还提供</span><span lang="en-us" xml:lang="en-us">OWL</span><span style="font-family:'宋体';">的兼容呢</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:57:30 </span><span style="font-family:'宋体';">猛禽：但对</span><span lang="en-us" xml:lang="en-us">CLX</span><span style="font-family:'宋体';">的兼容我是不抱希望了，毕竟</span><span lang="en-us" xml:lang="en-us">CLX</span><span style="font-family:'宋体';">的用户还少，保持兼容的代价太大</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:57:56 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：呵呵，我一直认为这个</span><span lang="en-us" xml:lang="en-us">CLX</span><span style="font-family:'宋体';">有点鸡肋，不知道到底有多少人在用</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:58:09 </span><span style="font-family:'宋体';">猛禽：刚开始看</span><span lang="en-us" xml:lang="en-us">CLX</span><span style="font-family:'宋体';">还是不错的，保持和</span><span lang="en-us" xml:lang="en-us">VCL</span><span style="font-family:'宋体';">几乎一样的用法，但同时提供跨平台访问能力，可惜它的底层库选择错误，如果一开始选择</span><span lang="en-us" xml:lang="en-us">WXWIN</span><span style="font-family:'宋体';">就好多了。别的</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">还有什么可以提供的？</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:59:06 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：不过</span><span lang="en-us" xml:lang="en-us">Borland</span><span style="font-family:'宋体';">收购的</span><span lang="en-us" xml:lang="en-us">Together</span><span style="font-family:'宋体';">还有一家什么公司，对</span><span lang="en-us" xml:lang="en-us">Borland</span><span style="font-family:'宋体';">的帮助应该会很大。</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 16:59:18 </span><span style="font-family:'宋体';">猛禽：一个是</span><span lang="en-us" xml:lang="en-us">TOGETHER</span><span style="font-family:'宋体';">，一个是</span><span lang="en-us" xml:lang="en-us">BOLD</span><span style="font-family:'宋体';">。这是目前</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">最有希望赚到钱的方面。</span><span lang="en-us" xml:lang="en-us">ECO</span><span style="font-family:'宋体';">是目前</span><span lang="en-us" xml:lang="en-us">.net</span><span style="font-family:'宋体';">平台下第一个</span><span lang="en-us" xml:lang="en-us">ORMAPPING</span><span style="font-family:'宋体';">的解决方案</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 17:00:05 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：这两家都是提供企业级产品的，而且口碑都不促，这样的产品融合到</span><span lang="en-us" xml:lang="en-us">Borland</span><span style="font-family:'宋体';">的产品里，对客户吸引力还是很大的</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 17:00:23 </span><span style="font-family:'宋体';">猛禽：</span><span lang="en-us" xml:lang="en-us">TOGETHER</span><span style="font-family:'宋体';">又提供了在。</span><span lang="en-us" xml:lang="en-us">NET/JAVA</span><span style="font-family:'宋体';">下的</span><span lang="en-us" xml:lang="en-us">MDA</span><span style="font-family:'宋体';">开发能力，这是</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">目前最有优势的方面。</span><span lang="en-us" xml:lang="en-us">BCBX</span><span style="font-family:'宋体';">集成了</span><span lang="en-us" xml:lang="en-us">TOGETHER</span><span style="font-family:'宋体';">如果不能加强自身的企业应用开发能力，还是白搭</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 17:01:32 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：我觉得</span><span lang="en-us" xml:lang="en-us">Borland</span><span style="font-family:'宋体';">还是可以走它原来的长处，就是整合不同的技术。原来的对</span><span lang="en-us" xml:lang="en-us">DCOM</span><span style="font-family:'宋体';">和</span><span lang="en-us" xml:lang="en-us">Corba</span><span style="font-family:'宋体';">的集成就很有特点，这次的</span><span lang="en-us" xml:lang="en-us">C#Builder</span><span style="font-family:'宋体';">提供了对</span><span lang="en-us" xml:lang="en-us">Java</span><span style="font-family:'宋体';">的集成也很有个性。</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 17:01:53 </span><span style="font-family:'宋体';">猛禽：关键看</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">将在</span><span lang="en-us" xml:lang="en-us">BCBX</span><span style="font-family:'宋体';">中采用什么技术来实现</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 17:02:02 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：所以我开始就说了，我希望</span><span lang="en-us" xml:lang="en-us">Borland</span><span style="font-family:'宋体';">能凭借</span><span lang="en-us" xml:lang="en-us">BCBX</span><span style="font-family:'宋体';">整合出一套企业级的</span><span lang="en-us" xml:lang="en-us">Framework </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 17:02:32 </span><span style="font-family:'宋体';">猛禽：从利益的角度上说，</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">一定会整合</span><span lang="en-us" xml:lang="en-us">BES</span><span style="font-family:'宋体';">（即原来的</span><span lang="en-us" xml:lang="en-us">VISIBROKER</span><span style="font-family:'宋体';">）。但我不看好</span><span lang="en-us" xml:lang="en-us">BES</span><span style="font-family:'宋体';">，因为在</span><span lang="en-us" xml:lang="en-us">CORBA</span><span style="font-family:'宋体';">领域，</span><span lang="en-us" xml:lang="en-us">BES</span><span style="font-family:'宋体';">不是</span><span lang="en-us" xml:lang="en-us">ORBIX</span><span style="font-family:'宋体';">的对手，在</span><span lang="en-us" xml:lang="en-us">EJB</span><span style="font-family:'宋体';">领域，更不是</span><span lang="en-us" xml:lang="en-us">WEBLOGIC/WEBSPHERE</span><span style="font-family:'宋体';">的对手</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 17:02:42 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：是的。呵呵，这个领域我不熟悉。可是它不用去做</span><span lang="en-us" xml:lang="en-us">J2EE</span><span style="font-family:'宋体';">的容器，它只要做一个中间层就可以了</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 17:03:41 </span><span style="font-family:'宋体';">猛禽：再说</span><span lang="en-us" xml:lang="en-us">BES</span><span style="font-family:'宋体';">是用</span><span lang="en-us" xml:lang="en-us">JAVA</span><span style="font-family:'宋体';">写的，性能上不能完全发挥</span><span lang="en-us" xml:lang="en-us">C++</span><span style="font-family:'宋体';">的优势，</span><span lang="en-us" xml:lang="en-us">IDE</span><span style="font-family:'宋体';">是因为有图形界面，为了使它表现一致，用</span><span lang="en-us" xml:lang="en-us">JAVA</span><span style="font-family:'宋体';">开发我可以理解，但中间层应用没有</span><span lang="en-us" xml:lang="en-us">GUI</span><span style="font-family:'宋体';">，完全可以用</span><span lang="en-us" xml:lang="en-us">C++</span><span style="font-family:'宋体';">来实现，而最方便的莫过于采用</span><span lang="en-us" xml:lang="en-us">TAO</span><span style="font-family:'宋体';">这样的现成方案，这就要看</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">舍不舍得牺牲</span><span lang="en-us" xml:lang="en-us">BES</span><span style="font-family:'宋体';">了。不过还有一个方案就是像</span><span lang="en-us" xml:lang="en-us">MIDAS</span><span style="font-family:'宋体';">一样，提供一个通用的开发技术（中间层的</span><span lang="en-us" xml:lang="en-us">FRAMEWORK</span><span style="font-family:'宋体';">），底层可以自由选择，这样最好。现在用</span><span lang="en-us" xml:lang="en-us">C++</span><span style="font-family:'宋体';">实现的</span><span lang="en-us" xml:lang="en-us">CORBA</span><span style="font-family:'宋体';">方案中，比较好的就那么几个。像</span><span lang="en-us" xml:lang="en-us">MICO</span><span style="font-family:'宋体';">虽然不错，可是它对</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">的编译器兼容性不好，我曾经为了用</span><span lang="en-us" xml:lang="en-us">BCB6</span><span style="font-family:'宋体';">编译这玩意儿，改了它</span><span lang="en-us" xml:lang="en-us">N</span><span style="font-family:'宋体';">多源码，还是未完全成功。后来发现</span><span lang="en-us" xml:lang="en-us">TAO</span><span style="font-family:'宋体';">，它支持的编译器非常多（据我所知是所以</span><span lang="en-us" xml:lang="en-us">C++ CORBA</span><span style="font-family:'宋体';">方案中最多的）。现在多层技术就是三种：</span><span lang="en-us" xml:lang="en-us">COM</span><span style="font-family:'宋体';">系列</span><span lang="en-us" xml:lang="en-us">/CORBA/EJB</span><span style="font-family:'宋体';">。能用于</span><span lang="en-us" xml:lang="en-us">C++</span><span style="font-family:'宋体';">而跨平台的，只有</span><span lang="en-us" xml:lang="en-us">CORBA</span><span style="font-family:'宋体';">。</span><span lang="en-us" xml:lang="en-us">BCBX</span><span style="font-family:'宋体';">要是能在这点上做得好，还是很有前途的。</span><span lang="en-us" xml:lang="en-us">EJB</span><span style="font-family:'宋体';">是兼容</span><span lang="en-us" xml:lang="en-us">CORBA</span><span style="font-family:'宋体';">的，通过</span><span lang="en-us" xml:lang="en-us">RMI over IIOP</span><span style="font-family:'宋体';">可以直接访问</span><span lang="en-us" xml:lang="en-us">CORBA</span><span style="font-family:'宋体';">对象。只要</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">在</span><span lang="en-us" xml:lang="en-us">.net</span><span style="font-family:'宋体';">中提供</span><span lang="en-us" xml:lang="en-us">CORBA</span><span style="font-family:'宋体';">解决方案就好，反正现在</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">已经有了一系列</span><span lang="en-us" xml:lang="en-us">.net</span><span style="font-family:'宋体';">产品，开发一个像李维说的</span><span lang="en-us" xml:lang="en-us">Corba.net</span><span style="font-family:'宋体';">，应该是可以的</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 17:10:51 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：那是的</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 17:11:21 </span><span style="font-family:'宋体';">猛禽：而且正好现在</span><span lang="en-us" xml:lang="en-us">.net</span><span style="font-family:'宋体';">上的多层技术还空着，</span><span lang="en-us" xml:lang="en-us">MS</span><span style="font-family:'宋体';">现在在</span><span lang="en-us" xml:lang="en-us">.net</span><span style="font-family:'宋体';">中是用</span><span lang="en-us" xml:lang="en-us">COM+</span><span style="font-family:'宋体';">，相对来说比起</span><span lang="en-us" xml:lang="en-us">.net</span><span style="font-family:'宋体';">来说算是比较落伍的</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 17:13:00 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：不过按</span><span lang="en-us" xml:lang="en-us">.NET</span><span style="font-family:'宋体';">的能力，开发中间层问题不大，只是现在的</span><span lang="en-us" xml:lang="en-us">.NET</span><span style="font-family:'宋体';">还没有成熟而已</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 17:13:56 </span><span style="font-family:'宋体';">猛禽：如果</span><span lang="en-us" xml:lang="en-us">CORBA.net</span><span style="font-family:'宋体';">能在</span><span lang="en-us" xml:lang="en-us">MS</span><span style="font-family:'宋体';">下一代中间层技术出来前抢占市场，对</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">就会非常有利</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 17:14:08 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：对，没错</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 17:14:11 </span><span style="font-family:'宋体';">猛禽：</span><span lang="en-us" xml:lang="en-us">EJB</span><span style="font-family:'宋体';">也是在</span><span lang="en-us" xml:lang="en-us">JAVA</span><span style="font-family:'宋体';">出来三四年后才出现的。</span><span lang="en-us" xml:lang="en-us">.net</span><span style="font-family:'宋体';">现在才出来两三年，</span><span lang="en-us" xml:lang="en-us">Corba.net</span><span style="font-family:'宋体';">还有机会。就要看</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">怎么做了</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 17:14:59 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：而且</span><span lang="en-us" xml:lang="en-us">J2EE</span><span style="font-family:'宋体';">整个都还在不断发展和演化，</span><span lang="en-us" xml:lang="en-us">1.2</span><span style="font-family:'宋体';">还不支持</span><span lang="en-us" xml:lang="en-us">WebService</span><span style="font-family:'宋体';">呢</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 17:15:12 </span><span style="font-family:'宋体';">猛禽：</span><span lang="en-us" xml:lang="en-us">OMG</span><span style="font-family:'宋体';">制定的</span><span lang="en-us" xml:lang="en-us">Corba 3.0</span><span style="font-family:'宋体';">规范已经在赶超</span><span lang="en-us" xml:lang="en-us">EJB</span><span style="font-family:'宋体';">和</span><span lang="en-us" xml:lang="en-us">COM+</span><span style="font-family:'宋体';">了</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 17:15:23 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：呵呵，我们帮</span><span lang="en-us" xml:lang="en-us">Borland</span><span style="font-family:'宋体';">出这么多主意，不知道他们自己怎么打算的</span><span lang="en-us" xml:lang="en-us"> </span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 17:16:45 </span><span style="font-family:'宋体';">猛禽：李维是</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">的人，出的主意</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">都不一定听，更何况我们这样的无名小卒</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">2003-12-11 17:19:31 </span><span style="font-family:'宋体';">令狐虫</span><span lang="en-us" xml:lang="en-us">()</span><span style="font-family:'宋体';">：其实我倒觉得</span><span lang="en-us" xml:lang="en-us">Borland</span><span style="font-family:'宋体';">是在给我们提供了很多新的思路，原先我肯定想不到</span><span lang="en-us" xml:lang="en-us">BCBX</span><span style="font-family:'宋体';">可以这么走。这点来说还是很佩服</span><span lang="en-us" xml:lang="en-us">Borland</span><span style="font-family:'宋体';">的。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 27pt;text-indent:-27pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> &lt;?xml:namespace prefix = o ns = "urn:schemas-microsoft-com:office:office" /&gt;</font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:27pt;"><font size="3"><span style="font-family:'宋体';">在本文写到一半时，刚刚从</span><span lang="en-us" xml:lang="en-us">ChinaBCB—http://www.chinabcb.com</span><span style="font-family:'宋体';">上得到一些关于</span><span lang="en-us" xml:lang="en-us">BCBX2</span><span style="font-family:'宋体';">的好消息（原始出处为</span><span lang="en-us" xml:lang="en-us">--http://wxwindows.sourceforge.net</span><span style="font-family:'宋体';">）：</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">BCBX2</span><span style="font-family:'宋体';">已经在开发中，可能会在未来几个月内发布。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:27pt;"><font size="3"><span lang="en-us" xml:lang="en-us">BCBX2</span><span style="font-family:'宋体';">将包含完整的编译器，</span><span lang="en-us" xml:lang="en-us">Designer</span><span style="font-family:'宋体';">，</span><span lang="en-us" xml:lang="en-us">Object Inspector</span><span style="font-family:'宋体';">。新的</span><span lang="en-us" xml:lang="en-us">BCBX</span><span style="font-family:'宋体';">编译器将是全新开发的，据说与以前的编译器不可同日而语，并且它应该还可以兼容</span><span lang="en-us" xml:lang="en-us">VCL</span><span style="font-family:'宋体';">。</span><span lang="en-us" xml:lang="en-us">Designer</span><span style="font-family:'宋体';">拥有对不同的</span><span lang="en-us" xml:lang="en-us">Framework</span><span style="font-family:'宋体';">的整合能力（有一个</span><span lang="en-us" xml:lang="en-us">DEMO</span><span style="font-family:'宋体';">演示了对</span><span lang="en-us" xml:lang="en-us">wxWindows</span><span style="font-family:'宋体';">和</span><span lang="en-us" xml:lang="en-us">JavaBean</span><span style="font-family:'宋体';">的支持）。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:27pt;"><font size="3"><span style="font-family:'宋体';">对于</span><span lang="en-us" xml:lang="en-us">VCL</span><span style="font-family:'宋体';">用户来说，也不用再担心</span><span lang="en-us" xml:lang="en-us">VCL</span><span style="font-family:'宋体';">的未来了，已经确定在</span><span lang="en-us" xml:lang="en-us">BCBX2</span><span style="font-family:'宋体';">中会有一个与</span><span lang="en-us" xml:lang="en-us">BCB</span><span style="font-family:'宋体';">非常相似的被称为“</span><span lang="en-us" xml:lang="en-us">VCL Bridge</span><span style="font-family:'宋体';">”的实现。它支持对已有的</span><span lang="en-us" xml:lang="en-us">BCB</span><span style="font-family:'宋体';">项目进行打开、编辑、设计、更新等操作，就像是现在的</span><span lang="en-us" xml:lang="en-us">VCL</span><span style="font-family:'宋体';">设计器一样（如</span><span lang="en-us" xml:lang="en-us">BCB</span><span style="font-family:'宋体';">或</span><span lang="en-us" xml:lang="en-us">DELPHI</span><span style="font-family:'宋体';">）。不过</span><span lang="en-us" xml:lang="en-us">BCBX</span><span style="font-family:'宋体';">支持的</span><span lang="en-us" xml:lang="en-us">VCL</span><span style="font-family:'宋体';">不会再作改进，只是兼容现有的</span><span lang="en-us" xml:lang="en-us">VCL</span><span style="font-family:'宋体';">，</span><span lang="en-us" xml:lang="en-us">BORLAND</span><span style="font-family:'宋体';">建议将现有的</span><span lang="en-us" xml:lang="en-us">BCB VCL</span><span style="font-family:'宋体';">应用程序向两个方向转移：一个是用</span><span lang="en-us" xml:lang="en-us">Managed C++</span><span style="font-family:'宋体';">移植到</span><span lang="en-us" xml:lang="en-us">.net</span><span style="font-family:'宋体';">或用</span><span lang="en-us" xml:lang="en-us">wxWindows</span><span style="font-family:'宋体';">移植成跨平台应用。至于所谓的这个“现有版本的</span><span lang="en-us" xml:lang="en-us">VCL</span><span style="font-family:'宋体';">”是哪个版本尚未确定，可能是</span><span lang="en-us" xml:lang="en-us">BCB6</span><span style="font-family:'宋体';">的，也可能是</span><span lang="en-us" xml:lang="en-us">DELPHI7</span><span style="font-family:'宋体';">甚至</span><span lang="en-us" xml:lang="en-us">DELPHI8</span><span style="font-family:'宋体';">（去掉其中</span><span lang="en-us" xml:lang="en-us">.net</span><span style="font-family:'宋体';">部分）中的</span><span lang="en-us" xml:lang="en-us">VCL</span><span style="font-family:'宋体';">。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:27pt;"><font size="3"><span style="font-family:'宋体';">至于</span><span lang="en-us" xml:lang="en-us">COM/ActiveX</span><span style="font-family:'宋体';">等，可能会被支持。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:27pt;"><font size="3"><span class="postbody"><span style="font-family:'宋体';">如果对下个版本的</span><span lang="en-us" xml:lang="en-us">BCBX</span></span><span class="postbody"><span style="font-family:'宋体';">有什么建议和要求，请给</span><span lang="en-us" xml:lang="en-us">BORLAND</span></span><span class="postbody"><span style="font-family:'宋体';">发邮件并说明理由：</span><span lang="en-us" xml:lang="en-us"><a href="mailto:cpp_open_letter@borland.com"><font color="#006699">cpp_open_letter@borland.com</font></a></span></span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:27pt;"><font size="3"><span class="postbody"><span style="font-family:'宋体';">那篇文章除了上面说的这些，还有一段很长的答疑内容，专门回答</span><span lang="en-us" xml:lang="en-us">BCB</span></span><span class="postbody"><span style="font-family:'宋体';">用户对</span><span lang="en-us" xml:lang="en-us">BCBX</span></span><span class="postbody"><span style="font-family:'宋体';">的各种疑问，所有对</span><span lang="en-us" xml:lang="en-us">BCBX</span></span><span class="postbody"><span style="font-family:'宋体';">有疑问的</span><span lang="en-us" xml:lang="en-us">BCB</span></span><span class="postbody"><span style="font-family:'宋体';">开发人员相信都可以在这个答疑里找到满意的答案。</span><span lang="en-us" xml:lang="en-us"></span></span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:27pt;"><font size="3"><span class="postbody"><span style="font-family:'宋体';">看来</span><span lang="en-us" xml:lang="en-us">BCBX2</span></span><span class="postbody"><span style="font-family:'宋体';">还是很值得期待的，只是我所期望的企业应用开发的</span><span lang="en-us" xml:lang="en-us">Feature</span></span><span class="postbody"><span style="font-family:'宋体';">暂时还没能实现。</span></span></font></p>                </div>                    </div>
4926	 《C#入门与提高》	c#  语言  web服务  internet  开发工具  平台  	990508080	1256	yousoft	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <h2 align="center">《C#入门与提高》</h2><h3 align="center">前言</h3><table align="center" border="0" cellpadding="0" cellspacing="0" width="884"><tbody><tr><td><ol><li><i>C#介绍 </i><br/>我们知道，C和C++已经成为广泛的应用在商用软件的开发中的开发语言。但是C和C++的灵活性是牺牲了开发效率的。如果与其他的开发语言相比（比如说VB，Delphi），相同功能的C/C++软件通常会需要更长的开发周期，要写更多的代码。正是由于C/C++开发的复杂性和需要较长的开发周期，所以许多C/C++开发人员都在寻找一种可以在功能和开发效率间提高更多平衡的开发语言。 于是Microsoft想到了C#（发音为 C Sharp），并推出了C#。2000年6月　微软发布C#语言和.NET平台。C#语言是一种强类型的、面向对象的语言、它具有语法简单、表达力强的特点；而.NET平台则是构成微软的“.NET计划”的基石。.NET平台的核心包括两方面　一方面就是著名的通用语言运行机(Common Language Runtime)　虽然这个名词起得晦涩了点　不过大家可以拿它和Java的虚拟机来作比较，二者完成的任务大致相同，另一方面就是一大堆通用函数库，这些库函数可以被多种语言调用，并且通过编译都产生一种共同的中间语言（Intermediate Language），这种语言也可以拿Java的字节码来类比，虽然完成的方式有些不一样。C#是一种先进，面向对象的语言，通过C#可以让开发人员快速的建立大范围的基于MS网络平台的应用，并且提供大量的开发工具和服务帮助开发人员开发基于计算和通信的各种应用。 正是由于C#是一种面向对象的开发语言，所以C#可以大范围的适用于高层商业应用和底层系统的开发。即使是通过简单的C#构造也可以各种组件方便的转变为基于WEB的应用，并且能够通过Internet被各种系统或是其他开发语言所开发的应用调用。 <br/>它有以下的特点： <table align="center" border="1" width="711"><tbody><tr><td><p><b><font color="#0000ff">开发效率与安全性 </font></b><br/>目前的各种基于WEB应用的软件开发向传统的商业应用软件开发提出了挑战，开发者被组织起来开发具有更短开发周期的各种应用，并且需要能够提供更好的可修正性，而不是建立一个可以长久使用的软件系统。 <br/>C#的设计正是充分考虑了这些因素。C#会帮助开发者通过更少的代码完成相同的功能，并且能够更好的避免错误发生。 <br/><b><font color="#0000ff">与WEB开发相结合</font></b><br/>新的开发模式意味着需要更好的利用现有的各种WEB标准，例如HTML，XML，SOAP（简单对象存取协议）。现存的开发工具是在Internet出现前或是未得到充分应用前出现的，所以都不能很好的适应目前WEB技术的开发需要。 <br/>C#开发者可以方便的在M$网络平台上扩展自己的应用。C#可以将任何组件转变为WEB服务，并且可以被运行于Internet上的任何平台的任何应用调用，重要的是C#对这一特性提供了内置的支持。 <br/>更重要的一点，WEB服务框架可以让任何WEB服务都看起来类似于C#的内置对象，所以可以让开发人员在开发过程中继续使用他们已经具备的面向对象的开发方法和技巧。 <br/>此外C#还拥有许多其他特性使自己成为最出色的Internet开发工具。例如，XML目前已经成为网络中数据结构传送的标准，为了提高效率C#将允许直接将XML数据映射成为结构。这样的话可以有效的处理各种数据。 <br/><b><font color="#0000ff">减小开发中的错误 </font></b><br/>即使是优秀的C/C++开发人员都难于避免在编码过程出现一些常见错误，比如错误的初始化一个变量，而这种错误将有可能导致各种不可以预知的错误，并且难于被发现。如果一旦错误在发现前被投入生产环境，排除这些错误将会付出昂贵的代价。而C#的先进设计思想可以消除C/C++开发中的许多常见错误，比如： <br/>垃圾收集机制将减轻开发人员对内存的管理负担。 C#中的变量将自动根据环境被初始化。 变量是类型安全的。 使用C#将会使开发人员更加轻易的开发和维护各种商业应用。 <br/>提供内置的版本支持来减少开发费用 <br/>更新软件系统中的组件（模块）将会是一种容易产生错误的工作，在代码修改过程中可能对现存的软件产生影响。为了帮助开发人员处理这些问题，C#在语言中内置了版本控制功能。例如：函数重载必须被显式的声明（这种情况在C++和JAVA中时常发生），这可以防止代码级错误和保留版本化的特性。另一个相关的特性是接口和接口继承的支持。这些特性可以保证复杂的软件可以被方便的开发和升级。 <br/>总结起来，这些特性可以帮助开发更强壮的软件后继版本和减轻开发费用。 <br/><font color="#0000ff"><b>功能强，易于表现，灵活 </b></font><br/>更好的结合商业应用中的流程与软件实现 <br/>为了更好实现公司的各种商业计划，在软件系统中必须在商业流程和软件实现间有紧密的联系。但是大多数的开发语言都不能轻易的将各种应用逻辑与代码相联系。例如，开发人员会使用各种注释来标明各种类所代表抽象商业对象。C#允许使用在任何对象上使用预定义数据或是经过扩展的元数据。在系统结构中可以使用区域属性（译者：类似NT的网络域结构），并且将这些属性添加到类，接口或者其他元素上。开发者可以独立的测试各种元素上的属性。这将会使得一些如同收集区域中对象属性，或是编写自动工具来保证的区域中的类，接口是否被正确定义的类似工作变得简单。 <br/><b><font color="#0000ff">可扩展的协作能力 </font></b><br/>虽然管理性强，透明型好，类型安全的开发环境对大多的商业应用都适合，但现实的经验告诉我们一些应用出于执行效率或是与现存的应用接口API相结合的原因需要使用原有的开发方式来进行编码。也正是如此，许多C/C++开发人员宁愿放弃使用一些可以提高开发效率的开发工具。C#通过下面的方法来解决这些问题： <br/>内置支持COM模型和Windows平台API。 <br/>允许有限制的使用指针。 <br/>在C#中任何对象都会自动成为COM对象，开发者不再需要显式的实现IUnknown和其他一些COM接口，同时也可以方便而自然的使用现存的COM对象，而不需要关心这些COM对象是否使用C#开发。 <br/>对于使用C#的开发人员来讲，C#允许开发人员调用OS所提供的API。在经过标记的代码区域内使用指针并手工管理内存分配。这可以让C/C++开发人员更快的熟悉和转向C#和并且不需要放弃在以前开发中所形成的开发习惯，而且以前的C/C++代码依然可以被重用。无论是对于COM的支持还是对于API调用的支持都是为了为开发人员提供足够的开发控制能力。 </p></td></tr></tbody></table><br/></li><li><i>C#和Java</i><br/><table align="center" border="1" width="711"><tbody><tr><td>二者都编译成跨平台的,跨语言的代码,并且代码只能在一个受控制的环境中运行<br/>自动回收垃圾内存,并且消除了指针（在C#中可以使用指针,不过必须注明unsafe关键字）<br/>都不需要头文件,所有的代码都被“包(package)”限制在某个范围内,并且因为没有头文件,所以消除了类定义的循环依赖<br/>所有的类都是从对象派生出来,并且必须使用New关键字分配内存<br/>用对象加锁的方式来支持多线程<br/>都具有接口(interface)的概念<br/>继承类的时候不会以某种特定的访问权限来继承<br/>没有全局函数或者常量,一切必须属于类<br/>数组或者字符串都自带长度计算和边界检查<br/>只使用“.”操作符,没有“-&gt;”和“::”<br/>“null”,“boolean”和“bool”成为了关键字<br/>任何变量均在使用前进行初始化<br/>不能使用整数来返回到if条件语句中,必须使用布尔值<br/>“Try”模块後可以有“finally” </td></tr></tbody></table><br/></li></ol><i>总之，C#是一种先进的，面向对象的开发语言，并且能够方便快捷的MS网络平台建立各种应用和建立能够在网络间相互调用的WEB服务。从开发语言的角度来讲C#可以更好帮助开发人员避免错误，提高工作效率，而且同时具有C/C++的强大功能。</i> </td></tr></tbody></table>                </div>                    </div>
4980	 CRM认识误区	crm  电子商务  数据库  function  internet  物流  	1026263820	1347	Drate	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <div align="center"><table border="0" cellpadding="0" cellspacing="0" width="92%"><tbody><tr><td colspan="3" style="border-right:#c0c0c0;padding-right:0cm;border-top:#c0c0c0;padding-left:0cm;padding-bottom:0cm;border-left:#c0c0c0;padding-top:.75pt;border-bottom:#c0c0c0;background-color:transparent;"><p align="center" style="line-height:120%;text-align:center;"><b><span lang="en-us" style="font-size:13.5pt;font-family:Arial;" xml:lang="en-us">CRM</span></b><font face="宋体"><b><span style="font-size:13.5pt;">认识误区</span></b><b><span lang="en-us" style="font-size:13.5pt;font-family:Arial;" xml:lang="en-us">&lt;?xml:namespace prefix = o ns = "urn:schemas-microsoft-com:office:office" /&gt;</span></b></font></p><p><b></b></p><b></b></td></tr><tr><td style="border-right:#c0c0c0;padding-right:0cm;border-top:#c0c0c0;padding-left:0cm;padding-bottom:0cm;border-left:#c0c0c0;padding-top:.75pt;border-bottom:#c0c0c0;background-color:transparent;" width="218"><p class="MsoNormal" style="margin:0cm 0cm 0pt;line-height:120%;"><span lang="en-us" style="font-size:9pt;font-family:Arial;" xml:lang="en-us">2001-06-27 09:35</span></p><p></p></td><td style="border-right:#c0c0c0;padding-right:0cm;border-top:#c0c0c0;padding-left:0cm;padding-bottom:0cm;border-left:#c0c0c0;padding-top:.75pt;border-bottom:#c0c0c0;background-color:transparent;" width="288"><p align="right" class="MsoNormal" style="margin:0cm 0cm 0pt;line-height:120%;text-align:right;"><span style="font-size:9pt;font-family:'宋体';">整理稿</span><span lang="en-us" style="font-size:9pt;font-family:Arial;" xml:lang="en-us">/( ) </span></p><p></p></td><td style="border-right:#c0c0c0;padding-right:0cm;border-top:#c0c0c0;padding-left:0cm;padding-bottom:0cm;border-left:#c0c0c0;padding-top:0cm;border-bottom:#c0c0c0;background-color:transparent;"><p class="MsoNormal" style="margin:0cm 0cm 0pt;"> <span lang="en-us" style="font-size:10pt;" xml:lang="en-us"></span></p><p></p></td></tr><tr><td colspan="3" style="border-right:#c0c0c0;padding-right:0cm;border-top:#c0c0c0;padding-left:0cm;padding-bottom:0cm;border-left:#c0c0c0;padding-top:.75pt;border-bottom:#c0c0c0;background-color:transparent;" valign="top"><div align="center" class="MsoNormal" style="margin:0cm 0cm 0pt;line-height:120%;text-align:center;"><span lang="en-us" style="font-size:9pt;font-family:Arial;" xml:lang="en-us"><font size="3"></font></span></div><p class="MsoNormal" style="margin:0cm 0cm 0pt;line-height:130%;"><span lang="en-us" style="font-size:9pt;font-family:Arial;" xml:lang="en-us"><a href="http://ad.cn.doubleclick.net/jump/gb.chinabyte.com/sponsor-button/a01080019/sm/cb-pip_1x1;sz=1x1;ord=95532297716085470?"><span style="color:#103e97;text-decoration:none;">&lt;?xml:namespace prefix = v ns = "urn:schemas-microsoft-com:vml" /&gt;<font size="3"></font></span></a></span><span lang="en-us" style="font-family:Arial;" xml:lang="en-us"></span></p><p></p><table align="right" border="0" cellpadding="0" cellspacing="0" width="360"><tbody><tr><td style="border-right:#c0c0c0;padding-right:0cm;border-top:#c0c0c0;padding-left:0cm;padding-bottom:0cm;border-left:#c0c0c0;padding-top:.75pt;border-bottom:#c0c0c0;background-color:transparent;"><p class="MsoNormal" style="margin:0cm 0cm 0pt;line-height:120%;"> <span lang="en-us" style="font-size:9pt;font-family:Arial;" xml:lang="en-us"></span></p><p></p></td></tr></tbody></table><p style="line-height:130%;"><span style="font-size:10.5pt;"><font face="宋体">　　</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM(</span><span style="font-size:10.5pt;"><font face="宋体">客户关系管理</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">)</span><span style="font-size:10.5pt;"><font face="宋体">已非新出的概念，但是要正确理解</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span><span style="font-size:10.5pt;"><font face="宋体">，相信会有很多人对它都存在一定的误解。下面，通过对</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span><span style="font-size:10.5pt;"><font face="宋体">认识上可能出现的一系列问题进行整理，以避免走入认识</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span><font face="宋体"><span style="font-size:10.5pt;">的误区。</span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us"></span></font></p><p></p><p style="line-height:130%;"><span style="font-size:10.5pt;"><font face="宋体">　　</font></span><strong><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span></strong><font face="宋体"><strong><span style="font-size:10.5pt;">是软件——最大的误区</span></strong><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us"></span></font></p><p></p><p style="line-height:130%;"><span style="font-size:10.5pt;"><font face="宋体">　　</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span><font face="宋体"><span style="font-size:10.5pt;">是一种以客户为中心的管理思想，而软件是不能定制流程和制定策略的。</span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us"></span></font></p><p></p><p style="line-height:130%;"><span style="font-size:10.5pt;"><font face="宋体">　　</font></span><strong><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span></strong><font face="宋体"><strong><span style="font-size:10.5pt;">一定要用呼叫中心</span></strong><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us"></span></font></p><p></p><p style="line-height:130%;"><span style="font-size:10.5pt;"><font face="宋体">　　呼叫中心可以是</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span><font face="宋体"><span style="font-size:10.5pt;">的一个重要部分，但并不是必要的。与客户交互的形式是多种多样的。</span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us"></span></font></p><p></p><p style="line-height:130%;"><span style="font-size:10.5pt;"><font face="宋体">　　<strong>要做</strong></font></span><strong><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span></strong><strong><span style="font-size:10.5pt;"><font face="宋体">，先做</font></span></strong><strong><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">ERP</span></strong><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us"></span></p><p></p><p style="line-height:130%;"><span style="font-size:10.5pt;"><font face="宋体">　　对企业来说，先做</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span><span style="font-size:10.5pt;"><font face="宋体">还是</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">ERP</span><span style="font-size:10.5pt;"><font face="宋体">，取决于企业的商业模式。</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us"><br/> <br/></span><span style="font-size:10.5pt;"><font face="宋体">　　</font></span><strong><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span></strong><strong><span style="font-size:10.5pt;"><font face="宋体">是一对一营销</font></span></strong><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us"> </span></p><p></p><p style="line-height:130%;"><span style="font-size:10.5pt;"><font face="宋体">　　到目前为止，还没有什么营销原理能够指导客户关系管理活动，因而，</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span><span style="font-size:10.5pt;"><font face="宋体">应用开发商也就很难通过相关理论来推广其产品，唯一的选择就是针对一对一营销，同时，一对一营销也需要一些营销应用来证明其重要性，自然而然，一对一营销和</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span><span style="font-size:10.5pt;"><font face="宋体">之间形成了一种密不可分的伴侣关系。</font></span><span style="font-size:10.5pt;font-family:Arial;"> </span><span style="font-size:10.5pt;"><font face="宋体">这种关系让人们误以为</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span><span style="font-size:10.5pt;"><font face="宋体">就是一对一营销，但是这种关系对</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span><font face="宋体"><span style="font-size:10.5pt;">未来的发展十分有害：有时连我们自己也会承认一对一营销是关于客户关系，其实，只是一种可能的关系，即一对一客户关系；更为重要的是，这种与客户之间的一对一关系是不正确的。</span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us"></span></font></p><p></p><p style="line-height:130%;"><span style="font-size:10.5pt;"><font face="宋体">　　我在许多文章中都分析过，一对一营销并不是什么领先的理论。这是因为，第一，作为一种经营哲学，一对一营销本身具有伤害性，经理人员总是孤立顾客，对待不同的顾客采用不同的方法；第二，根据一对一营销原理，人们几乎不能开发任何营销应用方法（包括</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span><span style="font-size:10.5pt;"><font face="宋体">），许多表面上看来是一对一的应用，实际上是基于集成的营销方法。</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us"><br/> <br/></span><span style="font-size:10.5pt;"><font face="宋体">　　</font></span><strong><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span></strong><strong><span style="font-size:10.5pt;"><font face="宋体">是个性化营销</font></span></strong><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us"> </span></p><p></p><p style="line-height:130%;"><span style="font-size:10.5pt;"><font face="宋体">　　从技术的角度来看，现行的</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span><span style="font-size:10.5pt;"><font face="宋体">无疑于个性化营销，差别仅表现在个性化营销通常应用于网上经营的场合，因此甚至有些人试图创造一个新名词：</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">eCRM</span><span style="font-size:10.5pt;"><font face="宋体">，我认为完全没有必要，因为</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">eCRM</span><span style="font-size:10.5pt;"><font face="宋体">与个性化营销没有什么区别。</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us"><br/></span><span style="font-size:10.5pt;"><font face="宋体">　　</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us"> <br/></span><span style="font-size:10.5pt;"><font face="宋体">　　</font></span><strong><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span></strong><strong><span style="font-size:10.5pt;"><font face="宋体">是统计模型</font></span></strong><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us"> </span></p><p></p><p style="line-height:130%;"><font face="宋体"><span style="font-size:10.5pt;">　　在网络营销中，我遇到过两类人，一类人强烈反感统计，认为统计对营销没有实际价值，另一类人则认为，统计就是营销。</span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us"></span></font></p><p></p></td></tr></tbody></table></div><p class="MsoNormal" style="margin:0cm 0cm 0pt;line-height:130%;"><font size="3"><span style="font-family:'宋体';">我发现，对第一类人而言，产生这种观点的原因在于他们对统计知识了解太少，他们不知道营销理论的发展建立在统计模型的基础上，他们不了解统计对认识市场活动及制订有效的营销战略的重要性。</span><span style="font-family:Arial;"> </span><span style="font-family:'宋体';">例如，一对一营销的拥护者如果了解统计知识，他们就会知道，在独立客户信息的基础上不可能制订任何营销战略。一些一对一营销专家曾经评论细分市场多年，甚至不知道什么是市场细分，更谈不上细分市场的运作了。</span><span lang="en-us" style="font-family:Arial;" xml:lang="en-us"> </span></font></p><p></p><p style="line-height:130%;"><span style="font-size:10.5pt;"><font face="宋体">　　统计营销模型当然是制定营销战略的强大工具，在现行的</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span><span style="font-size:10.5pt;"><font face="宋体">应用中，通常使用大量复杂的统计模型，但是，</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span><font face="宋体"><span style="font-size:10.5pt;">并不就是统计模型。</span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us"></span></font></p><p></p><p style="line-height:130%;"><span style="font-size:10.5pt;"><font face="宋体">　　认为统计就是营销的一类人，通常拥有显赫的学历和统计方面的知识，曾经有一个博士对我是否有资格讨论营销问题提出疑问，他说，他了解半打统计模型，认为一个没有博士学位的人就没有资格谈论营销问题。我只是建议他先看一些营销研究的杂志，暗示他他的统计学知识还很有限，而且统计学并不等于营销研究。这类人认为，一旦研究出几个统计模型，便成了营销专家。</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us"> </span></p><p></p><p style="line-height:130%;"><span style="font-size:10.5pt;"><font face="宋体">　　</font></span><strong><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span></strong><font face="宋体"><strong><span style="font-size:10.5pt;">是数据库应用</span></strong><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us"></span></font></p><p></p><p style="line-height:130%;"><span style="font-size:10.5pt;"><font face="宋体">　　这可能有点费解，因为我们已经看到</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span><span style="font-size:10.5pt;"><font face="宋体">就是数据库应用，你可以这样设想，在我们知道数据库之前，有客户关系吗？在有计算机之前我们能够管理客户关系吗？可见，数据库应用只是帮助我们更有效管理客户关系的工具，但数据库应用本身并不就是</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span><font face="宋体"><span style="font-size:10.5pt;">。</span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us"></span></font></p><p></p><p style="line-height:130%;"><span style="font-size:10.5pt;"><font face="宋体">　　更为重要的是，客户关系管理可以受一定经营和营销战略的指导，人们可以在经营哲学和营销模型技巧的基础上开发出一种关系模型，然后利用数据库技术对这一模型加以补充和完善。然而，现在几乎所有的</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span><span style="font-size:10.5pt;"><font face="宋体">（包括个性化营销和一对一营销）应用都是由数据库开发者开发的，他们认为只要在一些相关的基础上制订一些“经营规则”，就可以帮助你管理客户关系。这就是为什么现在的</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span><font face="宋体"><span style="font-size:10.5pt;">应用在管理客户关系及营销方面只能达到有限目的的原因。</span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us"></span></font></p><p></p><p style="line-height:130%;"><span style="font-size:10.5pt;"><font face="宋体">　　</font></span><strong><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span></strong><strong><span style="font-size:10.5pt;"><font face="宋体">是电子商务</font></span></strong><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us"> </span></p><p></p><p style="line-height:130%;"><span style="font-size:10.5pt;"><font face="宋体">　　当我们谈到电子商务的时候，不仅仅是指网页的设计或网上商城的模式，所有可以促进从“批量生产”转变为“批量定制”的手段都可以容纳到“电子商务”的范围中。数字化信息存储和交换、无线通信、信息家电、</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">Internet</span><span style="font-size:10.5pt;"><font face="宋体">……这些以比特为载体加速了信息流通的商业行为都是电子商务。除非社会的各个方面都达到了信息的安全迅速无缝流动，并且在物流和实物传输方面配合得上，否则“新经济”就谈不上已经成型。因此，可以说，电子商务是一个非常大的概念，</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span><span style="font-size:10.5pt;"><font face="宋体">在其中只是一个子集。</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us"> </span></p><p></p><p style="line-height:130%;"><span style="font-size:10.5pt;"><font face="宋体">　　</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span><span style="font-size:10.5pt;"><font face="宋体">不能“包治百病”。同时我也认为，任何宣称某种软件可以让传统企业甩掉包袱，马上进入“信息时代”的说法都是极不负责任的。</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span><span style="font-size:10.5pt;"><font face="宋体">可能是企业进行转变的最好突破口，它的效力初步证明了加快流动的信息可以有效地降低成本，为企业新增价值。但是</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span><span style="font-size:10.5pt;"><font face="宋体">不是包罗万象的“电子商务”，它有一个适用范围。这个范围就是涉及市场营销、销售、维修、电话服务、交互式网络联系和售后服务这几个方面的客户信息集成。也就是说只要涉及到企业和客户之间的信息交换，就应该运用到</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span><span style="font-size:10.5pt;"><font face="宋体">。但是超出这个范围的，比如设计、研发、物流管理和财务管理等等，不能完全由</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us">CRM</span><span style="font-size:10.5pt;"><font face="宋体">来解决。</font></span><span lang="en-us" style="font-size:10.5pt;font-family:Arial;" xml:lang="en-us"> </span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-family:Arial;" xml:lang="en-us"><script type="text/javascript"><!--//--><![CDATA[//><!--function recommend(){OpenWindow = window.open('http://www.chinabyte.com/digest/email.shtm?url=http%3A%2F%2Fwww.chinabyte.com%2F20010627%2F187161.shtml','Ewin','toolbar=no,location=no,scrollbars=no,menubar=no,width=470,height=470')}//--><!]]></script><script type="text/javascript"><!--//--><![CDATA[//><!--function sendemail(){OpenWindow = window.open('http://other.chinabyte.com/chinabyte/qin/sendemail.shtm?url=http%3A%2F%2Fwww.chinabyte.com%2F20010627%2F187161.shtml','emailwin','toolbar=no,location=no,scrollbars=no,menubar=no,width=462,height=450')}//--><!]]></script></span></p>                </div>                    </div>
5336	 微机总线和接口标准	图形  ide  工作  ibm  网络  asynchronous  	1003502640	4263	eternalee	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <h2 align="center" style="margin-top:20px;"><font color="#ff00ff">微机总线和接口标准</font></h2><hr size="1"/><p>自1970年美国DEC公司在其PDP11/20小型计算机上采用Unibus总线以来，随着计算机技术的迅速发展，推出了各种标准的、非标准的总线。总线技术之所以能够得到迅速发展，是由于采用总线结构在系统设计、生产、使用和维护上有很多优越性。概括起来有以下几点:</p><p>·便于采用模块结构设计方法，简化了系统设计；</p><p>·标准总线可以得到多个厂商的广泛支持，便于生产与之兼容的硬件板卡和软件；</p><p>·模块结构方式便于系统的扩充和升级；</p><p>·便于故障诊断和维修，同时也降低了成本。</p><p>PC机从其诞生以来就采用了总线结构方式。先进的总线技术对于解决系统瓶颈提高整个微机系统的性能有着十分重要的影响，因此在PC机二十多年的发展过程中，总线结构也不断地发展变化。当前总线结构方式已经成为微机性能的重要指标之一。</p><p>在微机系统中除了采用总线技术外，还采用了标准接口技术，其目的也是为了便于模块结构设计,可以得到多个厂商的广泛支持，便于生产与之兼容的外部设备和软件。接口一般是指主板和某类外设之间的适配电路，其功能是解决主板和外设之间在电压等级、信号形式和速度上的匹配问题。因此不同类型的外设需要不同的接口，不同的接口是不通用的。例如，硬盘和软盘驱动器的接口是不兼容的，因此不能在硬盘接口上接入软盘驱动器。另一方面，由于目前的一些新型接口标准，如USB、IEEE1394等，允许同时连接多种不同的外设，因此也把它们称为外设总线。此外，连接显示系统的新型接口AGP，由于习惯上的原因（原来的显示卡插入ISA或者PCI总线插槽中），也被称为AGP总线，但是实际上它应该是一种接口标准。</p><p><font color="#ff0000"><b>总线的分类</b></font></p><p>首先我们来讨论总线的分类。总线就是各种信号线的集合，是计算机各部件之间传送数据、地址和控制信息的公共通路。在微机系统中，有各式各样的总线。这些总线可以从不同的层次和角度进行分类。</p><p>1.按相对于CPU或其它芯片的位置可分为： </p><p>·片内总线 </p><p>·片外总线  </p><p>在CPU内部，寄存器之间和算术逻辑部件ALU与控制部件之间传输数据所用的总线称为片内总线（即芯片内部的总线）；通常所说的总线(Bus)指片外总线，是CPU与内存RAM、ROM和输入/输出设备接口之间进行通讯的通路。有的资料上也把片内总线叫做内部总线或内总线(Internal Bus)，把片外总线叫做外部总线或外总线(External Bus)。 </p><p>CPU通过总线实现程序取指令、内存/外设的数据交换，在CPU与外设一定的情况下，总线速度是制约计算机整体性能的最大因素。 </p><p>2.按总线的功能可分为： </p><p>·地址总线 </p><p>·数据总线 </p><p>·控制总线 </p><p>通常所说的总线都包括上述三个组成部分，地址总线（ABus）用来传送地址信息，数据总线（DBus）用来传送数据信息，控制总线（CBus）用来传送各种控制信号。例如ISA总线共有98条线（即ISA插槽有98个引脚）；其中数据线有16条（构成数据总线），地址线24条（构成地址总线），其余各条为控制信号线（构成控制总线）、接地线和电源线。 </p><p>3.按总线的层次结构可分为： </p><p>·CPU总线：包括地址线(CAB)、数据线(CDB)和控制线(CCD)，它用来连接CPU和控制芯片。 </p><p>·存贮总线：包括地址线(MAB)、数据线(MDB)和控制线(MCD)，用来连接存储控制器和DRAM。 </p><p>·系统总线：也称为I/O通道总线，包括地址线(SAB)、数据线(SDB)和控制线(SCB)，用来与扩充插槽上的各扩充板卡相连接。系统总线有多种标准，以适用于各种系统。 </p><p>·外部总线：用来连接外设控制芯片，如主机板上的I/O控制器和键盘控制器。包括地址线(XAB)、数据线(XDB)和控制线(XCB)。 </p><p>CPU总线、存储总线、外部总线在系统板上，不同的系统采用不同的芯片集。这些总线不完全相同，也不存在互换性问题。系统总线是与I/O扩充插槽相连的，I/O插槽中可插入各式各样的扩充板卡，作为各种外设的适配器与外设连接。系统总线必须有统一的标准，以便按照这些标准设计各类适配卡。因此，我们实际上要讨论的总线就是系统总线，各种总线标准也主要是指系统总线的标准。 </p><p>4.按总线在微机系统中的位置可分为： </p><p>·机内总线：上面介绍的各类都是机内总线。 </p><p>机外总线（Peripheral Bus — 外设总线）：指与外部设备接口的总线，实际上是一种外设的接口标准。目前在PC机上流行的接口标准有：IDE、SCSI、USB和IEEE1394四种。前两种主要是与硬盘、光驱等IDE设备接口，后面两种新型外部总线可以用来连接多种外部设备。 </p><p>5.系统总线 </p><p>上面说过，我们要讨论的总线主要是系统总线。PC机上的系统总线又可分为ISA、EISA、MCA、VESA、PCI、AGP等多种标准。 </p><p>·ISA(Industry Standard Architecture)是IBM公司为286/AT电脑制定的总线工业标准。也称为AT标准。 </p><p>·MCA(Micro Channel Architecture)，是IBM公司专为其PS/2系统开发的微通道总线结构。由于执行的是使用许可证制度，因此未能得到有效推广。 </p><p>·EISA(Extended Industry Standard Architecture)，是EISA集团(1988年由Compaq、HP、AST、NEC、Olivetti、Zenith、Tandy等组成)为32位CPU设计的总线扩展工业标准。 </p><p>·VESA(Video Electronics Standards Association)，是VESA组织(1992年由IBM、Compaq等发起，有120多家公司参加)按Local Bus(局部总线)标准设计的一种开放性总线。 </p><p>·PCI(Peripheral Component Interconnect)，是SIG(Special Interest Group)集团推出的总线结构。1992年起，先后有Intel、HP、IBM、Apple、DEC、Compaq、NEC等著名的厂商加盟重新组建。 </p><p>AGP（Accelerated Graphics Port）即加速图形端口。它是一种为了提高视频带宽而设计的总线规范。因为它是点对点连接，即连接控制芯片和AGP显示卡，因此严格说来，AGP也是一种接口标准。 </p><p>6.局部总线 </p><p>在以Windows为代表的图形用户接口(GUI)进入PC机之后，要求有高速的图形描绘能力和I/O处理能力。这不仅要求图形适配卡要改善其性能，也对总线的速度提出了挑战。实际上当时外设的速度已有了很大的提高，如硬磁盘与控制器之间的数据传输率已达10MB/s以上，图形控制器和显示器之间的数据传输率也达到69MB/s。通常认为I/O总线的速度应为外设速度的3～5倍。因此原有的ISA、EISA已远远不能适应要求，而成为整个系统的主要瓶颈。 </p><p>局部总线是PC体系结构的重大发展。它打破了数据I/O的瓶颈，使高性能CPU的功能得以充分发挥。从结构上看，所谓局部总线是在ISA总线和CPU总线之间增加的一级总线或管理层。这样可将一些高速外设，如图形卡、硬盘控制器等从ISA总线上卸下而通过局部总线直接挂接到CPU总线上，使之与高速的CPU总线相匹配。 </p><p>局部总线可分为三种： </p><p>·专用局部总线 </p><p>·VL总线(VESA Local Bus)。 </p><p>·PCI总线(Peripheral Component Interconnect)。 </p><p>专用局部总线是一些大公司，如NEC、Dell、HP等，为自己系统开发的专用总线，用于图形处理、网络传输等。它们是非标准的，不能通用，也不被广大兼容机采用。VL总线和PCI总线都是通用总线，但VL总线只是适用于486的一种过渡标准，目前已经淘汰。586以上档次的微机普遍采用PCI总线。 </p><p>总线的主要参数 </p><p>1.总线的带宽 </p><p>总线的带宽指的是一定时间内总线上可传送的数据量，即我们常说的每秒钟传送多少MB的最大稳态数据传输率。与总线带宽密切相关的两个概念是总线的位宽和总线的工作时钟频率。 </p><p>2.总线的位宽 </p><p>总线的位宽指的是总线能同时传送的数据位数，即我们常说的32位、64位等总线宽度的概念。总线的位宽越宽则总线每秒数据传输率越大，也即总线带宽越宽。 </p><p>3.总线的工作时钟频率 </p><p>总线的工作时钟频率以MHz为单位，工作频率越高则总线工作速度越快，也即总线带宽越宽。 </p><p>总线带宽、总线位宽、总线工作时钟频率的关系举个例子就很容易明白了。高速公路上的车流量取决于公路车道的数目和车辆行驶速度，车道越多、车速越快则车流量越大；总线带宽就象是高速公路的车流量，总线位宽仿佛高速公路上的车道数，总线时钟工作频率相当于车速，总线位宽越宽、总线工作时钟频率越高则总线带宽越大。 </p><p>当然，单方面提高总线的位宽或工作时钟频率都只能部分提高总线的带宽，并容易达到各自的极限。只有两者配合才能使总线的带宽得到更大的提升。 </p><p>ISA总线 </p><p>一、概述 </p><p>最早的PC总线是IBM公司于1981年推出的基于8位机PC/XT的总线，称为PC总线。1984年IBM公司推出了16位PC机PC/AT，其总线称为AT总线。然而IBM公司从未公布过他们的AT总线规格。为了能够合理地开发外插接口卡，由Intel公司，IEEE和EISA集团联合开发了与IBM/AT原装机总线意义相近的ISA总线，即8/16位的“工业标准结构”(ISA-Industry Standard Architecture)总线。 </p><p>二、ISA总线的主要特点和性能指标 </p><p>8位ISA扩展I/O插槽由62个引脚组成，用于8位的插卡；8/16位的扩展插槽除了具有一个8位62线的连接器外，还有一个附加的36线连接器，这种扩展I/O插槽既可支持8位的插卡，也可支持16位插卡。ISA总线的主要性能指标如下：  </p><p>·I/O地址空间0100H-03FFH </p><p>·24位地址线可直接寻址的内存容量为16MB </p><p>·8/16位数据线 </p><p>·62+36引脚 </p><p>·最大位宽16位(bit) </p><p>·最高时钟频率8MHz </p><p>·最大稳态传输率16MB/s </p><p>·中断功能 </p><p>·DMA通道功能 </p><p>·开放式总线结构，允许多个CPU共享系统资源  </p><p>ISA插槽如图2所示。 </p><p>A1-A31及B1-B31的62线插槽即为8位插卡插槽，它与PC/XT 8位总线完全兼容。C1-C18和D1-D18为AT总线增加的36线插槽，它和62线插槽一起供16位插卡使用。  </p><p>EISA总线 </p><p>一、概述 </p><p>ISA总线对于286和386SX等微机系统来说是方便的，但对于386DX以上档次具有32位地址和数据宽度的微机系统来说，因其数据总线和地址总线宽度不够而影响了32位微处理器性能的发挥。为此IBM推出了32位微机采用的MCA微通道总线技术，但由于IBM对MCA技术采用了严格的许可证制度，使得其它厂商不能采用，同时MCA与PC/XT/AT总线也不兼容，所以除了在PS/2计算机中采用之外，在其它兼容机中没有得到推广。为了与MCA总线技术抗衡，Compaq、HP、AST、Epson、NEC、Olivetti、Tandy、Wyse、Zeith Data System(ZDS)等九家公司联合起来在ISA的基础上于1988年推出了为32位微机设计的“扩展工业标准结构”(Extended Industry Standard Architecture)，即EISA总线。 </p><p>EISA在结构上与ISA有良好的兼容性，保护了厂商和用户巨大的软硬件投资；同时又充分发挥和利用32位微处理机的功能，使之在图形技术、光存储器、分布处理、网络、数据处理等需要高速处理能力的地方发挥作用。EISA的推出打破了IBM MCA结构对微计算机发展的垄断。 </p><p>二、EISA的主要特点 </p><p>EISA插槽既与ISA插卡兼容，又与EISA插卡兼容。在插EISA卡时使用32位数据线，能达到33MB/s的传输率。EISA的主要性能指标与ISA相比，有以下优点： </p><p>·开放式结构。EISA和ISA兼容，现有的ISA扩充板可以用于EISA总线上 </p><p>·32位地址域直接寻址范围为4GB </p><p>·32位数据线 </p><p>·最大时钟频率8.3MHz </p><p>·最大传输率 33MB/s </p><p>EISA插槽由于要与ISA和EISA插卡兼容，因此在结构上和以往的插槽不同，采用了双层结构，EISA插卡的金手指也是双层结构。EISA插槽结构和ISA、EISA两种插卡的连接示意图如图3所示。 </p><p>如图所示，EISA插槽外观上与ISA插槽等长宽高，内部采用双层引脚结构，两层引脚之间由定位键限位。上层引脚与ISA插卡上的“金手指”对应，引脚为A1-A31、B1-B31、C1-C18和D1-D18。由于定位键的限位作用，ISA插卡不会与下层引脚相碰。下层引脚是为EISA卡设计的，与EISA卡上的“金手指”对应。引脚为E1-E31、F1-F31、G1-G9和H1-H19。EISA板插入时，插卡上的标准凹口会避开定位键，可插入槽底，使EISA插卡上的“金手指”分别与槽中A、B、C、D、E、F、G、H各组引脚连接，图3表示了ISA插槽插入ISA插卡和EISA插卡的情形。 </p><p>PCI总线 </p><p>一、概述 </p><p>90年代，随着图形处理技术和多媒体技术的广泛应用，在以Windows为代表的图形用户接口(GUI)进入PC机之后，要求有高速的图形描绘能力和I/O处理能力。这不仅要求图形适配卡要改善其性能，也对总线的速度提出了挑战。实际上当时外设的速度已有了很大的提高，如硬磁盘与控制器之间的数据传输率已达10MB/s以上，图形控制器和显示器之间的数据传输率也达到69MB/s。通常认为I/O总线的速度应为外设速度的3-5倍。因此原有的ISA、EISA已远远不能适应要求，而成为整个系统的主要瓶颈。因此对总线提出了更高的性能要求，从而促使了总线技术进一步发展。 </p><p>1991年下半年，Intel公司首先提出了PCI的概念，并联合IBM、Compaq、AST、HP、DEC等100多家公司成立了PCI集团，其英文全称为：Peripheral Component Interconnect Special Interest Group(外围部件互连专业组)，简称PCISIG。PCI是一种先进的局部总线，已成为局部总线的新标准。PCI总线插槽如图4所示。 </p><p>二、PCI局部总线的主要性能和特点 </p><p>PCI总线是一种不依附于某个具体处理器的局部总线。从结构上看，PCI是在CPU和原来的系统总线之间插入的一级总线，具体由一个桥接电路实现对这一层的管理，并实现上下之间的接口以协调数据的传送。管理器提供了信号缓冲，使之能支持10种外设，并能在高时钟频率下保持高性能。PCI总线也支持总线主控技术，允许智能设备在需要时取得总线控制权，以加速数据传送。 </p><p>1.PCI总线的主要性能 </p><p>·支持10台外设 </p><p>·总线时钟频率33.3MHz/66MHz </p><p>·最大数据传输速率133MB/s </p><p>·时钟同步方式 </p><p>·与CPU及时钟频率无关 </p><p>·总线宽度 32位（5V）/64位（3.3V） </p><p>·能自动识别外设 </p><p>·特别适合与Intel的CPU协同工作 </p><p>2.其它特点 </p><p>·具有与处理器和存储器子系统完全并行操作的能力 </p><p>·具有隐含的中央仲裁系统 </p><p>·采用多路复用方式（地址线和数据线）减少了引脚数 </p><p>·支持64位寻址 </p><p>·完全的多总线主控能力  </p><p>·提供地址和数据的奇偶校验 </p><p>·可以转换5V和3.3V的信号环境  </p><p>三、PCI总线信号定义  </p><p>要引脚 主控设备49条 目标设备47条 </p><p>可选引脚 51条（主要用于64位扩展、中断请求、高速缓存支持等） </p><p>总引脚数 120条（包含电源、地、保留引脚等） </p><p>四、PCI总线结构连接方式  </p><p>PCI总线的基本连接方式如图5所示。从图中可以看到CPU总线和PCI总线由桥接电路（习惯上称为北桥芯片）相连。芯片中除了含有桥接电路外，还有Cache控制器和DRAM控制器等其它控制电路。PCI总线上挂接高速设备，如图形控制器、IDE设备或SCSI设备、网络控制器等。PCI总线和ISA/EISA总线之间也通过桥接电路（习惯上称为南桥芯片）相连，ISA/EISA上挂接传统的慢速设备，继承原有的资源。 </p><p>此外，PCI总线还有其它一些连接方式，如双PCI总线 方式、PCI TO PCI方式、多处理器服务器方式等。鉴于篇幅关系不再详细介绍。 </p><p>五、PCI总线的新发展 </p><p>当前PCI总线的最高版本是2.1版，虽然在理论上达到66MHz的时钟频率，但对于新型的CPU（如Xeon、Katmai等）和高总线频率主板是完全不能适应的。Intel推出的新一代PCI总线规范称为PCI－X，主要适用于133MHz总线时钟频率的台式机主板。此外Intel还准备推出一种称为MINI PCI的总线标准。MINI PCI对原来的PCI总线在控制线路和功能上作了改进，减小了外形尺寸，使之适用于便携式机器。 </p><p>AGP总线 </p><p>一、为什么要采用AGP </p><p>AGP（Accelerated Graphics Port）即加速图形端口。它是一种为了提高视频带宽而设计的总线规范。它支持的AGP插槽可以插入符合该规范的AGP插卡。其视频信号的传输速率可以从PCI的132MB/s提高到266MB/s（×1模式）或者532MB/s（×2模式）。 </p><p>虽然现在PC机的图形处理能力越来越强，但要完成细致的大型3D图形描绘，PCI结构的性能仍然有限，为了让PC的3D应用能力能同图形工作站一较高低，Intel公司开发了AGP标准，推出AGP的主要目的就是要大幅提高高档PC机的图形尤其是3D图形的处理能力。  </p><p>严格说来，AGP不能称为总线，因为它是点对点连接，即连接控制芯片和AGP显示卡。采用AGP的目的是为了使3D图形数据越过PCI总线，直接送入显示子系统。这样就能突破由PCI总线形成的系统瓶颈。 </p><p>PCI总线在3D应用中的局限主要表现在3D图形描绘中。储存在PCI显示卡显示内存中的不仅有影像数据，还有纹理数据（Texture Data）、Z轴的距离数据及Alpha变换数据等,特别是纹理数据的信息量相当大。如果要描绘细致的3D图形，就要求显存容量很大；再加上必须采用较快速的显存，最终造成显示卡价格高昂。因此，3D显示卡的制造厂商所期望的是既能增加纹理数据的储存能力，又能降低产品的成本。一个有效的办法就是将纹理数据从显示内存移到主内存，以便减少显示内存的容量，从而降低显示卡的成本。从整个系统来看，增加显示内存也不如增加主内存划算，因为用作主内存的DRAM的价格已不太昂贵，而且把纹理数据储存在主内存比储存在显示内存更可有效利用内存。存储纹理数据所需的内存空间依应用程序而定，也就是说，当应用程序结束后，它所占用的主内存空间又可恢复，纹理数据并不永远占用主内存的空间。 </p><p>然而遗憾的是，当纹理数据从显示内存移到主内存时，由于纹理数据传输量很大，数据传输的瓶颈就从显示卡上的内存总线转移到了PCI总线上。例如，显示1024×768×16位真彩色的3D图形时，纹理数据的传输速度需要200MB／s以上，但目前的PCI总线最高数据传输速度仅为133MB/s，因而成为系统的主要瓶颈。  </p><p>3D绘图时所需数据传送速度如下表所示： </p><p>AGP在主内存与显示卡之间提供了一条直接的通道。使得3D图形数据越过PCI总线，直接送入显示子系统。这样就能突破由于PCI总线形成的系统瓶颈，从而实现了以相对低价格来达到高性能3D图形的描绘功能。采用AGP总线的系统结构如图6所示。 </p><p>二、AGP的性能特点 </p><p>AGP以66MHz PCI Revision 2.1规范为基础。在此基础上扩充了以下主要功能： </p><p>1.数据读写操作的流水线操作 </p><p>流水线(pipelining)操作是AGP提供的仅针对主存的增强协议。由于采用了流水线操作减少了内存等待时间，数据传输速度有了很大提高。  </p><p>2.具有133MHz的数据传输频率 </p><p>AGP使用了32位数据总线和双时钟技术的66MHz时钟。双时钟技术允许AGP在一个时钟周期内传输双倍的数据，即在工作脉冲波形的两边沿（即上升沿和下降沿）都传输数据，从而达到133MHz的传输速率，即532MB/s（133M×4B/s）的突发数据传输率。 </p><p>3.直接内存执行DIME </p><p>AGP允许3D纹理数据不存入拥挤的帧缓冲区(即图形控制器内存)，而将其存入系统内存，从而让出帧缓冲区和带宽供其它功能使用。这种允许显示卡直接操作主存的技术称为DIME（Direct Memory Excute）。应该说明的是，虽然AGP把纹理数据存入主存，也可以称为UMA(Unified Memory Architecture，统一内存体系结构)技术。但是与一些低端机采用的UMA有以下两点区别： </p><p>·通过AGP技术使用的主内存（称为AGP RAM）并没有完全取代显示卡的显示缓存，AGP主存只是对缓存的扩大和补充。 </p><p>·低端机的UMA是通过PCI接口运行的，其速度较慢。 </p><p>4.地址信号与数据信号分离 </p><p>采用多路信号分离技术(demultiplexing)，并通过使用边带寻址SBA(sideband address)总线来提高随机内存访问的速度。  </p><p>5.并行操作 </p><p>允许在CPU访问系统RAM的同时AGP显示卡访问AGP内存，显示带宽也不与其它设备共享，从而进一步提高了系统性能。 </p><p>三、AGP的工作模式 </p><p>AGP的工作模式如下表所示。  </p><p>从上表中可以看出，要真正达到良好的3D图形处理能力，应该采用2×以上的工作模式。在1×模式下，由于带宽不足，并不能适合DIME的速度，3D图形处理能力仍然是不理想的。因此在选购主板和AGP显示卡时，要注意它们是否支持AGP 2×的工作模式。目前，4×模式尚未正式推出。 </p><p>四、PCI和AGP的比较 </p><p>下表列出了PCI和AGP的性能比较。 </p><p>在采用AGP的系统中，由于显示卡通过AGP、芯片组与主内存相连，提高了显示芯片与主内存间的数据传输速度，让原需存入显示内存的纹理数据，现可直接存入主内存，这样可提高主内存的内存总线使用效率，也提高了画面的更新速度及Z buffer（Z缓冲）等数据的传输速度，而且还减轻了PCI总线的负载，有利于其它PCI设备充分发挥性能。由于在PC98规格中，ISA总线已被取消，ISA设备终将被淘汰，所以，把占用了PCI总线大量带宽的显示卡移到AGP上是非常必要的。当然AGP不可能取代PCI，因为我们已经多次说过AGP只是一个图形显示接口标准，而不是系统总线。AGP插槽和AGP插卡的插脚都采用了与EISA相似的上下两层结构，因此减小了AGP插槽的尺寸。图7是AGP插卡的两层金手指插脚。 </p><p>IEEE 1394总线  </p><p>IEEE 1394是一种串行接口标准，这种接口标准允许把电脑、电脑外部设备、各种家电非常简单地连接在一起。从IEEE 1394可以连接多种不同外设的功能特点来看，也可以称为总线，即一种连接外部设备的机外总线。IEEE 1394的原型是运行在Apple Mac电脑上的Fire Wire(火线)，由IEEE采用并且重新进行了规范。它定义了数据的传输协定及连接系统，可用较低的成本达到较高的性能，以增强电脑与外设如硬盘、打印机、扫描仪，与消费性电子产品如数码相机、DVD播放机、视频电话等的连接能力。 </p><p>由于要求相应的外部设备也具有IEEE1394接口功能才能连接到1394总线上，所以直到1995年第3季度Sony推出的数码摄像机加上了IEEE 1394接口后，1394才真正引起广泛的注意。采用1394接口的数码摄像机，可以毫无延迟地编辑处理影像、声音数据，性能得到增强。数码相机、DVD播放机和一般消费性家电产品，如VCR、HDTV、音响等也都可以利用IEEE 1394接口来互相连接。电脑的外部设备，例如硬盘、光驱、打印机、扫描仪等，也可利用IEEE 1394来传输数据。机外总线将改变当前电脑本身拥有众多附加插卡、连接线的现状，它把各种外设和各种家用电器连接起来。电脑也成为一种普通的家电。 </p><p>当电脑家电化之后，未来的电脑将如同现在的电视机一样，消费者可能只需拿起遥控器便可快速完成上Internet、玩游戏、控制视听影音器材甚至控制家里的电灯、电话等电器，真正实现居室智能化。 </p><p>一、IEEE 1394的主要性能特点 </p><p>1.采用“级联”方式连接各个外部设备 </p><p>IEEE 1394在一个端口上最多可以连接63个设备，设备间采用树形或菊花链结构。设备(下转26页)间电缆的最大长度是4.5m，采用树形结构时可达16层，从主机到最末端外设总长可达72M。 </p><p>2.能够向被连接的设备提供电源 </p><p>IEEE 1394的连接电缆(Cable)中共有六条芯线。其中两条线为电源线，可向被连接的设备提供电源；其它四条线被包装成两对双绞线，用来传输信号。电源的电压范围是8-40V直流电压，最大电流1.5A。像数码相机之类的一些低功耗设备可以从总线电缆内部取得动力，而不必为每一台设备配置独立的供电系统。由于1394能够向设备提供电源，即使设备断电或者出现故障也不影响整个网络的运转。  </p><p>3.采用基于内存的地址编码，具有高速传输能力 </p><p>总线采用64位的地址宽度(16位网络ID，6位节点ID，48位内存地址)，将资源看作寄存器和内存单元，可以按照CPU—内存的传输速率进行读写操作，因此具有高速的传输能力。1394总线的数据传输率最高可达400Mbps，因此可以适用于各种高速设备。  </p><p>4.采用点对点结构(peer to peer) </p><p>任何两个支持IEEE 1394的设备可以直接连接，不需要通过电脑控制，例如在电脑关闭的情况下，仍可以将DVD播放机与数字电视机连接而直接播放光盘节目。 </p><p>5.安装方便且容易使用 </p><p>允许热即插即用，不必关机即可随时动态配置外部设备，增加或拆除外设后IEEE 1394会自动调整拓朴结构，重设整个外设网络状态。 </p><p>二、IEEE 1394的工作模式 </p><p>1.IEEE 1394标准定义了两种总线数据传输模式，即：Backplane模式和Cable模式。其中Backplane模式支持12.5、25、50Mbps的传输速率；Cable模式支持100、200、400Mbps的速率。目前正在开发1G的版本。在400Mbps时，只要利用50%的带宽就可以支持不经压缩的高质量数字化视频信息流。 </p><p>2.IEEE 1394可同时提供同步(Synchronous)和异步(Asynchronous)数据传输方式。同步传输应用于实时性的任务，而异步传输则是将数据传送到特定的地址(Explicit Address)。这一标准的协议称为等时同步(isosynchronous)。使用这一协议的设备可以从1394连接中获得必要的带宽。其余的带宽，可以用于异步数据传输，异步数据传输过程并不保留同步传输所需的带宽。这种处理方式使得两种传输方式各得其所，可以在同一传输介质上可靠地传输音频、视频和计算机数据。它对计算机内部总线没有影响。目前的PCI局部总线可以充分利用1394。  </p><p>USB总线 </p><p>USB(Universal Serial Bus)称为通用串行总线，是由Compaq、DEC、IBM、Intel、Microsoft、NEC和NT(北方电讯)七大公司共同推出的新一代接口标准。它和IEEE 1394一样，也是一种连接外围设备的机外总线。从性能上来看，USB在很多方面不如1394，但是由于USB有着IEEE 1394无法比拟的价格优势，在一段时间内USB将与IEEE 1394共存，分别管理低速和高速外设。 </p><p>一、USB的主要性能特点 </p><p>1.具有热即插即用功能 </p><p>USB提供机箱外的热即插即用连接，连接外设不必再打开机箱，也不必关闭主机电源。这个特点为用户提供了很大的方便。 </p><p>2.USB采用“级联”方式连接各个外部设备 </p><p>每个USB设备用一个USB插头连接到前一个外设的USB插座上，而其本身又提供一个USB插座供下一个USB外设连接用。通过这种类似菊花链式的连接，一个USB控制器可以连接多达127个外设，而两个外设间的距离(线缆长度)可达5米。USB统一的4针圆形插头将取代机箱后部众多的串/并口(鼠标、MODEM)、键盘等插头。USB能智能识别USB链上外围设备的插入或拆卸，扩充卡、DIP开关、跳线、IRQ、DMA通道、I/O地址都将成为过去。 </p><p>3.适用于低速外设连接 </p><p>根据USB规范，USB传送速度可达12Mb/s(每秒12兆位)，除了可以与键盘、鼠标、MODEM等常见外设连接外，还可以与ISDN、电话系统、数字音响、打印机/扫描仪等低速外设连接。尽管USB被设计为也可以连接数字相机一类的较高速外设，但由于USB总线技术推出太迟，IEEE 1394接口总线已经在数字相机、数字摄影及视频播放等高速、高带宽领域(100Mb/s或以上)取得应用。 </p><p>USB接口插座如图8所示。 </p><p>二、IEEE 1394和USB的相似性 </p><p>1.都可以提供即插即用及热插拔的功能； </p><p>2.采用“级联”方式，可以连接多台设备，避免了电脑背板仅能提供少量插座，只能与少数设备连接的限制。 </p><p>三、IEEE 1394和USB的主要差别 </p><p>1.目前IEEE 1394规范的传输速度为100～400Mb/s,因此它可连接高速设备如DVD播放机、数码相机、硬盘等；而USB受到12Mb/s传输速度限制只能连接低速的键盘、麦克风、软驱、电话等设备。 </p><p>2.IEEE 1394的拓扑结构中，不需要集线器（Hub）就可连接63台设备，并且可以由网桥（Bridge）再将这些独立的子网（Subtree）连接起来。IEEE 1394并不强制要用电脑控制这些设备，也就是说这些设备可以独立工作。而在USB的拓扑结构中，必须通过Hub来实现多重连接，每个Hub有7个连接头，整个USB网络中最多可连接127台机器，而且一定要有电脑的存在，作为总的控制。 </p><p>3.IEEE 1394的拓扑结构在其外部设备增减时，会自动重设网络，其中包括网络短暂的等待状态；而USB以Hub来判明其连接设备的增减，因此可以减少USB网络动态重设的状况。 </p><p>USB和IEEE 1394在功能和设计思想上有许多相似的地方，但是它们的传输速率不同，因而适用范围也不同。从目前情况看，PC97标准已经纳入了USB规范，新的芯片组都支持USB，并且已有许多采用USB的电脑外设产品出现，USB的使用已经得到了推广。而IEEE 1394尚未有支持该总线标准的芯片组推出，支持1394的外设产品也为数甚少，因此IEEE 1394在短期内尚难以形成气候。 </p><p>IDE接口 </p><p>作为接口,包括了硬件和软件两部分：接口设备是硬件,接口信号规约标准是软件。接口信号规约标准对每一根信号线进行定义,定义内容包括信号的属性（控制信号、状态信号、还是数据信号）、方向和有效电平（高电平有效还是低电平有效）。只有符合接口标准的外设，才能连接使用。基本的硬盘接口标准有四种,即ST506,IDE,ESDI,SCSI。对于用户来讲,并不要求详细了解接口软硬件的细节,只要保证接口标准相符即可连接使用。ST506是Seagate公司开发的最早的一种接口标准。  </p><p>ESDI的原文是Enhanced Small Device Interface,即增强型小设备接口,是由美国的Maxtor、Shugart、CDC和XEBEC等公司联合开发的一种高性能硬盘接口。ST506和ESDI标准都已经淘汰,目前在微机中使用最广泛的是IDE和SCSI标准。 </p><p>一、 IDE接口标准 </p><p>IDE的原文是Integrated Device Electronics,即集成设备电子部件。它是由Compaq开发并由Western Digital公司生产的控制器接口。IDE是在ST506的基础上改进而成的,它的最大特点是把控制器集成到驱动器内。因此在硬盘适配卡中,不再有控制器这一部分了。这样做的最大好处是可以消除驱动器和控制器之间的数据丢失问题,使数据传输十分可靠。这就可以提高每磁道的扇区数到30以上,从而增大容量。由于控制器电路并入驱动器内,因此从驱动器中引出的信号线已不是控制器和驱动器之间的接口信号线,而是通过简单处理后可与主系统连接的接口信号线,这种接口方式是与ST506接口不同的。IDE采用了40线的单组电缆连接。在IDE的接口中,除了对AT总线上的信号作必要的控制之外,基本上是原封不动地送往硬盘驱动器。由此可见,IDE实际上是系统级的接口,而ST506、ESDI属于设备级接口。因此,在有的资料上也称IDE为ATA接口(AT-Attachment:AT嵌入式接口)。 </p><p>由于把控制器集成到驱动器之中,适配卡已变得十分简单,现在的微机系统中已不再使用适配卡，而把适配电路集成到系统主板上,并留有专门的IDE连接器插口。IDE由于具有多种优点,且成本低廉,在个人微机系统中得到了最广泛的应用。 </p><p>二、 增强型IDE(EIDE)接口标准 </p><p>增强型IDE (Enhanced IDE)是Western Digital为取代IDE而开发的接口标准。在采用EIDE接口的微机系统中,EIDE接口已直接集成在主板上,因此不必再购买单独的适配卡。与IDE相比,EIDE有以下几个方面的特点: </p><p>1.支持大容量硬盘,最大容量可达8.4GB。而原有的IDE标准,因受到硬盘磁头数(最大为16)的限制,其管理的最大硬盘容量不超过528MB。 </p><p>2.EIDE标准支持除硬盘以外的其它外设。旧的IDE标准只支持硬盘,因此它只是一个硬盘标准。而EIDE支持符合ATAPI接口(AT Attachment Packet Interface)标准的磁带驱动器和CD-ROM驱动器。因此我们在谈到IDE连接的对象时,只能说硬盘,而谈到EIDE连接的对象时就可笼统地说EIDE设备。 </p><p>3.可连接更多的外设,最多可连接四台EIDE设备。原有IDE只提供一个IDE插座,最多只能挂接两个硬盘。EIDE提供了两个接口插座,分别称为第一IDE(Primary)接口插座和第二IDE(Secondary)接口插座。每个插座又可连接两个设备,分别称为主(Master)和从(Slave)设备。因此一共可连接四台设备。第一IDE接口也称为主通道,它通常与高速的局部总线相连,用于挂接硬盘等高速的主IDE设备(Primary IDE Device)。第二IDE接口称为辅通道,一般与ISA总线相连,可挂接CD-ROM或磁带机等辅IDE设备(Secondary IDE Device)。在BIOS设置中,要求用户对Secondary IDE Device的数量、主从设备的工作模式进行设置。 </p><p>4.EIDE具有更高的数据传输速率。原有的IDE驱动器的最大突发数据传输率(Burst Data Transfer Rate)仅为3MB/s。突发数据传输率是指从硬盘缓冲区读取数据的速度,其单位常用每秒兆字节(MB/s)或每秒兆位(Mb/s)。EIDE支持硬盘标准组织SFFC (Small Form Factor Commitee)在1993年制定的宿主传输标准,如PIO (Programmed Input/Output)Mode 3以及PIO Mode 4,其突发数据传输率可达11.1MB/s和16.6MB/s；也支持Multiword Mode 1 DMA以及Multiword Mode 2 DMA,其突发数据传输率为13.3MB/s和16.6MB/s。为了说明不同的传输标准,通常把支持PIO Mode 3或Multiword Mode 1 DMA的系统和硬盘称为Fast ATA,而把支持PIO Mode 4或Multiword Mode 2 DMA的系统和硬盘称为Fast ATA-2。 </p><p>5.为了支持大容量硬盘，EIDE支持三种硬盘工作模式：NORMAL、LBA和LARGE模式。 </p><p>·NORMAL 普通模式 </p><p>这是原有IDE方式。在此方式下对硬盘访问时,BIOS和IDE控制器对参数不作任何转换。在普通模式下支持的最大柱面数为1024,最大磁头数为16,最大扇区数为63,每扇区字节数为512。因此支持最大硬盘容量为:512×63×16×1024=528MB。 </p><p>在此模式下即使硬盘的实际物理容量更大,但可访问的硬盘空间也只能是528MB。 </p><p>·LBA(Logical Block Addressing) 逻辑块寻址模式 </p><p>这种模式所管理的硬盘空间突破了528KB的瓶颈,可达8.4GB。在LBA模式下,设置的柱面、磁头、扇区等参数并不是实际硬盘的物理参数。在访问硬盘时,由IDE控制器把由柱面、磁头、扇区等参数确定的逻辑地址转换为实际硬盘的物理地址。在LBA模式下,可设置的最大磁头数为255,其余参数与普通模式相同。由此可计算出可访问的硬盘容量为:512×63×255×1024=8.4GB。 </p><p>·LARGE 大硬盘模式 </p><p>当硬盘的柱面超过1024而又不为LBA支持时可采用此种模式。LARGE模式采取的方法是把柱面数除以2,把磁头数乘以2,其结果总容量不变。例如,在NORMAL模式下柱面数为1220,磁头数为16,进入LARGE模式则柱面数为610,磁头数32。这样在DOS看来柱面数小于1024,即可正常工作。相反的转换进程由BIOS的INT 13H完成,以便取得正确的硬盘地址。LARGE模式支持的最大硬盘容量为:512×63×32×512=528MB </p><p>用户可根据配置的实际硬盘在上述三种工作模式中选择设置。 </p><p>三、Ultra DMA33和Ultra DMA66接口标准 </p><p>在ATA-2标准推出之后，SFFC又推出了ATA-3标准。ATA-3标准的主要特点是提高ATA-2的安全性和可靠性。ATA-3本身并没有定义更高的传输模式。此外，ATA标准本身只支持硬盘，前面我们说过EIDE支持符合ATAPI接口标准的磁带驱动器和CD-ROM驱动器，但是这些ATAPI设备和硬盘驱动器有很多区别，因此需要通过专门的驱动程序来处理。为此SFFC将推出ATA-4标准，该标准将集成ATA-3和ATAPI并且支持更高的传输模式。在ATA-4标准没有正式推出之前，作为一个过渡性的标准,Quantum和Intel推出了Ultra ATA(Ultra DMA)标准。 </p><p>Ultra ATA的第一个标准是Ultra DMA33(简称UDMA33)，也有人把它称为ATA-3。符合该标准的主板和硬盘在97年已经投放市场。UDMA33的主要特点如下: </p><p>1.通过改善的驱动程序，充分利用硬盘控制器的性能，使硬盘在数据传输过程中避免CPU的过多干预，使系统的并行工作能力进一步地提高。  </p><p>2.能够在时序脉冲的上下两相进行数据传输，传输速率比单相工作的硬盘提高一倍。因此其突发数据传输率理论上可从16.6MB/s提高到33MB/s。但由于系统开销等原因，实际的带宽没有达到33MB/s。几种主要UDMA33硬盘的实测带宽在26MB/s～30MB/s左右。 </p><p>3.由硬盘产生选通信号，并同时把缓冲区中的数据送到总线，避免了由主机送来选通信号造成的延时。 </p><p>Ultra DMA66（或者Ultra ATA-66）是由Quantum和Intel在98年2月份提出的最新标准。Ultra DMA66对Ultra DMA33改进主要在以下几个方面： </p><p>1.进一步提高了数据传输率，其突发数据传输率理论上可达66.6MB/s。 </p><p>2.采用了新型的CRC循环冗余校验。在突发传输数据时，主机和硬盘同时各自计算CRC并存入自己的寄存器中。突发传输结束后，主机把CRC寄存器中的值送到硬盘并与硬盘CRC寄存器中的值进行比较，从而进一步提高了数据传输的可靠性。 </p><p>3.改用80pin的排线(保留了与现有的电脑兼容的40pin排线，增加了40条地线)，以保证在高速数据传输中降低相邻信号线间的干扰。 </p><p>虽然Intel目前尚未发布支持Ultra DMA66硬盘模式的芯片组,但是VIA Apollo Pro芯片组已经提供了对Ultra DMA66硬盘的支持。部分主板如磐英P2-112A也提供了支持Ultra DMA66硬盘的接口。目前市场上已有Ultra ATA-66硬盘出售。 </p><p>使用UDMA33/66标准必须具备以下几个条件： </p><p>·主板（控制芯片组）支持UDMA33/66规范; </p><p>·硬盘支持UDMA33/66规范; </p><p>·正确安装硬盘的UDMA33/66驱动程序。 </p><p>SCSI接口 </p><p>SCSI的原文是Small Computer System Interface,即小型计算机系统接口。SCSI也是系统级接口,可与各种采用SCSI接口标准的外部设备相连,如硬盘驱动器、扫描仪、光盘、打印机和磁带驱动器等。采用SCSI标准的这些外设本身必须配有相应的外设控制器。SCSI早期只在小型机上使用,近年来也在PC机中采用。SCSI是由美国国家标准协会(ANSI)1986年6月公布的接口标准（称为SCSI－1）。1990年又推出了SCSI－2标准。SCSI接口标准的主要特性如下： </p><p>1.SCSI是系统级接口,可与各种采用SCSI接口标准的外部设备相连,如硬盘驱动器、扫描仪、光盘、打印机、磁带驱动器、通信设备等。总线上的主机适配器和SCSI外设控制器的总数最大为8个。 </p><p>2.SCSI是一个多任务接口，具有总线仲裁功能。因此，SCSI总线上的适配器和控制器可以并行工作，在同一个SCSI控制器控制下的多台外设也可以并行工作。 </p><p>3.SCSI可以按同步方式和异步方式传输数据。SCSI－1在同步方式下的数据传输速率为4MB/s,在异步方式下为1.5MB/s，最多可支持32个硬盘。SCSI－1接口的全部信号通过一根50线的扁平电缆传送,其中包含9条数据线及9条控制和状态信号线。其特点是操作时序简单,并具有总线仲裁功能。随后推出的扩充的SCSI－2标准增加一条68线的电缆,把数据信号的宽度扩充为16/32位,其同步数据传送速率达到了20MB/s。 </p><p>4.SCSI可分为单端传送方式和差分传送方式。单端SCSI的电缆不能超过6米，如果数据传送距离超过6米，应采用差分SCSI传送方式。 </p><p>5.SCSI总线上的设备没有主从之分，双方平等。启动设备和目标设备之间采用高级命令进行通信，不涉及外设特有的物理特性。因此，使用十分方便，适应性强，便于系统集成。 </p><p>从90年代开始，ANSI SCSI委员会开始制定SCSI-3规范。SCSI-3规范是一个多层结构，其协议层除了原有的并行协议外新增加了三个协议：光纤信道协议、串行协议和块传输协议。因此共有四种接口：SCSI-3并行接口、SCSI-3光纤信道接口、IEEE 1394和SCSI-3串行接口。这些新型接口将以PCI插卡的形式出现。IEEE 1394在前面已经作过介绍，它实际上就是以SCSI-3为基础制定的串行标准。SCSI-3的结构如图9所示。SCSI-3协议无疑是一个较为理想的标准，目前还在设计过程之中，要完全实现规范并进入实用可能还需要一个较长的时间。 </p><p>在90年代中期EIDE接口技术迅速发展的同时，ANSI SCSI委员会也推出了它的Ultra SCSI规范作为一种过渡性的方案。在理论上，Ultra SCSI的最大数据传输率提高到40MB/s。但是Ultra SCSI作为并行总线，没有解决SCSI对电缆布线的苛刻要求，而且其高速的数据传输率使得电缆长度和电缆质量的问题更加突出。在单端方式下，Ultra SCSI电缆的最大长度不能超过1.5米;在差分方式下，虽然能够支持较长的电缆，但是必须为每条数据线提供一条单独的地线，因此成本很高，同时引起了安装和兼容性的问题。为了解决上述问题，在98年推出了Ultra2 SCSI（LVD）规范，LVD表示低电压差分方式。Ultra2 SCSI（LVD）的主要特点是：16位数据线；最高数据传输率为80MB/s；电缆长度最大可达12米。目前已有部分支持Ultra2 SCSI（LVD）的硬盘面市，如昆腾的Atlas三代、IBM的Ultrastar等。98年9月，又发表了基于Ultra3 SCSI的Ultra160/m接口标准，进一步把数据传输率提高到160MB/s。昆腾也在98年11月推出了第一个支持Ultra160/m接口标准的硬盘Atlas10K和Atlas四代。 </p><p>SCSI对PC来说应是一种很好的选择,它不仅是一个接口,更是一条总线。相信随着技术的进一步发展，SCSI也会象EIDE一样广泛应用在微机系统和外设中。 </p><hr size="1"/><p align="left">* * * * * * <font color="#ff0000"><strong><big>请继续支持设备驱动程序开发网！</big></strong></font>* * * * * *<br/><br/>BeiJing : <a href="http://devdrv.qzone.com/">http://devdrv.qzone.com/</a>  <br/>LanZhou : <a href="http://devdrv.my.west163.com/">http://devdrv.my.west163.com/</a>  <br/>TaiYuan : <a href="http://devdrv.longcity.net/">http://devdrv.longcity.net/</a>  <br/>ShenZhen : <a href="http://devdrv.at.china.com/">http://devdrv.at.china.com/</a>  <br/>Email : <a href="mailto:devdrv@email.com.cn">devdrv@email.com.cn</a>  <br/>          <a href="mailto:devdriver@email.com.cn">devdriver@email.com.cn</a>  </p><p align="left"> </p>                </div>                    </div>
5402	 使用Intel向量化编译器优化性能(1)	编译器  优化  vectorization  dependencies  float  汇编  	1052794920	2282	xzygod	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p align="center" class="MsoNormal" style="margin:0cm 0cm 0pt;text-align:center;"><b><span style="font-size:15pt;font-family:'新宋体';"><font face="宋体">使用<span lang="en-us" xml:lang="en-us">Intel 向量化编译器优化性能(1)&lt;?xml:namespace prefix = o ns = "urn:schemas-microsoft-com:office:office" /&gt;</span></font></span></b></p><p><b></b></p><b></b><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"></span></p><p><font face="宋体" size="3"> </font></p><p align="center" class="MsoNormal" style="margin:0cm 0cm 0pt;text-align:center;"><span style="font-family:'新宋体';"><font size="3"><font face="宋体">本文节选翻译自<span lang="en-us" xml:lang="en-us">Intel网站</span></font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"></span></p><p><font face="宋体" size="3"> </font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span style="font-family:'新宋体';"><font size="3"><font face="宋体"><span lang="en-us" xml:lang="en-us">使用Intel c++编译器的时候,怎么也找不到相关的资料可以参考,在Intel的网站找到了一些教程,我C++的水平很一般,对这个编译器的使用也是刚入门,大家看了请多指正,这是第一部分,余下的我会在这几天继续整理完.</span></font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"></span></p><p><font face="宋体" size="3"> </font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><font face="宋体"><span style="font-family:'新宋体';"><font size="3">学习如何增强<span lang="en-us" xml:lang="en-us">c/c++以及Fortran代码在windows和Linux下的性能,使用Intel的向量化编译器来为特定的循环操作自动产生SIMD代码,这些SIMD指令包括MMX/SIMD </span></font></span><span lang="en-us" style="font-size:10pt;font-family:'新宋体';" xml:lang="en-us">Extensions</span><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"> /SIMD </font></span><span lang="en-us" style="font-size:10pt;font-family:'新宋体';" xml:lang="en-us">Extensions</span><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"> 2.</font></span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"></span></p><p><font face="宋体" size="3"> </font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:-21pt;"><font face="宋体"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><span><font size="3">1.</font><span style="font:7pt 'Times New Roman';">       </span></span></span><span style="font-family:'新宋体';"><font size="3">什么是向量器<span lang="en-us" xml:lang="en-us"></span></font></span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><font face="宋体"><span style="font-family:'新宋体';"><font size="3">向量器是<span lang="en-us" xml:lang="en-us">intel c++/Fortran编译器的一个特性,使用intel向量编译特性通过自动生成SIMD代码加速你的代码中特定的循环, 这些SIMD指令包括MMX/SIMD </span></font></span><span lang="en-us" style="font-size:10pt;font-family:'新宋体';" xml:lang="en-us">Extensions</span><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"> /SIMD </font></span><span lang="en-us" style="font-size:10pt;font-family:'新宋体';" xml:lang="en-us">Extensions</span><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"> 2.</font></span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"></span></p><p><font face="宋体" size="3"> </font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:-21pt;"><font face="宋体"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><span><font size="3">2.</font><span style="font:7pt 'Times New Roman';">       </span></span></span><span style="font-family:'新宋体';"><font size="3">什么是向量化程序<span lang="en-us" xml:lang="en-us"></span></font></span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:-21pt;"><font face="宋体"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><span><font size="3">a)</font><span style="font:7pt 'Times New Roman';">       </span></span></span><span style="font-family:'新宋体';"><font size="3">主要改善性能的地方<span lang="en-us" xml:lang="en-us"></span></font></span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;"><font face="宋体"><span style="font-family:'新宋体';"><font size="3">当函数包含大量循环时通过使用向量化编译器使用<span lang="en-us" xml:lang="en-us">SIMD指令能够获取较大的性能上的提高,一段以向量化循环为特征的程序足以快过那些同样运行方式的一般的程序或类库.对比一个向量化的循环和一个同样方式的标量循环,向量化会提供等同于使用底层汇编实现这循环的性能(通常使用在使用Streaming SIMD Extensions时会有25%-40%的性能提高).向量器也可能打开这些循环插入一些预取和 streaming store(不知道怎么翻译) 代码在你的循环中,这也</span></font></span><span style="font-size:10pt;font-family:'新宋体';">可能获得一些额外的性能上的提高<span lang="en-us" xml:lang="en-us">.</span></span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:-21pt;"><font face="宋体"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><span><font size="3">b)</font><span style="font:7pt 'Times New Roman';">       </span></span></span><span style="font-family:'新宋体';"><font size="3">使用<span lang="en-us" xml:lang="en-us">Intel的编译器可以使你从单调乏味的优化工作中解脱出来,编译器可以节省你很多时间,可以代替你做更多的工作.</span></font></span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:-21pt;"><font face="宋体"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><span><font size="3">c)</font><span style="font:7pt 'Times New Roman';">       </span></span></span><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3">Intel编译器从4.5版本开始支持向量化,5.0版本增强了向量化的功能包括performing simple statement reordering automatically(这是什么,也不知道)和对SIMD2的支持</font></span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"></span></p><p><font face="宋体" size="3"> </font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:-21pt;"><font face="宋体"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><span><font size="3">3.</font><span style="font:7pt 'Times New Roman';">       </span></span></span><span style="font-family:'新宋体';"><font size="3">为什么要使用向量器<span lang="en-us" xml:lang="en-us"></span></font></span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:-21pt;"><font face="宋体"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><span><font size="3">a)</font><span style="font:7pt 'Times New Roman';">       </span></span></span><font size="3"><span style="font-family:'新宋体';">提高性能<span lang="en-us" xml:lang="en-us">,</span></span><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"> 比如向量化一个有浮点操作的并被频繁调用的循环将会极大提高程序的性能</span><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"></span></font></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:-21pt;"><font face="宋体"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><span><font size="3">b)</font><span style="font:7pt 'Times New Roman';">       </span></span></span><font size="3"><span style="font-family:'新宋体';">编写单一版本的代码<span lang="en-us" xml:lang="en-us">,</span></span><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"> 减少使用汇编使编码工作简化,较少的汇编意味着会大大减少你为特定的系统编程的工作,你的程序将很容易升级并使用于最新的主流系统而不必重新编写那些汇编代码.</span><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"></span></font></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"></span></p><p><font face="宋体" size="3"> </font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:-21pt;"><font face="宋体"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><span><font size="3">4.</font><span style="font:7pt 'Times New Roman';">       </span></span></span><span style="font-family:'新宋体';"><font size="3">什么样的循环是可以向量化的<span lang="en-us" xml:lang="en-us"></span></font></span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:-21pt;"><font face="宋体"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><span><font size="3">a)</font><span style="font:7pt 'Times New Roman';">       </span></span></span><span style="color:#000000;font-family:'新宋体';"><font size="3">对于一个循环<span lang="en-us" xml:lang="en-us">,如果编译器认为循环内的每一个语句都没有依赖于另一个语句并且没有循环的依赖关系,那么这个循环就是向量的.换句话说,每一个语句必须能独立执行,读写数据的操作必须中立于循环的每次迭代</span></font></span></font><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><br/><br/></span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt;text-align:left;"><font face="宋体"><span lang="en-us" style="font-size:10pt;color:#000000;font-family:'新宋体';" xml:lang="en-us"><span>        </span></span><span style="color:#000000;font-family:'新宋体';"><font size="3">看这个循环<span lang="en-us" xml:lang="en-us"></span></font></span></font></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 36pt;text-align:left;"><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">for (int i=0; i&lt;1000; i++) {<br/>s1: a[i] = b[i] * T + d[i] ;<br/>s2: b[i] = a[i] + b[i])/2;<br/>s3: c = c + b[i];<br/>} </font></font></span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt;text-align:left;"><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体"><span>        </span>如果等价于下面的操作</font></font></span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 36pt;text-align:left;"><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">for (int i=0; i&lt;1000; i++) a[i] = b[i] * T + d[i] ;<br/>for (int i=0; i&lt;1000; i++) b[i] = (a[i] + b[i])/2;<br/>for (int i=0; i&lt;1000; i++) c = c + b[i]; </font></font></span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 36pt;text-align:left;"><span style="color:#000000;font-family:'新宋体';"><font size="3"><font face="宋体">那么就认为这个循环是可以被向量化的<span lang="en-us" xml:lang="en-us">.</span></font></font></span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 36pt;text-align:left;"><span style="color:#000000;font-family:'新宋体';"><font size="3"><font face="宋体">再看一个例子<span lang="en-us" xml:lang="en-us"></span></font></font></span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 36pt;text-align:left;"><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"></span></p><p><font face="宋体" size="3"> </font></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 36pt;text-align:left;"><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">for (int i=1; i&lt;1000; i++)</font></font></span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 36pt;text-align:left;"><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">{<br/>s1: a[i] = a[i-1] * b[i];<br/>} </font></font></span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:15pt;text-align:left;"><span style="color:#000000;font-family:'新宋体';"><font size="3"><font face="宋体">无论如何<span lang="en-us" xml:lang="en-us">,这个循环是不能被向量化的,因为a[i]在每次迭代中都读取了前一次迭代中的a[i-1].我们称这是一个交叉迭代的数据依赖或者”flow dependence”,这样的循环不能被编译器向量化.</span></font></font></span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 36pt;text-align:left;"><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"></span></p><p><font face="宋体" size="3"> </font></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:15pt;text-align:left;"><span style="color:#000000;font-family:'新宋体';"><font size="3"><font face="宋体">假定在第一个例子中使用的是浮点数据<span lang="en-us" xml:lang="en-us">-向量器能够通过使用SIMD Extensions同时操作4个浮点数,在这里,为了能够向量化,这个循环的次数必须大于4.</span></font></font></span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:15pt;text-align:left;"><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"></span></p><p><font face="宋体" size="3"> </font></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:-21pt;text-align:left;"><font face="宋体"><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"><span><font size="3">b)</font><span style="font:7pt 'Times New Roman';">       </span></span></span><span style="color:#000000;font-family:'新宋体';"><font size="3">向量器只能作用在最内层的循环<span lang="en-us" xml:lang="en-us"></span></font></span></font></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:21pt;text-align:left;"><span style="color:#000000;font-family:'新宋体';"><font size="3"><font face="宋体">在一个嵌套的循环中<span lang="en-us" xml:lang="en-us">,向量器只能尝试向量化最内层的循环,查看向量器的输出信息可以知道循环是否能被向量化以及原因,如果影响性能的关键循环没有向量化,你可能需要做一些更深层的打算,比如像下面描述的内容那样来帮助向量器做出正确的决定.</span></font></font></span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:21pt;text-align:left;"><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"></span></p><p><font face="宋体" size="3"> </font></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:-21pt;text-align:left;"><font face="宋体"><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"><span><font size="3">c)</font><span style="font:7pt 'Times New Roman';">       </span></span></span><span style="color:#000000;font-family:'新宋体';"><font size="3">向量化不是并行化<span lang="en-us" xml:lang="en-us"></span></font></span></font></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:21pt;text-align:left;"><span style="color:#000000;font-family:'新宋体';"><font size="3"><font face="宋体">看这个例子<span lang="en-us" xml:lang="en-us"></span></font></font></span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:21pt;text-align:left;"><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"></span></p><p><font face="宋体" size="3"> </font></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 84pt;text-align:left;"><span lang="en-us" style="font-size:10pt;color:#000000;font-family:'新宋体';" xml:lang="en-us"><font face="宋体">for (int i=0; i&lt;1000; i++)</font></span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 84pt;text-align:left;"><font face="宋体"><span lang="en-us" style="font-size:10pt;color:#000000;font-family:'新宋体';" xml:lang="en-us">{<br/>s1: a[i] = b[i] * T + d[i] ;<br/>s2: b[i] = (a[i] + b[i])/2;<br/>s3: c = c + b[i];<br/>}</span><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"></span></font></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt;text-align:left;"><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"></span></p><p><font face="宋体" size="3"> </font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体"><span>    </span>这个向量化程序依次s1,s2,s3执行所有的循环迭代.</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;"><font size="3"><font face="宋体"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><span>    </span></span><span style="color:#000000;font-family:'新宋体';">并行化意味在语句的不同的迭代循环中可能被另一个处理过程所干扰<span lang="en-us" xml:lang="en-us">,如果语句请求共享资源(比如读写同一个数据),那这个输出就不能保证正确,所以这个循环是不能正确向量化的.</span></span></font></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;"><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"></span></p><p><font face="宋体" size="3"> </font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:-21pt;"><font face="宋体"><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"><span><font size="3">5.</font><span style="font:7pt 'Times New Roman';">       </span></span></span><span style="color:#000000;font-family:'新宋体';"><font size="3">如何打开向量器<span lang="en-us" xml:lang="en-us"></span></font></span></font></p><p></p><table border="1" cellpadding="0" cellspacing="0" class="MsoNormalTable" style="margin:auto auto auto 20.75pt;" width="529"><tbody><tr><td style="border-right:#d4d0c8;padding-right:2.25pt;border-top:#d4d0c8;padding-left:2.25pt;padding-bottom:2.25pt;border-left:#d4d0c8;padding-top:2.25pt;border-bottom:#d4d0c8;background-color:transparent;" valign="top" width="361"><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt;text-align:left;"><font face="宋体"><b><span style="color:#000000;font-family:'新宋体';">参数</span></b><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"></span></font></p><p></p></td><td style="border-right:#d4d0c8;padding-right:2.25pt;border-top:#d4d0c8;padding-left:2.25pt;padding-bottom:2.25pt;border-left:#d4d0c8;padding-top:2.25pt;border-bottom:#d4d0c8;background-color:transparent;" valign="top" width="90"><p align="center" class="MsoNormal" style="margin:0cm 0cm 0pt;text-align:center;"><font face="宋体"><b><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us">Windows*</span></b><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"></span></font></p><p></p></td><td style="border-right:#d4d0c8;padding-right:2.25pt;border-top:#d4d0c8;padding-left:2.25pt;padding-bottom:2.25pt;border-left:#d4d0c8;padding-top:2.25pt;border-bottom:#d4d0c8;background-color:transparent;" valign="top" width="77"><p align="center" class="MsoNormal" style="margin:0cm 0cm 0pt;text-align:center;"><font face="宋体"><b><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us">Linux*</span></b><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"></span></font></p><p></p></td></tr><tr><td style="border-right:#d4d0c8;padding-right:2.25pt;border-top:#d4d0c8;padding-left:2.25pt;padding-bottom:2.25pt;border-left:#d4d0c8;padding-top:2.25pt;border-bottom:#d4d0c8;background-color:transparent;" valign="top" width="361"><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt;text-align:left;"><font face="宋体"><span style="color:#0033ff;font-family:'新宋体';">在编译器指定<span lang="en-us" xml:lang="en-us">cpu类型时打开向量器</span></span><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"></span></font></p><p></p></td><td style="border-right:#d4d0c8;padding-right:2.25pt;border-top:#d4d0c8;padding-left:2.25pt;padding-bottom:2.25pt;border-left:#d4d0c8;padding-top:2.25pt;border-bottom:#d4d0c8;background-color:transparent;" valign="top" width="90"><p align="center" class="MsoNormal" style="margin:0cm 0cm 0pt;text-align:center;"><font face="宋体"><i><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us">/Qx[M,K,W]</span></i><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"></span></font></p><p></p></td><td style="border-right:#d4d0c8;padding-right:2.25pt;border-top:#d4d0c8;padding-left:2.25pt;padding-bottom:2.25pt;border-left:#d4d0c8;padding-top:2.25pt;border-bottom:#d4d0c8;background-color:transparent;" valign="top" width="77"><p align="center" class="MsoNormal" style="margin:0cm 0cm 0pt;text-align:center;"><font face="宋体"><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us">-x[M,K,W]</span><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"></span></font></p><p></p></td></tr><tr><td style="border-right:#d4d0c8;padding-right:2.25pt;border-top:#d4d0c8;padding-left:2.25pt;padding-bottom:2.25pt;border-left:#d4d0c8;padding-top:2.25pt;border-bottom:#d4d0c8;background-color:transparent;" valign="top" width="361"><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt;text-align:left;"><font face="宋体"><span style="color:#0033ff;font-family:'新宋体';">打开向量器并自动检测<span lang="en-us" xml:lang="en-us">cpu类型,编译器能生成向量化的代码为最新的IA-32处理器,但同时也生成非向量化的代码供旧型号的处理器使用,这样使执行文件可以运行在多种处理器上</span></span><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"></span></font></p><p></p></td><td style="border-right:#d4d0c8;padding-right:2.25pt;border-top:#d4d0c8;padding-left:2.25pt;padding-bottom:2.25pt;border-left:#d4d0c8;padding-top:2.25pt;border-bottom:#d4d0c8;background-color:transparent;" valign="top" width="90"><p align="center" class="MsoNormal" style="margin:0cm 0cm 0pt;text-align:center;"><font face="宋体"><i><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us">/Qax[M,K,W]</span></i><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"></span></font></p><p></p></td><td style="border-right:#d4d0c8;padding-right:2.25pt;border-top:#d4d0c8;padding-left:2.25pt;padding-bottom:2.25pt;border-left:#d4d0c8;padding-top:2.25pt;border-bottom:#d4d0c8;background-color:transparent;" valign="top" width="77"><p align="center" class="MsoNormal" style="margin:0cm 0cm 0pt;text-align:center;"><font face="宋体"><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us">-ax[M,K,W]</span><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"></span></font></p><p></p></td></tr></tbody></table><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-align:left;"><span lang="en-us" style="color:#000000;font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">-W 打开对P4的Streaming SIMD Extensions 2的支持, -K打开对Pentium® III process的支持,-M是对MMX技术提供支持</font></font></span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:-21pt;text-align:left;"><font face="宋体"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><span><font size="3">6.</font><span style="font:7pt 'Times New Roman';">       </span></span></span><font size="3"><span style="color:#000000;font-family:'新宋体';">关于<span lang="en-us" xml:lang="en-us">#pragma ivdep和</span><span lang="en-us" xml:lang="en-us">restrict的使用</span></span><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"></span></font></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:-21pt;"><font face="宋体"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><span><font size="3">a)</font><span style="font:7pt 'Times New Roman';">       </span></span></span><span style="font-family:'新宋体';"><font size="3">为了向量化一个包含或可能包含依赖关系的循环<span lang="en-us" xml:lang="en-us">,加上#pragma ivdep (ignore vector dependencies),如果需要的话.</span></font></span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">Void foo(int k)</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 52.5pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">{<br/>#pragma ivdep</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 52.5pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">for(int j=0; j&lt;1000; j++)</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 52.5pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">{</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 63pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">a[j] = b[j+k] * c[j];<br/>b[j] = (a[j] + b[j])/2;<br/>b[j] = b[j] * c[j];</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 52.5pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">}</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">}</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;"><span style="font-family:'新宋体';"><font size="3"><font face="宋体">当向量化这个循环时<span lang="en-us" xml:lang="en-us">.编译器会认为数组b依赖了交叉迭代,原因就是是使用了变量k,如果你知道k不会干涉数据访问,加上#pragma ivdep向量器忽略向量的依赖性并尝试进行向量化,根本说,你必须知道这个依赖性是什么,并确信他们不会成为问题</span></font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"></span></p><p><font face="宋体" size="3"> </font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:-21pt;"><font face="宋体"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><span><font size="3">b)</font><span style="font:7pt 'Times New Roman';">       </span></span></span><font size="3"><span style="color:#000000;font-family:'新宋体';">使用指针的循环</span><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"></span></font></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:21pt;"><span style="font-family:'新宋体';"><font size="3"><font face="宋体">使用指针的循环可能造成依赖性<span lang="en-us" xml:lang="en-us">,如果为了向量化这样的循环,可以使用restrict关键字,如果需要的话</span></font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">Void foo(float *restrict a, float *restrict b, float * restrict c)</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">{ </font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 52.5pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">for(int j=0; j&lt;1000; j++)</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 52.5pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">{</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 63pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">a[j] = b[j] * c[j];</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 63pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">b[j] = (a[j] + b[j])/2;</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 63pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">b[j] = b[j] * c[j];</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 52.5pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">} </font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">}</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;"><span style="font-family:'新宋体';"><font size="3"><font face="宋体">注意<span lang="en-us" xml:lang="en-us">,使用了restrict关键字旧需要使用/ Qrestrict开关.如果不使用restrict关键字,编译器会认为数组的引用可能有交叉迭代的依赖性</span></font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;"><span style="font-family:'新宋体';"><font size="3"><font face="宋体">这是因为指针在循环中用来访问数据<span lang="en-us" xml:lang="en-us">,编译器无法知道是否指向了相同的地址(一般就是别名),为了安全必须阻止这样程序向量化, restrict关键字告诉编译器指针指向的地址是受限的,只能通过这个指针访问,换句话说,这里没有别名</span></font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"></span></p><p><font face="宋体" size="3"> </font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:-21pt;"><font face="宋体"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><span><font size="3">7.</font><span style="font:7pt 'Times New Roman';">       </span></span></span><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3">Verbose 模式参数</font></span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><font size="3"><font face="宋体"><span style="font-family:'新宋体';">在<span lang="en-us" xml:lang="en-us">windows下使用/Qvec_report[0,1,2,3]参数来产生详细的向量化报告,在Linux下使用-vec_report[0,1,2,3]参数,</span></span><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"> </span><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us">[0,1,2,3]指定输出信息的详细等级,在最详细的等级3,编译器会指出向量器是产生代码的具体信息.</span></font></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"></span></p><p><font face="宋体" size="3"> </font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span style="font-family:'新宋体';"><font size="3"><font face="宋体">下面是一次开启了向量器的编译操作的部分输出信息<span lang="en-us" xml:lang="en-us">:</span></font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><font size="3"><font face="宋体"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us">C:/TEMP/Text1.cpp(16) : (col. 1) remark: </span>&lt;?xml:namespace prefix = st1 ns = "urn:schemas-microsoft-com:office:smarttags" /&gt;<span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us">LOOP</span><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"> WAS VECTORIZED. </span></font></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">Below is an example of vectorizer output using the level 3 switch. </font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">char *p;</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">p = "aeiou";</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">while (*p++) {</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">cout &lt;&lt; *p;</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">}</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">C:/TEMP/Text1.cpp(20) : (col. 1) remark: loop was not vectorized: nonstandard loop is not a vectorization candidate.</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">float x[100], y[100];</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">int z[100];</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">for(int j=0; j&lt;100; j++)</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">{</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">x[j] = y[j] + 3;</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">z[j] = z[j+1];</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">}</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">C:/TEMP/Text1.cpp(29) : (col. 5) remark: loop was not vectorized: mixed data types.</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">float x[100], y[100];</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">int z[100];</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">for(int j=0; j&lt;100; j++)</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">{</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">x[j] = y[j] + 3;</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">y[j+1] = z[j+1];</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">}</font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"><font size="3"><font face="宋体">C:/TEMP/Text1.cpp(26) : (col. 1) remark: loop was not vectorized: existence of vector dependence. </font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span style="font-family:'新宋体';"><font size="3"><font face="宋体">注意这里有<span lang="en-us" xml:lang="en-us">2处问题,2处循环都有向量依赖性,还有一个循环有数据类型不一致的问题,向量器会根据检测到的这些问题的优先等级给出信息.</span></font></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"></span></p><p><font face="宋体" size="3"> </font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span style="font-family:'新宋体';"><font size="3"><font face="宋体">待续<span lang="en-us" xml:lang="en-us">………………….</span></font></font></span></p><p></p>                </div>                    </div>
5404	 使用Intel向量化编译器优化性能(3)	编译器  优化  vector  算法  float  数据结构  	1053161460	2139	xzygod	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p align="center" class="MsoNormal" style="margin:0cm 0cm 0pt;text-align:center;"><b><span style="font-size:15pt;font-family:'新宋体';">使用<span lang="en-us" xml:lang="en-us">Intel 向量化编译器优化性能(3)&lt;?xml:namespace prefix = o ns = "urn:schemas-microsoft-com:office:office" /&gt;</span></span></b></p><p><b></b></p><b></b><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-family:'新宋体';" xml:lang="en-us"></span></p><p><font size="3"> </font></p><p align="center" class="MsoNormal" style="margin:0cm 0cm 0pt;text-align:center;"><span style="font-family:'新宋体';"><font size="3">本文节选翻译自<span lang="en-us" xml:lang="en-us">Intel编译器文档</span></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" xml:lang="en-us"></span></p><p><font face="新宋体" size="3"> </font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:-21pt;"><font face="新宋体"><b><span lang="en-us" style="font-size:14pt;" xml:lang="en-us"><span>1.<span style="font:7pt 'Times New Roman';">       </span></span></span></b><b><span style="font-size:14pt;font-family:'宋体';">向量化循环中的数据类型</span></b><b><span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></b></font></p><p><b></b></p><b></b><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><font face="新宋体"><span style="font-size:9pt;font-family:'宋体';">在整形的循环中</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,MMX</span><span style="font-size:9pt;font-family:'宋体';">和</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">SSE</span><span style="font-size:9pt;font-family:'宋体';">技术都为多数使用</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">8/16/32bits</span><span style="font-size:9pt;font-family:'宋体';">长度数据的算法和逻辑操作提供了相应的</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">SIMD</span><span style="font-size:9pt;font-family:'宋体';">指令</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">如果一个使用整数的算法把结果保存在一个有足够精度的变量中</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">那么这个算法就可能被向量化</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">举例说</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">一个运算的结果是</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">32</span><span style="font-size:9pt;font-family:'宋体';">位整数</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">但却被保存在一个</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">16</span><span style="font-size:9pt;font-family:'宋体';">位的整数中</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">那么这么操作就不能被向量化</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">不是所有整形操作都能够被向量化的</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">.</span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><font face="新宋体"><span style="font-size:9pt;font-family:'宋体';">在</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">32</span><span style="font-size:9pt;font-family:'宋体';">位或</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">64</span><span style="font-size:9pt;font-family:'宋体';">位浮点数的循环中</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,SSE</span><span style="font-size:9pt;font-family:'宋体';">指令集不光为加减乘除等运算提供了相应的</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">SIMD</span><span style="font-size:9pt;font-family:'宋体';">指令</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">而且也提供了诸如</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">MAX/MIN/SORT</span><span style="font-size:9pt;font-family:'宋体';">这样的操作的</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">SIMD</span><span style="font-size:9pt;font-family:'宋体';">指令</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">其它的一些数学运算</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">比如三角函数</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">SIN/COS/TAN</span><span style="font-size:9pt;font-family:'宋体';">的</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">SIMD</span><span style="font-size:9pt;font-family:'宋体';">版本也已经在和编译器一起提供的向量数学库中得到了支持</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">.</span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p><font face="新宋体"> </font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:-21pt;"><font face="新宋体"><b><span lang="en-us" style="font-size:14pt;" xml:lang="en-us"><span>2.<span style="font:7pt 'Times New Roman';">       </span></span></span></b><b><span style="font-size:14pt;font-family:'宋体';">展开循环</span></b><b><span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></b></font></p><p><b></b></p><b></b><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;"><font face="新宋体"><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"><span>         </span></span><span style="font-size:9pt;font-family:'宋体';">编译器会自动对循环进行分析</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">并生成展开后的代码</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">这就是说你不需要自己去展开循环重新编写循环操作</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">在很多情况下</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">这能够使你获得更多的向量化操作</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">.</span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:21pt;"><font face="新宋体"><span style="font-size:9pt;font-family:'宋体';">看下面的循环</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></font></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 84pt;text-indent:21pt;text-align:left;"><span lang="en-us" style="font-size:9pt;color:#0000FF;font-family:'新宋体';" xml:lang="en-us">int</span><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"> i = 0;</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 84pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>  </span><span>   </span><span style="color:#0000FF;">while</span>(i &lt; k)</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 84pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>  </span><span>   </span>{</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 84pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>    </span><span>     </span>a[i] = b[i] + c[i];</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 84pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>    </span><span>     </span>++i;</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 105pt;text-indent:4.5pt;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us">}</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>              </span>向量化后就生成这样2个循环操作</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt;text-align:left;"><font face="新宋体"><span lang="en-us" xml:lang="en-us"><span><font size="3">                                   </font></span></span><span lang="en-us" style="font-size:9pt;color:#0000FF;font-family:'新宋体';" xml:lang="en-us">while</span><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us">(i &lt; (k - k % 4))</span></font></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 94.5pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>  </span>{</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 94.5pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>    </span>a[i] = b[i] + c[i];</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 94.5pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>    </span>a[i + 1] = b[i + 1] + c[i + 1];</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 94.5pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>    </span>a[i + 2] = b[i + 2] + c[i + 2];</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 94.5pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>    </span>a[i + 3] = b[i + 3] + c[i + 3];</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 94.5pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>    </span>i+=4;<span>  </span></span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 94.5pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>  </span>}</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 94.5pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"></span></p><p> </p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 94.5pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>  </span><span style="color:#0000FF;">while</span>(i &lt; k)</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 94.5pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>  </span>{</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 94.5pt;text-indent:18pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us">a[i] = b[i] + c[i];<span>  </span></span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 94.5pt;text-indent:18pt;text-align:left;"><span lang="en-us" style="font-size:9pt;color:#FF0000;font-family:'新宋体';" xml:lang="en-us">++i;<span>  </span>&lt;-此处文档上遗漏,很显然缺少这行程序很可能会陷入死循环</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 94.5pt;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>  </span>}</span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 94.5pt;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"></span></p><p> </p><p class="MsoNormal" style="margin:0cm 0cm 0pt 94.5pt;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"></span></p><p> </p><p class="MsoNormal" style="margin:0cm 0cm 0pt 94.5pt;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"></span></p><p> </p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:-21pt;"><font face="新宋体"><b><span lang="en-us" style="font-size:14pt;" xml:lang="en-us"><span>3.<span style="font:7pt 'Times New Roman';">       </span></span></span></b><b><span style="font-size:14pt;font-family:'宋体';">循环中的语句</span></b><b><span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></b></font></p><p><b></b></p><b></b><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;"><font face="新宋体"><span style="font-size:9pt;font-family:'宋体';">整数和浮点数间的向量化操作是不同的</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">.</span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;"><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p><font face="新宋体"> </font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:-21pt;"><font face="新宋体"><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"><span>a)<span style="font:7pt 'Times New Roman';">          </span></span></span><span style="font-size:9pt;font-family:'宋体';">浮点数组操作</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:21pt;"><font face="新宋体"><span style="font-size:9pt;font-family:'宋体';">支持的算法包括加</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">/</span><span style="font-size:9pt;font-family:'宋体';">减</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">/</span><span style="font-size:9pt;font-family:'宋体';">乘</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">/</span><span style="font-size:9pt;font-family:'宋体';">除</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">/</span><span style="font-size:9pt;font-family:'宋体';">非</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">/</span><span style="font-size:9pt;font-family:'宋体';">平方根</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">/</span><span style="font-size:9pt;font-family:'宋体';">求最大值</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">/</span><span style="font-size:9pt;font-family:'宋体';">求最小值</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">在</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">P4</span><span style="font-size:9pt;font-family:'宋体';">处理器还可以使用双精度的运算</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">前提是编译时使用</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">-QxW</span><span style="font-size:9pt;font-family:'宋体';">或</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">-QaxW</span><span style="font-size:9pt;font-family:'宋体';">打开对</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">P4</span><span style="font-size:9pt;font-family:'宋体';">的优化</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">.</span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:21pt;"><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p><font face="新宋体"> </font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:-21pt;"><font face="新宋体"><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"><span>b)<span style="font:7pt 'Times New Roman';">         </span></span></span><span style="font-size:9pt;font-family:'宋体';">整数数组操作</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:21pt;"><font face="新宋体"><span style="font-size:9pt;font-family:'宋体';">在包含</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">8/16/32</span><span style="font-size:9pt;font-family:'宋体';">位整形数据的循环中</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">计算平方根</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">(sqrt)</span><span style="font-size:9pt;font-family:'宋体';">和浮点数绝对值</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">(fabs)</span><span style="font-size:9pt;font-family:'宋体';">这样的运算也是可以支持的</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">像加</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">/</span><span style="font-size:9pt;font-family:'宋体';">减</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">/</span><span style="font-size:9pt;font-family:'宋体';">乘</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">(16</span><span style="font-size:9pt;font-family:'宋体';">位</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">)/</span><span style="font-size:9pt;font-family:'宋体';">除</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">(16</span><span style="font-size:9pt;font-family:'宋体';">位</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">)/and/or/xor/max/min</span><span style="font-size:9pt;font-family:'宋体';">这些运算在一定条件下也是支持的</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">你可以在运算中使用多种数据类型只要结果不丢失数据</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">就是说结果不能超过</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">32bits</span><span style="font-size:9pt;font-family:'宋体';">发生溢出</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">.</span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:21pt;"><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p><font face="新宋体"> </font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:-21pt;"><font face="新宋体"><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"><span>c)<span style="font:7pt 'Times New Roman';">          </span></span></span><span style="font-size:9pt;font-family:'宋体';">其它操作</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:21pt;"><font face="新宋体"><span style="font-size:9pt;font-family:'宋体';">任何超出整数和浮点数精度范围的语句都是不能向量化的</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">那些特殊的如</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">__m64</span><span style="font-size:9pt;font-family:'宋体';">和</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">__m128</span><span style="font-size:9pt;font-family:'宋体';">这样类型的数据也不能被向量化</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">循环中不能有任何函数调用</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">(</span><span style="font-size:9pt;color:#FF0000;font-family:'宋体';">注</span><span lang="en-us" style="font-size:9pt;color:#FF0000;" xml:lang="en-us">:void fun(void)</span><span style="font-size:9pt;color:#FF0000;font-family:'宋体';">这样的是可以的</span><span lang="en-us" style="font-size:14pt;color:#FF0000;font-family:Wingdings;" xml:lang="en-us"><span>J</span></span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">),</span><span style="font-size:9pt;font-family:'宋体';">也不能够使用</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">SSE SDK</span><span style="font-size:9pt;font-family:'宋体';">的</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">Intrinsics</span><span style="font-size:9pt;font-family:'宋体';">库</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">(</span><span style="font-size:9pt;color:#0000FF;font-family:'宋体';">这里意思不确定</span><span lang="en-us" style="font-size:9pt;color:#0000FF;" xml:lang="en-us">,</span><span style="font-size:9pt;color:#0000FF;font-family:'宋体';">原文是</span><span lang="en-us" style="font-size:9pt;color:#0000FF;" xml:lang="en-us">Use of<span>  </span>the Streaming SIMD Extensions Intrinsics(_mm_add_ps) are not allowed </span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">).</span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:21pt;"><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p><font face="新宋体"> </font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:-21pt;"><font face="新宋体"><b><span lang="en-us" style="font-size:14pt;" xml:lang="en-us"><span>4.<span style="font:7pt 'Times New Roman';">       </span></span></span></b><b><span style="font-size:14pt;font-family:'宋体';">语言支持和控制指令</span></b><b><span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></b></font></p><p><b></b></p><b></b><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><font face="新宋体"><span style="font-size:9pt;font-family:'宋体';">一些控制指令可以更好的帮助你向量化你的代码</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">.</span></font></p><p></p><table border="1" cellpadding="0" cellspacing="0" class="MsoTableGrid" style="border-right:medium none;border-top:medium none;margin:auto auto auto 50.4pt;border-left:medium none;border-bottom:medium none;border-collapse:collapse;"><tbody><tr><td style="border-right:1pt solid;padding-right:5.4pt;border-top:1pt solid;padding-left:5.4pt;padding-bottom:0cm;border-left:1pt solid;padding-top:0cm;border-bottom:1pt solid;background-color:transparent;" valign="top" width="168"><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"><font face="新宋体">__declspec(align(n))</font></span></p><p></p></td><td style="border-right:1pt solid;padding-right:5.4pt;border-top:1pt solid;padding-left:5.4pt;padding-bottom:0cm;border-left:#d4d0c8;padding-top:0cm;border-bottom:1pt solid;background-color:transparent;" valign="top" width="324"><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><font face="新宋体"><span style="font-size:9pt;font-family:'宋体';">使你的编译器把变量的地址对齐</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">n</span><span style="font-size:9pt;font-family:'宋体';">字节</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">就是说变量的地址</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"> mod n =0</span></font></p><p></p></td></tr><tr><td style="border-right:1pt solid;padding-right:5.4pt;border-top:#d4d0c8;padding-left:5.4pt;padding-bottom:0cm;border-left:1pt solid;padding-top:0cm;border-bottom:1pt solid;background-color:transparent;" valign="top" width="168"><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"><font face="新宋体">__declspec(align(n,off))</font></span></p><p></p></td><td style="border-right:1pt solid;padding-right:5.4pt;border-top:#d4d0c8;padding-left:5.4pt;padding-bottom:0cm;border-left:#d4d0c8;padding-top:0cm;border-bottom:1pt solid;background-color:transparent;" valign="top" width="324"><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><font face="新宋体"><span style="font-size:9pt;font-family:'宋体';">使你的编译器把变量的地址对齐</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">n</span><span style="font-size:9pt;font-family:'宋体';">字节</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">+offset,</span><span style="font-size:9pt;font-family:'宋体';">就是说变量的地址</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"> mod n = off</span></font></p><p></p></td></tr><tr><td style="border-right:1pt solid;padding-right:5.4pt;border-top:#d4d0c8;padding-left:5.4pt;padding-bottom:0cm;border-left:1pt solid;padding-top:0cm;border-bottom:1pt solid;background-color:transparent;" valign="top" width="168"><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"><font face="新宋体">restrict</font></span></p><p></p></td><td style="border-right:1pt solid;padding-right:5.4pt;border-top:#d4d0c8;padding-left:5.4pt;padding-bottom:0cm;border-left:#d4d0c8;padding-top:0cm;border-bottom:1pt solid;background-color:transparent;" valign="top" width="324"><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><font face="新宋体"><span style="font-size:9pt;font-family:'宋体';">使编译器认为没有指针别名</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">可以更容易向量化你的代码</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></font></p><p></p></td></tr><tr><td style="border-right:1pt solid;padding-right:5.4pt;border-top:#d4d0c8;padding-left:5.4pt;padding-bottom:0cm;border-left:1pt solid;padding-top:0cm;border-bottom:1pt solid;background-color:transparent;" valign="top" width="168"><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"><font face="新宋体">__assume_aligned(a,n)</font></span></p><p></p></td><td style="border-right:1pt solid;padding-right:5.4pt;border-top:#d4d0c8;padding-left:5.4pt;padding-bottom:0cm;border-left:#d4d0c8;padding-top:0cm;border-bottom:1pt solid;background-color:transparent;" valign="top" width="324"><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><font face="新宋体"><span style="font-size:9pt;font-family:'宋体';">如果编译器没能字节对齐的信息</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">用这个让编译器假设数组</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">a</span><span style="font-size:9pt;font-family:'宋体';">使按</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">n</span><span style="font-size:9pt;font-family:'宋体';">对齐的</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></font></p><p></p></td></tr><tr><td style="border-right:1pt solid;padding-right:5.4pt;border-top:#d4d0c8;padding-left:5.4pt;padding-bottom:0cm;border-left:1pt solid;padding-top:0cm;border-bottom:1pt solid;background-color:transparent;" valign="top" width="168"><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"><font face="新宋体">#pragma ivdep</font></span></p><p></p></td><td style="border-right:1pt solid;padding-right:5.4pt;border-top:#d4d0c8;padding-left:5.4pt;padding-bottom:0cm;border-left:#d4d0c8;padding-top:0cm;border-bottom:1pt solid;background-color:transparent;" valign="top" width="324"><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><font face="新宋体"><span style="font-size:9pt;font-family:'宋体';">让编译器假设你的代码没有数据依赖</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></font></p><p></p></td></tr><tr><td style="border-right:1pt solid;padding-right:5.4pt;border-top:#d4d0c8;padding-left:5.4pt;padding-bottom:0cm;border-left:1pt solid;padding-top:0cm;border-bottom:1pt solid;background-color:transparent;" valign="top" width="168"><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"><font face="新宋体">#pragma vector</font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"><font face="新宋体">{aligned | unaligned | always}</font></span></p><p></p></td><td style="border-right:1pt solid;padding-right:5.4pt;border-top:#d4d0c8;padding-left:5.4pt;padding-bottom:0cm;border-left:#d4d0c8;padding-top:0cm;border-bottom:1pt solid;background-color:transparent;" valign="top" width="324"><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><font face="新宋体"><span style="font-size:9pt;font-family:'宋体';">指定如何向量化这个循环并忽略效率推测</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></font></p><p></p></td></tr><tr><td style="border-right:1pt solid;padding-right:5.4pt;border-top:#d4d0c8;padding-left:5.4pt;padding-bottom:0cm;border-left:1pt solid;padding-top:0cm;border-bottom:1pt solid;background-color:transparent;" valign="top" width="168"><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"><font face="新宋体">#pragma novector</font></span></p><p></p></td><td style="border-right:1pt solid;padding-right:5.4pt;border-top:#d4d0c8;padding-left:5.4pt;padding-bottom:0cm;border-left:#d4d0c8;padding-top:0cm;border-bottom:1pt solid;background-color:transparent;" valign="top" width="324"><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><font face="新宋体"><span style="font-size:9pt;font-family:'宋体';">不要向量化这个循环</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></font></p><p></p></td></tr></tbody></table><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"></span></p><p><font face="新宋体" size="3"> </font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"></span></p><p><font face="新宋体" size="3"> </font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:-21pt;"><font face="新宋体"><b><span lang="en-us" style="font-size:14pt;" xml:lang="en-us"><span>5.<span style="font:7pt 'Times New Roman';">       </span></span></span></b><b><span style="font-size:14pt;font-family:'宋体';">一些向量化循环的例子</span></b><b><span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></b></font></p><p><b></b></p><b></b><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:-21pt;"><font face="新宋体"><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"><span>a)<span style="font:7pt 'Times New Roman';">          </span></span></span><span style="font-size:9pt;font-family:'宋体';">有别名问题的循环</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;"><font face="新宋体"><span style="font-size:9pt;font-family:'宋体';">下面的例子是个向量复制的操作</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></font></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 73.5pt;text-align:left;"><span lang="en-us" style="font-size:9pt;color:#0000FF;font-family:'新宋体';" xml:lang="en-us">void</span><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"> vec_copy (<span style="color:#0000FF;">int</span>* p1,<span style="color:#0000FF;">int</span>* p2)</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 73.5pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us">{</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 73.5pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>  </span><span style="color:#0000FF;">for</span> (i = 0; i &lt; 100; ++i)</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 73.5pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>  </span>{</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 73.5pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>    </span>p1[i] = p2[i];</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 73.5pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>  </span>}</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 52.5pt;text-indent:21pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us">}</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 52.5pt;text-indent:21pt;text-align:left;"><span style="font-size:9pt;font-family:'新宋体';">这里因为编译器能清楚的分别两个指针<span lang="en-us" xml:lang="en-us">,所以可以被向量化.</span></span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 52.5pt;text-indent:21pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"></span></p><p> </p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 52.5pt;text-indent:21pt;text-align:left;"><span style="font-size:9pt;font-family:'新宋体';">又有个例子<span lang="en-us" xml:lang="en-us"></span></span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 73.5pt;text-align:left;"><span lang="en-us" style="font-size:9pt;color:#0000FF;font-family:'新宋体';" xml:lang="en-us">void</span><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"> vec_copy (<span style="color:#0000FF;">int</span>* </span><font face="新宋体"><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">restrict</span><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"> p1,<span style="color:#0000FF;">int</span>* </span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">restrict</span><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"> p2)</span></font></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 73.5pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us">{</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 73.5pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>  </span><span style="color:#0000FF;">for</span> (i = 0; i &lt; 100; ++i)</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 73.5pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>  </span>{</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 73.5pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>    </span>p1[i] = p2[i];</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 73.5pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>  </span>}</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 52.5pt;text-indent:21pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us">}</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 52.5pt;text-indent:21pt;text-align:left;"><font face="新宋体"><span style="font-size:9pt;font-family:'宋体';">和上一个例子同样可以被向量化</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">但是用了</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">restrict,</span><span style="font-size:9pt;font-family:'宋体';">所以编译器不用产生多个版本的代码</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">注意</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">用</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">restrict</span><span style="font-size:9pt;font-family:'宋体';">编译时要加</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">/</span><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us">Qrestrict参数</span></font></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 52.5pt;text-indent:21pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"></span></p><p> </p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:-21pt;text-align:left;"><font face="新宋体"><b><span lang="en-us" style="font-size:14pt;" xml:lang="en-us"><span>6.<span style="font:7pt 'Times New Roman';">       </span></span></span></b><b><span style="font-size:14pt;font-family:'新宋体';">数据对齐</span></b><b><span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></b></font></p><p><b></b></p><b></b><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;text-align:left;"><span style="font-size:9pt;font-family:'新宋体';">一个<span lang="en-us" xml:lang="en-us">16字节或更大的数据结构或数组应该是对齐的,所以这些结构和数据的基地址应该是16的倍数,下图说明了一个DCU(data cache unit)是如何分割一个没有对齐16字节的数据.</span></span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;text-align:left;"><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">&lt;?xml:namespace prefix = v ns = "urn:schemas-microsoft-com:vml" /&gt;</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;text-align:left;"><font face="新宋体"><span style="font-size:9pt;font-family:'宋体';"><span lang="en-us" style="font-size:9pt;font-family:'Times New Roman';" xml:lang="en-us"> </span></span></font></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;text-align:left;"><font face="新宋体"><span style="font-size:9pt;font-family:'宋体';">在访问这个数据的时候需要多花费</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">6-12</span><span style="font-size:9pt;font-family:'宋体';">时钟周期</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">如果你能把数据对齐就可以避免这些额外的性能开销</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></font></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;text-align:left;"><font face="新宋体"><span style="font-size:9pt;font-family:'宋体';">举例说明</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></font></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:21pt;text-align:left;"><span lang="en-us" style="font-size:9pt;color:#0000FF;font-family:'新宋体';" xml:lang="en-us">float </span><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us">*a,*b<span style="color:#0000FF;">;</span></span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:21pt;text-align:left;"><span lang="en-us" style="font-size:9pt;color:#0000FF;font-family:'新宋体';" xml:lang="en-us">for</span><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"> (i = 0; i &lt; 10; ++i)</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>  </span><span>            </span>{</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>    </span><span>               </span>a[i] = b[i];</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>  </span><span>   </span>}</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;text-align:left;"><font face="新宋体"><span style="font-size:9pt;font-family:'宋体';">如果</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">a[0]/b[0]</span><span style="font-size:9pt;font-family:'宋体';">都是</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">16</span><span style="font-size:9pt;font-family:'宋体';">字节对齐的</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">,</span><span style="font-size:9pt;font-family:'宋体';">那么这个循环就可以使用</span><span lang="en-us" style="font-size:9pt;color:#0000FF;font-family:'新宋体';" xml:lang="en-us">#pragma</span><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"> vector aligned这个指令,在向量化后就是这样执行的.</span></font></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>     </span>2次向量化迭代<span>             </span>2次循环</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;text-align:left;"><font face="新宋体"><span lang="en-us" style="font-size:9pt;font-family:Wingdings;" xml:lang="en-us"><span>ß</span></span><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us">------------------------</span><span lang="en-us" style="font-size:9pt;font-family:Wingdings;" xml:lang="en-us"><span>à</span></span><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"> </span><span lang="en-us" style="font-size:9pt;font-family:Wingdings;" xml:lang="en-us"><span>ß</span></span><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us">-------&gt;</span></font></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>     </span>i=0-3,i=4-7<span>                </span>i=8-9</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us">2次向量化迭代可以用块复制的方式来操作.</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"></span></p><p> </p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;text-align:left;"><span style="font-size:9pt;color:#FF0000;font-family:'新宋体';">注意<span lang="en-us" xml:lang="en-us">,如果向量化使用不正确的对齐指令,编译器会产生不可预见的行为,比如在未对齐的的数据上使用</span></span><span lang="en-us" style="font-size:9pt;color:#0000FF;font-family:'新宋体';" xml:lang="en-us">#pragma</span><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"> vector aligned<span style="color:#FF0000;">将会导致一个异常</span>.</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;text-align:left;"><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p><font face="新宋体"> </font></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;text-align:left;"><font face="新宋体"><span style="font-size:9pt;font-family:'宋体';">这是几个关于数据对齐的例子</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></font></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 63pt;text-align:left;"><span lang="en-us" style="font-size:9pt;color:#0000FF;font-family:'新宋体';" xml:lang="en-us">void</span><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"> f(<span style="color:#0000FF;">int</span> lb)</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 63pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us">{</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 63pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>     </span><span style="color:#0000FF;">float</span> z2[N],a2[N],y2[N],x2;</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 63pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>     </span><span style="color:#0000FF;">for</span> (i = lb; i &lt; N; ++i)</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>     </span><span>     </span>{</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>         </span><span>     </span>a2[i] = a2[i] * x2 + y2[i];</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>     </span><span>     </span>}</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:21pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us">}</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;text-align:left;"><span style="font-size:9pt;font-family:'新宋体';">因为无法在编译时去确定<span lang="en-us" xml:lang="en-us">lb,所以我们只能认为这里没有做到对齐,如果你确定lb时4的倍数,那么你就可以使用<span style="color:#0000FF;">#pragma</span> vector aligned.</span></span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 63pt;text-align:left;"><span lang="en-us" style="font-size:9pt;color:#0000FF;font-family:'新宋体';" xml:lang="en-us">void</span><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"> f(<span style="color:#0000FF;">int</span> lb)</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 63pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us">{</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 63pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>     </span><span style="color:#0000FF;">float</span> z2[N],a2[N],y2[N],x2;</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 63pt;text-align:left;"><span lang="en-us" style="font-size:9pt;color:#0000FF;font-family:'新宋体';" xml:lang="en-us"><span>     </span>assert</span><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us">(lb % 4 = 0);</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 63pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>     </span><span style="color:#0000FF;">#pragma</span> vector aligned</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 63pt;text-indent:21pt;text-align:left;"><span lang="en-us" style="font-size:9pt;color:#0000FF;font-family:'新宋体';" xml:lang="en-us">for</span><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"> (i = lb; i &lt; N; ++i)</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>     </span><span>     </span>{</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>         </span><span>     </span>a2[i] = a2[i] * x2 + y2[i];</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us"><span>     </span><span>     </span>}</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:21pt;text-align:left;"><span lang="en-us" style="font-size:9pt;font-family:'新宋体';" xml:lang="en-us">}</span></p><p></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;text-align:left;"><span lang="en-us" style="font-size:9pt;color:#FF0000;" xml:lang="en-us"></span></p><p><font face="新宋体"> </font></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;text-align:left;"><span lang="en-us" style="font-size:9pt;color:#FF0000;" xml:lang="en-us"></span></p><p><font face="新宋体"> </font></p><p align="left" class="MsoNormal" style="margin:0cm 0cm 0pt 42pt;text-indent:21pt;text-align:left;"><font size="3"><font face="新宋体"><span style="font-family:'宋体';">全文完</span><span lang="en-us" xml:lang="en-us">,</span><span style="font-family:'宋体';">谢谢大家的支持</span><span lang="en-us" xml:lang="en-us">.</span></font></font></p><p></p>                </div>                    </div>
5621	 软件测试问题汇总表	软件测试  文档  	994078680	887	luhongjun	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                                                <b><span style="font-family:'宋体';font-size:26pt;">软件开发评测规范</span></b><p align="left" class="MsoNormal" style="line-height:20pt;margin-left:45pt;text-align:left;text-indent:-45pt;"><span style="font-family:'宋体';font-size:14pt;">附录</span><span lang="en-us" style="font-size:14pt;" xml:lang="en-us">B</span><span style="font-family:'宋体';font-size:14pt;">《软件测试问题汇总表》（</span><span lang="en-us" style="font-size:14pt;" xml:lang="en-us">F02</span><span style="font-family:'宋体';font-size:14pt;">）</span><span lang="en-us" style="font-size:14pt;" xml:lang="en-us">&lt;?xml:namespace prefix = o ns = "urn:schemas-microsoft-com:office:office" /&gt;</span></p><p></p><p align="center" class="MsoNormal" style="margin-left:45.1pt;text-align:center;text-indent:-45.1pt;"><b><span style="font-family:'宋体';font-size:22pt;">《软件测试问题汇总表》</span></b><b><span lang="en-us" style="font-size:22pt;" xml:lang="en-us"></span></b></p><p><b></b></p><b></b><p class="MsoNormal"><span style="font-family:'宋体';font-size:14pt;">月份</span><span lang="en-us" style="font-size:14pt;" xml:lang="en-us">:<span>                                                 </span></span></p><p></p><table border="1" cellpadding="0" cellspacing="0" style="border-bottom:medium none;border-collapse:collapse;border-left:medium none;border-right:medium none;border-top:medium none;"><tbody><tr><td style="border-bottom:.5pt solid;border-left:.5pt solid;border-right:.5pt solid;border-top:.5pt solid;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="91"><p align="center" class="MsoNormal" style="text-align:center;"><span style="font-family:'宋体';font-size:14pt;">开发人员</span><span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:.5pt solid;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="266"><p align="center" class="MsoNormal" style="text-align:center;"><span style="font-family:'宋体';font-size:14pt;">系统名称</span><span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:.5pt solid;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="91"><p align="center" class="MsoNormal" style="text-align:center;"><span style="font-family:'宋体';font-size:14pt;">严重错误</span><span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:.5pt solid;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="112"><p align="center" class="MsoNormal" style="text-align:center;"><span style="font-family:'宋体';font-size:14pt;">中等错误</span><span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:.5pt solid;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="98"><p align="center" class="MsoNormal" style="text-align:center;"><span style="font-family:'宋体';font-size:14pt;">一般错误</span><span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:.5pt solid;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="98"><p align="center" class="MsoNormal" style="text-align:center;"><span style="font-family:'宋体';font-size:14pt;">允许错误</span><span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:.5pt solid;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="112"><p align="center" class="MsoNormal" style="text-align:center;"><span style="font-family:'宋体';font-size:14pt;">质量系统</span><span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:.5pt solid;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="77"><p align="center" class="MsoNormal" style="text-align:center;"><span style="font-family:'宋体';font-size:14pt;">备注</span><span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td></tr><tr><td style="border-bottom:.5pt solid;border-left:.5pt solid;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="91"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="266"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="91"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="112"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="98"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="98"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="112"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="77"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td></tr><tr><td style="border-bottom:.5pt solid;border-left:.5pt solid;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="91"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="266"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="91"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="112"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="98"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="98"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="112"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="77"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td></tr><tr><td style="border-bottom:.5pt solid;border-left:.5pt solid;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="91"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="266"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="91"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="112"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="98"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="98"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="112"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="77"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td></tr><tr><td style="border-bottom:.5pt solid;border-left:.5pt solid;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="91"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="266"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="91"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="112"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="98"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="98"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="112"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="77"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td></tr><tr><td style="border-bottom:.5pt solid;border-left:.5pt solid;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="91"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="266"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="91"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="112"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="98"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="98"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="112"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="77"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td></tr><tr><td style="border-bottom:.5pt solid;border-left:.5pt solid;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="91"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="266"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="91"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="112"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="98"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="98"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="112"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="77"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td></tr><tr><td style="border-bottom:.5pt solid;border-left:.5pt solid;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="91"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="266"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="91"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="112"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="98"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="98"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="112"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="77"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td></tr><tr><td style="border-bottom:.5pt solid;border-left:.5pt solid;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="91"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="266"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="91"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="112"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="98"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="98"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="112"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="77"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td></tr><tr><td style="border-bottom:.5pt solid;border-left:.5pt solid;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="91"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="266"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="91"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="112"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="98"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="98"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="112"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="77"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td></tr><tr><td style="border-bottom:.5pt solid;border-left:.5pt solid;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="91"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="266"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="91"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="112"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="98"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="98"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="112"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="77"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td></tr><tr><td style="border-bottom:.5pt solid;border-left:.5pt solid;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="91"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="266"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="91"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="112"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="98"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="98"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="112"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="77"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td></tr><tr><td style="border-bottom:.5pt solid;border-left:.5pt solid;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="91"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="266"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="91"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="112"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="98"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="98"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="112"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td><td style="border-bottom:.5pt solid;border-left:medium none;border-right:.5pt solid;border-top:medium none;padding-bottom:0cm;padding-left:5.4pt;padding-right:5.4pt;padding-top:0cm;" valign="top" width="77"><p align="center" class="MsoNormal" style="text-align:center;"> <span lang="en-us" style="font-size:14pt;" xml:lang="en-us"></span></p><p></p></td></tr></tbody></table><p align="left" class="MsoNormal" style="line-height:20pt;margin-left:45pt;text-align:left;text-indent:-45pt;"><font size="5"><font color="#ff0000"><span lang="en-us" style="font-size:14pt;" xml:lang="en-us"><strong> 说明： 该文档设计人：luhongjun(过江项羽)。<br/>      文档版权归BCB开发团队所有，欢迎大家转载引用，但请注明文档所有者和设计人。未经同意请勿任意修改，不可用于商业目的。 <br/><br/><br/></strong></span></font></font></p><p><strong></strong></p><strong></strong>                </div>                    </div>
5670	 .NET语言的选择 [特别推荐]	语言  .net  vb.net  vb  c++  c#  	988610220	1773	coolstar	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        导 读：每个组织迁移到.NET将选择采用哪种.NET语言。微软提供了四种语言：C#, VB.NET, 可管理的C++和 JScript。本文简要的讨论了我们关于这些语言和哪种语言将被使用的看法。 <hr/>翻译整理：51dotnet.com（高飞家族） <p>原文出处：<a href="http://www.dotnetdan.com/articles/misc/LanguageChoice.htm">http://www.dotnetdan.com/articles/misc/LanguageChoice.htm</a></p><p>每个组织迁移到.NET将选择采用哪种.NET语言。微软提供了四种语言：C#, VB.NET, 可管理的C++和 JScript。本文简要的讨论了我们关于这些语言和哪种语言将被使用的看法。</p><p>简而言之，我们相信C#将占据主要的市场份额；JScript是没有竞争力的；C++将被忽视，VB.NET显现出对市场的准备不足。</p><p><font color="#000099" size="4"><b>失败者</b></font></p><p><font color="#000099" size="3">JScript</font></p><p>我们希望JScript在很少用户的基础上结束它的使命。现在很少有关于这方面的资料而且在.NET论坛中也不大有关于JScript的内容。它已经不是主流了。不要在把钱投到这项技术上，放弃它才是最明智的。</p><p><font color="#000099"><font size="3">可管理的C++</font></font></p><p>C++，即使它新的可管理的形式也将渐渐的被忽视。当越来越多的开发者趋向于语法清晰的语言，例如JScript, Java, VB.NET和C#, 使用C++ 的圈子越来越小。另一个C++ 面临的问题是他不能作为一种教学语言。无疑，尽管如此，有经验的C++开发者将继续使用它的能力，模板，多重代码的继承性和决定性的最终确定。其余的人都能轻松的应付。</p><p><font color="#000099" size="4"><b>胜利者们</b></font></p><p>在这里确切的说应该是胜利者。因为我们相信C# 是唯一的真正的胜利者。VB.NET处在尚无人支持的境地。</p><p><font color="#000099"><font size="3">C#具有相当的优势</font></font></p><p>大多数专业的软件开发者，即使独立开发微软平台，如今也将采用一些Java语言中的形式。</p><p>Java相对于C++和VB6较有利。他去处了许多C++ 中的语法特性而没有丝毫降低它的功能（因此C++的开发者转向使用Java是非常容易的）。它在支持面向对象的工具方面要优于VB6。</p><p>Java以其清晰的面向对象的语法结构和巨大的类库在大多数主流的具有生产性的语言中占据了最高地位。正是由于这个原因，许多擅长面向对象技术的C++ 和 VB 开发者开始向Java转移。</p><p>C# 为那些原本不支持微软的人转向使用微软的开发工具提供了依据。实际上它和Java是一致的，只不过在它们的不同之处，C# 更显示出了它无可厚非的优越性。此外，它是一种ECMA标准的语言，因此它提供了跨越多平台的潜在能力。</p><p>严肃的讲，开发者想要微软的最有生产能力和主流的.NET语言，C# 是最明智的选择。</p><p><font color="#000099"><font size="3">VB.NET孤立无助</font></font></p><p>还剩下VB.NET。我们仍旧对微软为什么仅仅使VB.NET成为一个更复杂的C# 而提出疑问。也许这两门语言的历史背景是知道这个转变的关键，但是我们要讨论的是技术方面的问题而不是市场的问题。</p><p>无疑，VB.NET已经成长到一个新的阶段。它现在已经成为了面向对象俱乐部中快速成长的一员。但是现在谁关心它呢？也许是一群对其不满的人和非面向对象的程序员，但他们将立刻得到它。随着C#的产生，VB.NET看上去更象是个过时的产品，而不是改进。</p><p>DecHand代码生成器能在VB.NET或C#中生成代码。如果你选择VB.NET选项，你会得到一个文件，它和C#实现同样功能，但却要比C#生成的文件大33% 左右。读某人用VB.NET编写的的代码时，冗长的语句会带来很多麻烦。当我们把这和前面所提到的原因结合起来时，我们只能希望有经验的面向对象的开发者应该喜欢C# 胜过VB.NET。 </p><p>那么什么样的市场会丢掉VB.NET呢? 目前的市场却使软件公司仅使用VB来作为开发工具,并造就了一大批VB爱好者.不幸的是,说实在话VB.NET并不是为这些人所开发的。</p><p><font color="#000099"><font size="3">从VB6移植</font></font></p><p>只用VB编写程序的工作间可能正期望从VB6更新到VB.NET，而且能象现有的VB升级一样容易。不幸的是，他们可能会遭到严酷的打击。尽管已经有一种工具可以自动完成操作过程，但升级到VB.NET仍然会累人的多。</p><p>正如我们上面提到的，VB.NET是一种面向对象的语言，而VB6不是。问题在于，如果你不按照面向对象的方式思考，而许多机构也正是这样做的，你就无法体会到VB.NET转换经历的乐趣。因为这不仅仅是一个结构，而是一种范例的转变，而这种转变是很昂贵的。很多组织可能会觉得如果他们想改变思维方式，他们不如改变语言。如果VB.NET被很快淘汰掉，也没什么可惊讶的。</p><p>过去曾经辉煌而如今孤寂的爱好者</p><p>最终的市场分割造就了爱好者。对他们而言，VB6是一种可选择的语言。它提供了简单而功能强大的工具来构建简单的应用程序包括GUIs。</p><p>VB.NET不是这么简单的。正像我们前面说过的那样，它是一种功能强大的面向对象的语言。但对于一般的爱好者来说，他们不想也不需要了解‘-isms’和面向对象领域中的抽象事务。他们只想把一项任务尽快完成，而忽略我们某些专业人士所要求的精细之处。</p><p>为此，过不了不久这些VB爱好者可能不会再继续使用VB6，或者他们对其不再报有太大的希望了。</p><p><font color="#000099"><font size="3">VB.NET的未来</font></font></p><p>上述注解仅仅是公开发布的.NET BETA版信息的一小部分。当我们看到最终的.NET的产品距离现在还有相当一段长时间，微软会采用它们当中的一些去生产隐藏着VB.NET复杂性的Visual Studio.NET特性的产品。我们只能翘首以待。我们对此不能做什么，只能相信他们能作到，为了发展，让我们给微软以传统的爱护，这样他们就会更加努力的去做。</p><p><font color="#000099" size="4"><b>关于运行时间的执行</b></font></p><p>如果你看到这里与你所想的相差甚远，你可能会问“性能怎样？”，当你在决定用哪一种语言来更快的完成一项产品时，这是每一个人所自然而然所要问的。</p><p> 毫无疑问.NET完全排除了那些标准。</p><p>为了去理解为什么.NET 语言运行会一样快（或慢），我们需要去看一下编译程序，或正好是两个阶段的编译程序。</p><p>第一阶段发生在你用Visual Studio按Ctrl-Shift-B键时。在这一点上，执行一个编译，你的语言编译器正在创建中间语言（IL）。第二阶段发生在你运行了应用程序时。第二阶段有时被看作是JIT编译（我们会觉得奇怪，但是我们不能解释）。它为特别使用CPU而使用了IL和产生本土代码。</p><p>微软对第一阶段编译的IL而产生的代码并不乐观。相反，他们开始扩展他们所有的能力去优选第二阶段IL---本土代码编译。他们这样做是为了使语言的不可知的原因。所有的.NET语言在运行时间的执行上是一样的。</p><p><font color="#000099" size="4"><b>关于调试和编译者的支持</b></font></p><p>Visual Studio.NET提供了同样复杂的调试和编译者使用所有语言的工具。当在Managed C++译码时你不会看到更细节的东西，例如，与其他的语言相比。你可以达到你所希望达到的深度。同样，自动完成的方法也适用于其他语言。</p><p><font color="#000099" size="4"><b>总结</b></font></p><p>如果你想找到更安全的办法，那就使用C#。我们肯定现在VB.NET的功能如此强大，而且C#更是如此，选择它你不会后悔的，因为我们已经向你清晰地描述了它的生产性能。</p>                </div>                    </div>
5683	 --=== 让你的程序开始说话（在VB中使用文字朗读引擎（TTS）技术）===--	tts  vb  引擎  command  microsoft  文档  	988968540	2310	coolstar	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <span class="name00"><font color="#ff3300">在VB中使用文字朗读引擎（TTS）技术</font><br/></span><span class="Name01"><font color="#666666">（作者：许锦新　2001年04月10日 13:52）</font></span><br/><br/><span class="content">　　现今市面上流行的一些英语学习软件，在广告词上经常说自己使用了国际顶尖的全程语音TTS技术，能进行整段英文的流利朗读，并能自由调节朗读的速度与频率等。那么，这个神奇的TTS究竟是什么东西呢？ <br/><br/>　　其实，TTS是微软出品的一套文字朗读引擎（Text-To-Speech Engine)，这些英语软件就是调用它来进行英文朗读的。我们在英语学习软件的编程开发中也可使用TTS技术，下面笔者将利用Visual Basic 5.0来揭开TTS神秘的面纱。 <br/><br/>　　<strong>一、安装TTS引擎</strong> <br/>　　TTS引擎所需的Microsoft Text-to-Speech Engine与Microsoft Speech API软件都可到微软的站点去下载，也可以在“金山词霸2000”或“金山词霸.net”的安装光盘上找到（文件名为MSTTS.EXE与SPCHAPI.EXE)。安装了TTS引擎后，在Windows所在目录下会生成一个SPEECH目录，其中有一个Vtxtauto.tlb文件，在编程时我们需要调用它。 <br/><br/>　　<strong>二、在VB中引入Vtxtauto.tlb文件</strong> <br/>　　进入VB 5.0，执行选单命令“文件/新建工程/标准EXE”并确定，然后执行选单“工程”中的“引用”，单击“浏览”按钮到Windows目录下的SPEECH子目录，打开Vtxtauto.tlb文件，将“VoiceText 1.0 Type Library”添加到引用列表中，选中它并单击确定。将库Vtxtauto引入VB后，我们可以通过选单“视图”中的“对象浏览器”来了解它所封装的类，以及各类成员函数的属性的意义、使用格式等信息。一些主要的方法与属性意义,笔者在下面的源程序中将给出注释，在这里就不详细列出，请参见附图1。 <br/><br/><img alt="010410b1-1.jpg" src="http://www.ccidnet.com/html/tech/guide/2001/04/10/image/010410b1-1.jpg"/><br/>　　<strong>三、设置控件及属性</strong> <br/>　　在FORM1上添加三个Label控件、一个TextBox控件、一个HScrollBar控件和六个CommandButton控件。窗体及各控件的主要属性设置如下： <br/><br/>　　FORM1：Caption=“英文朗读” <br/><br/>　　LABEL1：Caption=“请输入英文文档” <br/><br/>　　LABEL2：Caption=“朗读速度” <br/><br/>　　LABEL3：Caption=“ ” <br/><br/>　　（LABEL3标签用来显示朗读速度值） <br/><br/>　　TEXT1：Text=“Please input english text”；ToolTiptext=“请输入或粘贴英文文档”； MultiLine=True；ScrollBars=3-Both <br/><br/>　　HSCROLL1:名称=SpeedChange；Min=90；Max=300（Min与Max属性值分别用来限定可调节的语速的最小与最大值） <br/><br/>　　COMMAND1：名称=read；Caption=“朗读” <br/><br/>　　COMMAND2：名称=pause；Caption=“暂停” <br/><br/>　　COMMAND3：名称=stop；Caption=“停止” <br/><br/>　　COMMAND4：名称=prev；Caption=“上一句” <br/><br/>　　COMMAND5：名称=next；Caption=“下一句” <br/><br/>　　COMMAND6：名称=quit；Caption=“退出” <br/><br/>　　<strong>四、编写代码</strong> <br/>　　下面我们就可以一步步地编写代码，具体代码如下： <br/><br/>　　'在窗体装载时调用Register方法注册，括号内的两个参数是字符串 <br/><br/>　　Private Sub Form_Load() <br/><br/>　　Call VTxtAuto.VTxtAuto.Register(Space(8), Space(8)) <br/><br/>　　'因为语速的默认值为170，故水平滚动条的初值也设为170 <br/><br/>　　SpeedChange.Value = 170 <br/><br/>　　End Sub <br/><br/>　　'设置朗读速度调节代码,当水平滚动条的值Value发生变化时将其赋给控制语速的Speed属性 <br/><br/>　　Private Sub SpeedChange_Change() <br/><br/>　　VTxtAuto.VTxtAuto.Speed=SpeedChange.Value <br/><br/>　　Label3.Caption = SpeedChange.Value <br/><br/>　　End Sub <br/><br/>　　'设置“朗读”按钮代码 <br/><br/>　　Private Sub read_Click() <br/><br/>　　'如果朗读出错，则转到出错处理标记模块ErrorHandler <br/><br/>　　On Error GoTo ErrorHandler <br/><br/>　　'调用方法Speak进行朗读，第一个参数是要朗读的文本，第二个参数是设置朗读风格 <br/><br/>　　Call VTxtAuto.VTxtAuto.speak(Trim(Text1.Text), vtxtsp_VERYHIGH + vtxtst_READING) <br/><br/>　　Exit Sub <br/><br/>　　ErrorHandler: <br/><br/>　　MsgBox "只能朗读英文文档，不能朗读汉字字符！", , "出错信息" <br/><br/>　　End Sub <br/><br/>　　'设置“暂停”按钮代码 <br/><br/>　　Private Sub pause_Click() <br/><br/>　　If VTxtAuto.VTxtAuto.IsSpeaking Then <br/><br/>　　'如果属性IsSpeaking为真，则表示正在朗读，调用AudioPause方法暂停朗读 <br/><br/>　　Call VTxtAuto.VTxtAuto.AudioPause <br/><br/>　　pause.Caption = "恢复" <br/><br/>　　Else <br/><br/>　　'如果已经处于暂停状态则调用AudioResume方法恢复朗读 <br/><br/>　　Call VTxtAuto.VTxtAuto.AudioResume <br/><br/>　　pause.Caption = "暂停" <br/><br/>　　End If <br/><br/>　　End Sub <br/><br/>　　'设置“停止”按钮代码，调用StopSpeaking方法停止当前朗读 <br/><br/>　　Private Sub stop_Click() <br/><br/>　　Call VTxtAuto.VTxtAuto.StopSpeaking <br/><br/>　　End Sub <br/><br/>　　'设置“上一句”按钮代码，调用AudioRewind方法往后跳过一句 <br/><br/>　　Private Sub prev_Click() <br/><br/>　　 Call VTxtAuto.VTxtAuto.AudioRewind <br/><br/>　　End Sub <br/><br/>　　'设置“下一句”按钮代码，调用AudioFastForward方法向前跳过一句 <br/><br/>　　Private Sub next_Click() <br/><br/>　　 Call VTxtAuto.VTxtAuto.AudioFastForward <br/><br/>　　End Sub <br/><br/>　　'设置“退出”按钮代码 <br/><br/>　　Private Sub quit_Click() <br/><br/>　　 Unload Me <br/><br/>　　End Sub <br/><br/>　　本程序在中文Windows 95/98、VB 5.0环境下运行通过。运行时在文本编辑框中输入或粘贴英文文档，然后单击“朗读”按钮就可播放读音，运行界面如图2。 <br/><br/><img alt="010410b1-2.jpg" src="http://www.ccidnet.com/html/tech/guide/2001/04/10/image/010410b1-2.jpg"/><br/>　　<strong>五、程序改进思路</strong> <br/>　　本文对在VB编程中使用TTS技术只是起个抛砖引玉的作用，熟悉VB编程的电脑爱好者来可以对本程序作一些改进，例如增加对声卡和TTS引擎是否安装的检测、增加从文本文件或数据库中读取文档的功能、增加让用户选择朗读的优先级和发声音量调节等功能。这些功能实现起来较为复杂，感兴趣的读者可进行深入研究。<br/></span>                </div>                    </div>
6111	 从乡村到城市	生活  创业  工作  产品  中兴  融资  	1062556200	3502	harrymeng	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p class="MsoNormal" style="margin:0cm 0cm 0pt;"><font size="3"><span style="font-family:'宋体';">《爱舞今生》系列文章一</span><strong><u><span lang="en-us" style="font-size:15pt;font-family:'宋体';" xml:lang="en-us"></span></u></strong></font></p><p><strong><u></u></strong></p><strong><u></u></strong><p align="center" class="MsoNormal" style="margin:0cm 0cm 0pt;text-align:center;"></p><p align="center" class="MsoNormal" style="margin:0cm 0cm 0pt;text-align:center;"><strong><u><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us"><font size="3"></font></span></u></strong></p><p><strong><u></u></strong></p><strong><u></u></strong><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us"></span><p><font size="3"> </font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:15.75pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us"><font size="3">1998年平7月，一个炎热的夏日，我走在珠海宽阔的九洲大道边，行李不多，只比原中国国家男足主教练南斯拉夫老头---米卢刚来中国掏金时多背了一个包：），心中充满了激情与<span>干劲,尽管大学生涯存在着若干的</span><span style="color:#000000;">缺憾与</span>郁闷,但这丝毫不影响我对即将到来的生活与工作充满了无限的憧憬与期待。</font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:15.75pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us"></span></p><p><font size="3"> </font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:15.8pt;"><strong><span style="font-family:'宋体';"><font size="3">关于珠海的环境<span lang="en-us" xml:lang="en-us"></span></font></span></strong></p><p><strong></strong></p><strong></strong><p style="background:#FFFFFF;"><span lang="en-us" style="font-size:10.5pt;" xml:lang="en-us"><span> </span><span> </span>与四年前刚走进大学所在的那个城市一样, 我流露出更多的是茫然和未知, 这么多年以来我一直融不进城市的繁华与喧嚣,尽管有很多次感觉上是走近了，却没能走进去……珠海,这座”浪漫之城”果然名不虚传,许多地方美得如同梦中仙境,这里四季如春,海风轻吹,绿树成荫,街道干净,治安良好,公园多酒吧多书店多水果多海鲜多……珠海的”浪漫”名声在外, 一条"情侣路"可以作为这个浪漫城市的标记, </span><span style="font-size:10.5pt;">情侣路一面靠山，一面对海，最适合<span lang="en-us" xml:lang="en-us">“海誓山盟”, 情侣路上有石椅和椅栏供行人休憩，路两旁是林荫道，种满了花，鲜花终年盛开，树木四季丰茂，山色海景跟随日月的脚步变幻, 而珠海渔女就近在咫尺,男士更可以借题发挥，讲个凄美的爱情故事，让佳人心醉！ 如果你的腰包鼓一点,在这里生活确实没有会与你为难了,你就尽情地享受生活享受浪漫吧! 我的腰包不鼓残忍一点的甚至可以说我没有腰包,因此再好的风景对我而言也会变得索然无味,在这个社会里很多的浪漫是需要MONEY的,如果现在你的灵感来了,写了一首酸酸的情诗,送给你刚认识的小资女友,她百分之八十以上会说你脑子有毛病而且还吃错了药,面对这种情况,作为有理想有追求有文化没家累没人管的年经人,在这座城市往往浪漫不了两年就跑到广州深圳上海发展去了,因为他们明白了很多感悟了很多,知道了这里是养老的地方却不是创业的地方.</span></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:15.75pt;"><font size="3"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us"><span>  </span><strong>关于</strong></span><strong><span style="font-family:'宋体';">珠海的<span lang="en-us" xml:lang="en-us">IT业</span></span></strong></font></p><p><strong></strong></p><strong></strong><p style="background:#FFFFFF;"><span lang="en-us" style="font-size:10.5pt;" xml:lang="en-us"><span>   </span><span>  </span>说到珠海的IT业,还应从巨人以及史玉柱说起.郁闷的时候我曾经做过很多无聊的假设,如果巨人不倒,现在珠海IT行业的现状会是什么样子的,与广州深圳的距离还会这么远吗,如果巨人大厦建好了,如果史玉柱……让我们先来看一下史玉柱的一段话:” 巨人倒了怪不了别人，更怪不了媒体。如果当时多坚持一年，又过来3亿5亿资金，还得倒。巨人倒闭，就是因为我本人和我当时的班子的问题。那个时候我们极不成熟。从创业到那个时候(1997年)一直很顺，一个成功接着一个成功，人已经昏了头了。现在回过头来看，很多地方幼稚得很。现在回过头来翻一翻当时的档案，哪儿像是办企业的人做的？更像是幼儿园一群人在那里拍板。” 我个人是很敬佩史玉柱的,无论是巨人的失败还是脑黄金的成功,</span><span lang="en-us" style="font-size:10.5pt;" xml:lang="en-us"> </span><span style="font-size:10.5pt;">很多人的锐气总会被年龄与堕性漫漫消解，但史玉柱不会。他是勇往直前的。他宁肯忍受磨砺，也不能默默无闻地打发人生。“如果有一天我不干了，那肯定是因为企业不需要我了，或者身体不行了，否则我不会停下来。”在他那里，全部的幸福就是实现自己的意志和愿望。因此对于史玉柱，我们不能设想“如果”。如果巨人依然屹立，他也许还是那个充满霸气，认为随意间就可征服世界的人。他也可能还是那个脾气大得把文件掀翻，把桌子掀翻才解气的总裁。他也还是那个做事有豪赌意味的总裁。<span lang="en-us" xml:lang="en-us"></span></span></p><p></p><p style="background:#FFFFFF;text-indent:24pt;"><span style="font-size:10.5pt;">之所以说了一下巨人及史玉柱<span lang="en-us" xml:lang="en-us">, 是因为我一直认为巨人的倒闭对珠海的高科技产业甚至房地产等行业的发展是一次很大的打击,再有钱的老板也会重新考虑对珠海的投资……尽管近年来</span></span><span style="font-size:10.5pt;">珠海市政府根据珠海适宜科研和软件产业发展的良好环境优势，大力地提倡和扶持软件产业的发展，一定的程度上有效地促进了软件产业的发展<span lang="en-us" xml:lang="en-us">,珠海也因此出现了一些发展较快的软件企业,但总体而言,珠海的软件企业仍然存在以下的不足:</span></span></p><p style="background:#FFFFFF;text-indent:24pt;"><span style="font-size:10.5pt;"><span lang="en-us" xml:lang="en-us">(1) 外企少,有名的外企更少;<span> </span></span></span></p><p style="background:#FFFFFF;text-indent:24pt;"><span style="font-size:10.5pt;"><span lang="en-us" xml:lang="en-us">(2) 民营企业较多,但规模很小,大多急功近利,管理混乱; </span></span></p><p style="background:#FFFFFF;text-indent:24pt;"><span style="font-size:10.5pt;"><span lang="en-us" xml:lang="en-us">(3)没有IT方面的龙头企业,说到深圳一般人都会想起华为,中兴等,但提起珠海,你想到谁了? 格力,那是造空调的,老兄; </span></span></p><p style="background:#FFFFFF;text-indent:24pt;"><span style="font-size:10.5pt;"><span lang="en-us" xml:lang="en-us">(4) 做MIS的公司太多做产品的公司太少,普遍公司的技术含量低,对公司而言,能赚到钱就开心了,管TMD什么项目什么技术什么语言,对程序员们来讲,这也许不是什么好事,人总要不断地成长,无论是技术还是别的方面的能力,因此可以说,找到一个好老板,对程序员的成长及发展是多么地重要……</span></span></p><p style="background:#FFFFFF;text-indent:24pt;"><span style="font-size:10.5pt;"><span lang="en-us" xml:lang="en-us">尽管存在这些不足,但从发展的潜力及前景来看,珠海还是很不错的,</span></span></p><p style="background:#FFFFFF;text-indent:24pt;"><span style="font-size:10.5pt;"><span lang="en-us" xml:lang="en-us">首先珠海依山傍海，环境优雅，空气清新，气候条件优越，城市规划科学，环保水平高。优良的生态环境极适合软件开发工作。</span></span></p><p style="background:#FFFFFF;text-indent:24pt;"><span style="font-size:10.5pt;"><span lang="en-us" xml:lang="en-us">其次珠海优越的区位优势十分有利于软件技术交流，实现软件产业的国际化。珠海与澳门陆地相连，与香港水陆相接。借助澳台直航的便利，是台胞进入祖国大陆首选的口岸城市。珠海与澳门的合作及澳门作为中国与欧盟和葡语国家的桥梁的作用日益得到加强,我在写这篇文章的时候,港珠澳大桥已通过论证,相信这个大桥会给珠海带来更大的机遇。</span></span></p><p style="background:#FFFFFF;text-indent:24pt;"><span style="font-size:10.5pt;"><span lang="en-us" xml:lang="en-us">再次就是珠海正在形成的人才优势,近几年珠海大办大学园区，吸引全国和海外的重点或名牌高等院校到珠海办学、办分院，目前已有中山大学,暨南大学,哈工大,北理工,北师大等名校,这些院校为软件产业的发展提供了人才支撑; </span></span></p><p style="background:#FFFFFF;text-indent:24pt;"><span style="font-size:10.5pt;"><span lang="en-us" xml:lang="en-us">最后是市政府的大力支持,兴建了南方软件园,科技创新海岸,清华科技园等软件基地, 2001年8月，国家计委、信息产业部给珠海授予“国家软件产业基地”称号，这标志着珠海软件产业的发展将进入崭新的阶段，国家软件产业基地（珠海）将成为软件企业聚集和培养各类高水平软件人才的重要基地，推动珠海软件产业实现跨越式发展。　　<br/><span>    </span></span></span></p><p></p><p style="background:#FFFFFF;text-indent:24pt;"><strong><span style="font-size:10.5pt;">关于融资<span lang="en-us" xml:lang="en-us"></span></span></strong></p><p><strong></strong></p><strong></strong><p style="background:#FFFFFF;text-indent:24pt;"><span style="font-size:10.5pt;">这个我写得可能不多<span lang="en-us" xml:lang="en-us">,因为这需要专业人士的参与,不过有几点是需要注意的:</span></span></p><p></p><p style="background:#FFFFFF;margin-left:69pt;text-indent:-45pt;"><span lang="en-us" style="font-size:10.5pt;" xml:lang="en-us"><span>(1)<span style="font:7pt 'Times New Roman';">                    </span></span></span><span style="font-size:10.5pt;">产品方案一定要写好<span lang="en-us" xml:lang="en-us">, 包括</span></span><span style="font-size:10.5pt;">可行性分析报告<span lang="en-us" xml:lang="en-us">,行业分析,市场分析(成熟市场,潜在市场,市场前景等),用户行为分析,效益分析等.</span></span></p><p></p><p style="background:#FFFFFF;margin-left:69pt;text-indent:-45pt;"><span lang="en-us" style="font-size:10.5pt;" xml:lang="en-us"><span>(2)<span style="font:7pt 'Times New Roman';">                    </span></span></span><span style="font-size:10.5pt;">风险分析方案也要写好<span lang="en-us" xml:lang="en-us">,包括技术风险、管理风险、市场风险、资金风险、信息风险、政策风险等.</span></span><span lang="en-us" style="font-size:10.5pt;" xml:lang="en-us"></span></p><p></p><p style="background:#FFFFFF;margin-left:69pt;text-indent:-45pt;"><span lang="en-us" style="font-size:10.5pt;" xml:lang="en-us"><span>(3)<span style="font:7pt 'Times New Roman';">                    </span></span></span><span style="font-size:10.5pt;">谈判的时候一定要自信<span lang="en-us" xml:lang="en-us">, 当然也要拥有一定的经验及能力罗,坚持你的立场,专注于你的目标,:)</span></span></p><p></p><p style="background:#FFFFFF;margin-left:69pt;text-indent:-45pt;"><span lang="en-us" style="font-size:10.5pt;" xml:lang="en-us"><span>(4)<span style="font:7pt 'Times New Roman';">                    </span></span></span><span lang="en-us" style="font-size:10.5pt;" xml:lang="en-us">……</span></p><p></p><p style="background:#FFFFFF;"><span lang="en-us" style="font-size:10.5pt;" xml:lang="en-us"></span></p><p> </p><p style="background:#FFFFFF;text-indent:21pt;"><strong><span lang="en-us" xml:lang="en-us"></span></strong></p><p><strong><font size="3"> </font></strong></p><strong></strong><p style="background:#FFFFFF;text-indent:21pt;"><strong><span lang="en-us" xml:lang="en-us"></span></strong></p><p><strong><font size="3"> </font></strong></p><strong></strong><p style="background:#FFFFFF;text-indent:21pt;"><strong><span lang="en-us" xml:lang="en-us"></span></strong></p><p><strong><font size="3"> </font></strong></p><strong></strong><p style="background:#FFFFFF;text-indent:21pt;"><strong><font size="3">商业计划书模版</font></strong></p><p style="background:#FFFFFF;text-indent:21pt;"><strong><font size="3">参见文章&lt;&lt;<a href="http://www.csdn.net/develop/read_article.asp?id=20777">商业计划书模版</a>&gt;&gt;</font></strong></p>                </div>                    </div>
6112	 商业计划书模版	产品  融资  服务器  活动  文档  通讯  	1062296520	5024	harrymeng	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p>CSDN上发表有很多表格的WORD文档总是不行,希望有关人员查看一下原因,现在我只能用文本方式发表,难看得很,:)</p><p> </p><p>商业计划书模版</p><p> </p><p>×××××××××××产品</p><p>商 业 计 划 书</p><p> </p><p>目录</p><p>第一部分  概要 4<br/>第二部分  公司介绍 5<br/>一、宗旨 5<br/>二、公司简介 5<br/>三、公司产品和服务 5<br/>四、公司管理管理队伍状况 5<br/>五、知识产权策略 5<br/>第三部分  市场分析 5<br/>一、市场介绍 5<br/>二、目标市场分析 6<br/>三、顾客的购买准则 6<br/>四、销售策略 6<br/>五、市场渗透和销售量 6<br/>第四部分  竟争性分析 7<br/>一、主要竞争者 7<br/>二、我们的竞争优势 7<br/>三．我们的竞争策略 7<br/>第五部分  产品与服务 7<br/>一、产品规划 8<br/>二、研究与开发 8<br/>三、服务规划 8<br/>第六部分  市场与销售 8<br/>一、市场推广计划 8<br/>二、销售策略 8<br/>三、销售渠道与伙伴 8<br/>四、销售周期 8<br/>五、定价策略 8<br/>六、社会认证 9<br/>第七部分  赢利分析 9<br/>第八部分  融资计划 10<br/>第九部分  资金用途 10<br/>第十部分  经营目标 12<br/>第十一部分  附录 12<br/>一、公司股东结构、机构设置 12<br/>二、与投资者及经营团队履历 13<br/>三、××产品与国内外同类产品性能比较 13</p><p> </p><p>第一部分  概要</p><p>行业背景：……………….<br/>宗旨及商业模式：……..<br/>我们的产品和服务：</p><p>公司产品：××××××产品<br/> 产品名称 完成日期</p><p>第一期 1．×××系统 年 月底全部完成<br/> 2．×××系统 <br/> 3．×××系统 <br/> 4．×××系统 </p><p><br/>第二期 5．×××系统 年 月底全部完成<br/> 6．×××系统 <br/> 7．×××系统 <br/> 8．×××综合平台 <br/> 9．×××系统 <br/>第三期<br/> 10．×××系统 年 月底全部完成</p><p>公司服务：<br/>市场定位：<br/>资金需求：万元人民币<br/>资金筹措方法：引资入股,………..</p><p>第二部分  公司介绍</p><p>一、宗旨<br/>二、公司简介<br/>三、公司产品和服务<br/>公司产品：<br/>公司服务: <br/>四、公司管理管理队伍状况</p><p>五、知识产权策略</p><p>第三部分  市场分析</p><p>一、市场介绍<br/>1、 目前市场现状<br/>下表列出×××系统在全国各省的应用情况统计：</p><p> 中 国 移 动 中 国 联 通 工程公司及研究、测试机构<br/>×产品    <br/>    </p><p>×××产品在广东××市场的详细应用情况：</p><p><br/>2、市场潜在容量、市场规模和前景展望<br/> </p><p>3、整体市场运作思路<br/>整个市场思路大体为：<br/>×年×月—×年×月-—— 产品开发阶段：………………………………… <br/>——确定以后竞争的坚实技术基础 <br/>×年×月—×年×月—— 市场初步推广:…………………………………  <br/>——确定技术领先优势，市场品牌初步确立<br/>×年×月—×年×月—— 市场大规模推广:……………………………………<br/>——扩大技术领先优势，市场领导地位初步确立</p><p>二、目标市场分析</p><p>三、顾客的购买准则</p><p>四、销售策略<br/>1． 销售方式：<br/>2． 产品定位：</p><p>五、市场渗透和销售量<br/> ………………………………………………………………………..<br/>…………………………………………………………..</p><p>下表是今后三年销售量预测：<br/> <br/>产品名称 2003年 2004年 2005年<br/>×××产品 ××套 ××套 ××套<br/>×××产品 ××套 ××套 ××套<br/>×××产品 ××套 ××套 ××套<br/>×××产品统 ××套 ××套 ××套<br/>×××产品 ××套 ××套 ××套<br/>总计 ××套 ××套 ××套</p><p><br/>第四部分  竟争性分析<br/>一、主要竞争者</p><p>1．国外公司：主要有哪些公司，它们的优势及不足在哪里啊<br/>2．国内公司：主要有哪些公司，它们的优势及不足在哪里啊。下表列出了它们的产品及特点、市场占有率、竞争特点等。</p><p>    产品及特点   市场占有率 竞争特点<br/>×××公司   <br/>×××公司   <br/>×××公司   </p><p>二、我们的竞争优势<br/> <br/>1． 制度优势<br/>2． 产品和技术优势<br/>3． 营销优势<br/>  <br/>三．我们的竞争策略</p><p><br/>第五部分  产品与服务</p><p>一、产品规划<br/>……………………..<br/>二、研究与开发<br/>下表是第二期五个产品开发所需具有的一些条件</p><p>产品           研发条件<br/>×××产品 <br/> <br/> <br/> <br/> <br/>三、服务规划</p><p><br/>第六部分  市场与销售</p><p>一、市场推广计划<br/>……………………………………………<br/>二、销售策略<br/>三、销售渠道与伙伴<br/>    <br/>四、销售周期<br/>     <br/>五、定价策略<br/>基本原则：<br/>六、社会认证<br/>需要做以下一些认证：<br/>1、 产品认可证书：包括移动集团指定的权威机构做的产品鉴定证和省信息产业厅做的高科技产品认证；<br/>2、 双软企业认证；<br/>3、 高新技术企业认证；</p><p><br/>第七部分  赢利分析</p><p>××公司未来三年销售收入估测</p><p>销售数量预测</p><p>产品名称 2003年 2004年 2005年<br/>××产品 ××套 ××套 ××套<br/>××产品   <br/>  <br/>总计   </p><p><br/>销售单价</p><p>产品名称 2003年 2004年 2005年<br/>××产品 ××万/套 ××万/套 ××万/套<br/>××产品   <br/>   <br/>   <br/>   </p><p>总销售收入</p><p>产品名称 2003年 2004年 2005年<br/>××产品 ××万 ××万 ××万<br/>××产品   <br/>   <br/>总计   </p><p>总销售成本</p><p>         2003年 2004年 2005年<br/>人力成本 ××万 ××万 ××万<br/>销售费用   <br/>经营费用   <br/>材料成本   <br/>总计   </p><p>利润总额</p><p> 2003年 2004年 2005年<br/>合计 ××万 ××万 ××万</p><p><br/> </p><p>第八部分  融资计划</p><p>融资方案：<br/>公司估值： <br/>融资额：  <br/>投资入股方式：</p><p>第九部分  资金用途</p><p>××万元资金使用计划<br/>第一年资金使用明细如下：<br/>①固定资产投资：××万  <br/>固定资产支出明细表</p><p>名称 内容说明 数量 单价 总价<br/>服务器 兼容服务器   <br/>笔记本电脑 用于外出演示   <br/>投影仪 用于演示   <br/>集团电话    <br/>其它    <br/>     总计    </p><p>②人力资源投资：××万/年<br/>职务 人数 月薪(元) 总计（年）<br/>总经理   <br/>副总经理   <br/>技术总监   <br/>财务总监   <br/>市场总监   <br/>高级程序员   <br/>硬件、仓管   <br/>销售员   <br/>会计   <br/>出纳   <br/>行政   <br/>后勤   <br/>总计   </p><p>③经营费用：××万/年<br/>项目 说明 月费 年费<br/>   网络费及通信费 网站、公司通讯  <br/>房屋租金 100平米  <br/>水电、办公耗材   <br/>公司内部活动费   <br/>总计   </p><p>④市场和销售费用：××万/年<br/>项目 说明 月费 年费<br/>广告、产品发布费 媒体广告  <br/>客户关系、活动费 与移动、联通、电信公司<br/>等建立各种社会关系  <br/>差旅费 每月5人次  <br/>   <br/>总计   </p><p>⑤研发投入：××万/年<br/>  ………………………<br/>⑥项目正常零备件最低储备 + 周转需垫付资金：××万/年<br/>⑦预备金（不可预见的人员投入、软硬件投入、维修费用、市场投入等）：××万/年<br/>  <br/>①②③④⑤⑥⑦项合计：××万元人民币</p><p>第十部分  经营目标</p><p>………………………………………………………………………..<br/>………………………………………………………………<br/>第十一部分  附录</p><p>一、公司股东结构、机构设置<br/>1． 公司股东结构<br/>注册资本<br/>××万人民币<br/>股东以及股权比例</p><p>甲              ：  董事长                       占   股权</p><p>乙              ：  总经理                       占   股权</p><p>丙              ：  副总经理                     占   股份</p><p>丁    ：  技术总监                     占   股权</p><p>戊              ：  财务总监                     占   股权</p><p><br/>2．机构设置<br/>                        <br/>   <br/>                                  </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p><br/>二、与投资者及经营团队履历<br/>甲：<br/>乙：<br/>丙：<br/>丁：<br/>戊：<br/>三、××产品与国内外同类产品性能比较<br/></p>                </div>                    </div>
6844	 精彩总结：★加密网页破解大法★	加密  破解  javascript  function  解密  button  	986895240	6791	net_lover	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <div align="center"><b>加密网页破解大法</b></div><table align="center" border="0" cellpadding="0" cellspacing="0" width="640"><tbody><tr><td><p align="center"><b><a href="http://go.163.com/~colorweb" style="text-decoration:none;"><img alt="copyright.gif" border="0" src="http://go.163.com/~colorweb/images/copyright.gif"/>　孟子E章</a> </b></p><p></p><p>　　当你在浏览网页时，看到一个很漂亮的特效，你查看源代码时看到的是一队乱码，那多扫兴呀！根据本人的研究，总结出了三种解密方法，与大家分享！！</p><p><b>方法一：</b></p><p>　　有一种加密的办法是采用javascript的escape()函数，把某些符号、汉字等变成乱码，以达到迷惑人的目的。解密这种代码的办法是采用其反函数加以还原。下面是一个经过加密的例子：</p><blockquote><p>&lt;HTML&gt;<br/>&lt;SCRIPT LANGUAGE="Javascript"&gt;<br/>var Words ="%3Chtml%3E%3Cbody%20bgcolor%3D%22red%22%3E%3Cp%3E%u8FD9%u662F%u4F8B%u5B50%uFF01%uFF01%uFF1A%uFF09%3C/p%3E%3C/body%3E%3C/html%3E"<br/>var NewWords;<br/>NewWords = unescape(Words);<br/>document.write(NewWords)<br/>&lt;/SCRIPT&gt;<br/>&lt;BODY&gt;<br/>&lt;/BODY&gt;<br/>&lt;/HTML&gt;</p></blockquote><p>　　这种文件最好解密，一看就明白，关键是unescape()函数起了还原源代码的作用。要想看到加密前的代码是什么样子，可以用下面的办法：</p><blockquote><p>&lt;HTML&gt;&lt;SCRIPT LANGUAGE="Javascript"&gt;<br/>var Words ="%3Chtml%3E%3Cbody%20bgcolor%3D%22red%22%3E%3Cp%3E%u8FD9%u662F%u4F8B%u5B50%uFF01%uFF01%uFF1A%uFF09%3C/p%3E%3C/body%3E%3C/html%3E"<br/>var NewWords;<br/>NewWords = unescape(Words);<br/>NewWords=NewWords.toString();<br/>function password(){<br/>document.pw.txtpw.value=NewWords;<br/>}<br/>&lt;/SCRIPT&gt;<br/>&lt;BODY&gt;<br/>&lt;form name=pw&gt;<br/>&lt;input type=button onclick="password()" value="解密"&gt;<br/>&lt;br&gt;<br/>&lt;textarea name="txtpw" cols="100" rows="100"&gt;&lt;/textarea&gt;<br/>&lt;/form&gt;<br/>&lt;/BODY&gt;<br/>&lt;/HTML&gt;</p></blockquote><p><b>方法二：</b></p><p>　　有一个软件叫HTMLEncrypt.exe，它就是把源代码进行加密的软件，这个软件的加密的原理是把字符转换。下面的例子是一个分帧的页面：</p><blockquote><p>&lt;html&gt;&lt;head&gt;&lt;script&gt;<br/>function Carbosoft( s ) { var sRet=""; for(j=0; j&lt; s.length; j++ ){ var n= s.charCodeAt(j); if (n&gt;=8364) {n = 128;} sRet += String.fromCharCode( n - 3 ); } return( sRet ); }<br/>var sJsCmds ="" +<br/>"?kwpoA?khdgA?phwd#kwws0htxly@%Frqwhqw0W|sh%#frqwhqw@%wh{w2kwpo&gt;#fkduvhw@lvr0;;8&lt;04%A?wlwohAZHOFRPH?2wlwohA?phwd#qdph@%JHQHUDWRU%#frqwhqw@%Plfurvriw#IurqwSdjh#613%A?phwd#qdph@%Plfurvriw#Wkhph%#frqwhqw@%qrqh/#ghidxow%A?phwd#qdph@%Plfurvriw#Erughu%#frqwhqw@%qrqh/#ghidxow%A?2khdgA?iudphvhw#erughu@%3%#iudpherughu@%3%#urzv@%-/93%A##?iudph#qdph@%pdlq%#vuf@%xs1kwp%#vfuroolqj@%dxwr%A##?iudph#qdph@%rqolqh%#vuf@%grzq1kwp%#vfuroolqj@%qr%#qruhvl}h#wdujhw@%beodqn%A##?qriudphvA##?erg|A##?sAWklv#sdjh#xvhv#iudphv/#exw#|rxu#eurzvhu#grhvq*w#vxssruw#wkhp1#?2sA##?2erg|A##?2qriudphvA?2iudphvhwA?2kwpoA?irqw#froru@%&amp;33333%A?s#doljq@%fhqwhu%A?vpdooA?irqw#idfh@%Wdkrpd%AWklv#iloh#zdv#hqfu|swhg#xvlqj#dq#xquhjlvwhuhg#yhuvlrq#ri#?d#kuhi@%kwws=22fduer{1wkhgqv1qhw2kwpohqfu|sw1kwp%AKWPO#Hqfu|sw#y413?2dA1?2irqwA?2vpdooA?2sA" +<br/>"";<br/>var s= Carbosoft( sJsCmds);<br/>document.write (s);<br/>&lt;/script&gt;<br/>&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</p></blockquote><p>　　从上面可以看出，浏览器解释这写代码前，进行了还原，从而可以得到破解的方法如下： </p><blockquote><p>&lt;script&gt;<br/>function Carbosoft( s ) { var sRet=""; for(j=0; j&lt; s.length; j++ ){ var n= s.charCodeAt(j); if (n&gt;=8364) {n = 128;} sRet += String.fromCharCode( n - 3 ); } return( sRet ); }<br/>var sJsCmds ="" +<br/>"?kwpoA?khdgA?phwd#kwws0htxly@%Frqwhqw0W|sh%#frqwhqw@%wh{w2kwpo&gt;#fkduvhw@lvr0;;8&lt;04%A?wlwohAZHOFRPH?2wlwohA?phwd#qdph@%JHQHUDWRU%#frqwhqw@%Plfurvriw#IurqwSdjh#613%A?phwd#qdph@%Plfurvriw#Wkhph%#frqwhqw@%qrqh/#ghidxow%A?phwd#qdph@%Plfurvriw#Erughu%#frqwhqw@%qrqh/#ghidxow%A?2khdgA?iudphvhw#erughu@%3%#iudpherughu@%3%#urzv@%-/93%A##?iudph#qdph@%pdlq%#vuf@%xs1kwp%#vfuroolqj@%dxwr%A##?iudph#qdph@%rqolqh%#vuf@%grzq1kwp%#vfuroolqj@%qr%#qruhvl}h#wdujhw@%beodqn%A##?qriudphvA##?erg|A##?sAWklv#sdjh#xvhv#iudphv/#exw#|rxu#eurzvhu#grhvq*w#vxssruw#wkhp1#?2sA##?2erg|A##?2qriudphvA?2iudphvhwA?2kwpoA?irqw#froru@%&amp;33333%A?s#doljq@%fhqwhu%A?vpdooA?irqw#idfh@%Wdkrpd%AWklv#iloh#zdv#hqfu|swhg#xvlqj#dq#xquhjlvwhuhg#yhuvlrq#ri#?d#kuhi@%kwws=22fduer{1wkhgqv1qhw2kwpohqfu|sw1kwp%AKWPO#Hqfu|sw#y413?2dA1?2irqwA?2vpdooA?2sA" +<br/>"";<br/>var s= Carbosoft( sJsCmds);<br/>&lt;/script&gt;<br/>&lt;form name=qq&gt;<br/>&lt;textarea name=ww cols=100 rows=10&gt;&lt;/textarea&gt;<br/>&lt;input onclick='ww.value=s' type=button value="解密"&gt;<br/>&lt;/form&gt;</p></blockquote><p><b>方法三：</b></p><p>　　有一种加密方法是每行单独加密，还原起来比较复杂。看一个加密过的原文：</p><blockquote><p>&lt;HTML&gt;<br/>&lt;BODY&gt;<br/>&lt;SCRIPT LANGUAGE="JavaScript"&gt;<br/>function Decode() {<br/>d("FrfmnD");d("FruyvDFgwhqjfWnyeseysuEXpydy%whqjf~J~XWghwEXfkjJpgXDFIgwhqjfD");d("FmufyWrffjKuieqdEX?klfulfK$ajuXWwklfulfEXfubfIrfmnGWwryhgufEsx}{~}XD");d("FfqfnuDejFIfqfnuD");d("FIruyvD");d("FxkvaD");d("FIxkvaD");d("FIrfmnD");d("W");return 0;}<br/>&lt;/SCRIPT&gt;<br/>&lt;SCRIPT LANGUAGE="JavaScript"&gt;<br/>function d (enc) {document.write(codeIt(key,enc));}<br/>var key = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!/"/ /|#$%&amp;/'()*+,-.//:;&lt;=&gt;?@[//]^_/t/`{}~/n";function codeIt (mC, eS) {var wTG, mcH = mC.length / 2, nS = "", dv;for (var x = 0; x &lt; eS.length; x++) { wTG = mC.indexOf(eS.charAt(x));if (wTG &gt; mcH) {dv = wTG - mcH; nS = nS + mC.charAt(48 - dv);}else {dv = mcH - wTG;nS = nS + mC.charAt(48 + dv);}}return nS;}<br/>&lt;/SCRIPT&gt;<br/>&lt;SCRIPT LANGUAGE="JavaScript"&gt;<br/>Decode();<br/>&lt;/SCRIPT&gt;<br/>&lt;/BODY&gt;<br/>&lt;/HTML&gt;</p></blockquote><p>　　还原的时候，也必须每行单独解密，用下面的方法可以看到源代码：</p><blockquote><p>&lt;HTML&gt;<br/>&lt;BODY&gt;<br/>&lt;SCRIPT LANGUAGE="JavaScript"&gt;<br/>function Decode() {<br/>d("FrfmnD");d("FruyvDFgwhqjfWnyeseysuEXpydy%whqjf~J~XWghwEXfkjJpgXDFIgwhqjfD");d("FmufyWrffjKuieqdEX?klfulfK$ajuXWwklfulfEXfubfIrfmnGWwryhgufEsx}{~}XD");d("FfqfnuDejFIfqfnuD");d("FIruyvD");d("FxkvaD");d("FIxkvaD");d("FIrfmnD");d("W");return 0;}<br/>&lt;/SCRIPT&gt;<br/>&lt;SCRIPT LANGUAGE="JavaScript"&gt;<br/>function d (enc) {alert(codeIt(key,enc));}<br/>var key = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!/"/ /|#$%&amp;/'()*+,-.//:;&lt;=&gt;?@[//]^_/t/`{}~/n";function codeIt (mC, eS) {var wTG, mcH = mC.length / 2, nS = "", dv;for (var x = 0; x &lt; eS.length; x++) { wTG = mC.indexOf(eS.charAt(x));if (wTG &gt; mcH) {dv = wTG - mcH; nS = nS + mC.charAt(48 - dv);}else {dv = mcH - wTG;nS = nS + mC.charAt(48 + dv);}}return nS;}<br/>&lt;/SCRIPT&gt;<br/>&lt;SCRIPT LANGUAGE="JavaScript"&gt;<br/>Decode();<br/>&lt;/SCRIPT&gt;<br/>&lt;/BODY&gt;<br/>&lt;/HTML&gt;</p></blockquote><p>　　哈哈！！:=)是不是很精彩！！</p></td></tr></tbody></table>                </div>                    </div>
6960	 在XSLT实现按日期排序	xslt  xsl  stylesheet  javascript  encoding  asp.net  	1077778140	3898	net_lover	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p align="center"><strong>在XSLT实现按日期排序</strong> </p><p align="center"><br/>作者：孟宪会 出自：【孟宪会之精彩世界】 发布日期：2004年2月21日 11点47分56秒 </p><p><br/>    我们在使用XSLT进行XML转换的时候，经常遇到按XML日期类型的数据进行排序的情况，按照默认的排序规则，很难实现正确的排序效果。虽然最新的MsXML3 SP4提供了3种数据类型的排序方式： </p><div style="border-right:.5pt solid;padding-right:5.4pt;border-top:.5pt solid;padding-left:5.4pt;background:#e6e6e6;padding-bottom:4px;border-left:.5pt solid;padding-top:4px;border-bottom:.5pt solid;"><div><span style="color:#000000;">  </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">xsl:sort <br/>    </span><span style="color:#ff0000;">select </span><span style="color:#0000ff;">= string-expression <br/>    </span><span style="color:#ff0000;">data-type </span><span style="color:#0000ff;">= { </span><span style="color:#ff0000;">"text" | "number" | Qname }<br/>    order </span><span style="color:#0000ff;">= { </span><span style="color:#ff0000;">"ascending" | "descending" } <br/>  </span><span style="color:#0000ff;">/&gt;</span></div></div><p>但好像仍不能满足我们的需要，下面我们就介绍日期类型数据的排序方法。我们的排序方法是基于下面语句的返回值为true的理论的： </p><div style="border-right:.5pt solid;padding-right:5.4pt;border-top:.5pt solid;padding-left:5.4pt;background:#e6e6e6;padding-bottom:4px;border-left:.5pt solid;padding-top:4px;border-bottom:.5pt solid;"><div><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">script </span><span style="color:#ff0000;">language</span><span style="color:#0000ff;">="JavaScript"</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;background-color:#f5f5f5;">    alert(Date.parse(</span><span style="color:#000000;background-color:#f5f5f5;">"</span><span style="color:#000000;background-color:#f5f5f5;">2004/08/09</span><span style="color:#000000;background-color:#f5f5f5;">"</span><span style="color:#000000;background-color:#f5f5f5;">)</span><span style="color:#000000;background-color:#f5f5f5;">==</span><span style="color:#000000;background-color:#f5f5f5;">Date.parse(</span><span style="color:#000000;background-color:#f5f5f5;">"</span><span style="color:#000000;background-color:#f5f5f5;">2004/8/9</span><span style="color:#000000;background-color:#f5f5f5;">"</span><span style="color:#000000;background-color:#f5f5f5;">))  </span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">script</span><span style="color:#0000ff;">&gt;</span></div></div><p>好了，下面就是我们的xsl文件： </p><p><strong>SortXML.xsl</strong> </p><div style="border-right:.5pt solid;padding-right:5.4pt;border-top:.5pt solid;padding-left:5.4pt;background:#e6e6e6;padding-bottom:4px;border-left:.5pt solid;padding-top:4px;border-bottom:.5pt solid;"><div><span style="color:#0000ff;">&lt;?</span><span style="color:#ff00ff;">xml version="1.0" encoding="gb2312"</span><span style="color:#0000ff;">?&gt;</span><span style="color:#000000;"><br/></span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">xsl:stylesheet </span><span style="color:#ff0000;">version</span><span style="color:#0000ff;">="1.0"</span><span style="color:#ff0000;"> xmlns:xsl</span><span style="color:#0000ff;">="http://www.w3.org/1999/XSL/Transform"</span><span style="color:#ff0000;"><br/> xmlns:msxsl</span><span style="color:#0000ff;">="urn:schemas-microsoft-com:xslt"</span><span style="color:#ff0000;"> xmlns:user</span><span style="color:#0000ff;">="http://dotnet.aspx.cc/"</span><span style="color:#ff0000;"><br/> exclude-result-prefixes</span><span style="color:#0000ff;">="msxsl user"</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>  </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">msxsl:script </span><span style="color:#ff0000;">language</span><span style="color:#0000ff;">="JavaScript"</span><span style="color:#ff0000;"> implements-prefix</span><span style="color:#0000ff;">="user"</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>    function xmlDateTime(nodelist) {<br/>      return Date.parse(nodelist.replace(/-/g,"/"));<br/>    }<br/>  </span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">msxsl:script</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>  </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">xsl:output </span><span style="color:#ff0000;">omit-xml-declaration</span><span style="color:#0000ff;">="yes"</span><span style="color:#0000ff;">/&gt;</span><span style="color:#000000;"><br/>  </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">xsl:template </span><span style="color:#ff0000;">match</span><span style="color:#0000ff;">="/"</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>    </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">xsl:call-template </span><span style="color:#ff0000;">name</span><span style="color:#0000ff;">="ItemList"</span><span style="color:#0000ff;">/&gt;</span><span style="color:#000000;"><br/>  </span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">xsl:template</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>  </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">xsl:template </span><span style="color:#ff0000;">name</span><span style="color:#0000ff;">="ItemList"</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>    </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">table </span><span style="color:#ff0000;">bgcolor</span><span style="color:#0000ff;">="snow"</span><span style="color:#ff0000;"> border</span><span style="color:#0000ff;">="1"</span><span style="color:#ff0000;"> cellpadding</span><span style="color:#0000ff;">="5"</span><span style="color:#ff0000;"> cellspacing</span><span style="color:#0000ff;">="2"</span><span style="color:#ff0000;"> borderColor</span><span style="color:#0000ff;">="darkorange"</span><span style="color:#ff0000;"> style</span><span style="color:#0000ff;">="font-size:9pt"</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>      </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">thead</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>        </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">tr </span><span style="color:#ff0000;">bgcolor</span><span style="color:#0000ff;">=""</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>          </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">th </span><span style="color:#ff0000;">width</span><span style="color:#0000ff;">="50%"</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;">标题</span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">th</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>          </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">th </span><span style="color:#ff0000;">width</span><span style="color:#0000ff;">="50%"</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;">修改时间</span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">th</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>        </span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">tr</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>      </span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">thead</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>      </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">tbody</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>        </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">xsl:for-each </span><span style="color:#ff0000;">select</span><span style="color:#0000ff;">="/multistatus/response"</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>          </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">xsl:sort </span><span style="color:#ff0000;">order</span><span style="color:#0000ff;">="descending"</span><span style="color:#ff0000;"> select</span><span style="color:#0000ff;">="user:xmlDateTime(string(getlastmodified))"</span><span style="color:#ff0000;"> data-type</span><span style="color:#0000ff;">="number"</span><span style="color:#0000ff;">/&gt;</span><span style="color:#000000;"><br/>          </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">tr</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>            </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">td</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>              </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">a </span><span style="color:#ff0000;">href</span><span style="color:#0000ff;">="{href}"</span><span style="color:#ff0000;"> target</span><span style="color:#0000ff;">="_blank"</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>                </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">xsl:value-of </span><span style="color:#ff0000;">select</span><span style="color:#0000ff;">="Title"</span><span style="color:#0000ff;">/&gt;</span><span style="color:#000000;"><br/>              </span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">a</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>            </span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">td</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>            </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">td</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>              </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">xsl:value-of </span><span style="color:#ff0000;">select</span><span style="color:#0000ff;">="getlastmodified"</span><span style="color:#0000ff;">/&gt;</span><span style="color:#000000;"><br/>            </span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">td</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>          </span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">tr</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>        </span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">xsl:for-each</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>      </span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">tbody</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>    </span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">table</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>  </span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">xsl:template</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/></span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">xsl:stylesheet</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/></span></div></div><p><strong>SortXML.xml</strong></p><div style="border-right:.5pt solid;padding-right:5.4pt;border-top:.5pt solid;padding-left:5.4pt;background:#e6e6e6;padding-bottom:4px;border-left:.5pt solid;padding-top:4px;border-bottom:.5pt solid;"><div><span style="color:#0000ff;">&lt;?</span><span style="color:#ff00ff;">xml version="1.0" encoding="GB2312"</span><span style="color:#0000ff;">?&gt;</span><span style="color:#000000;"><br/></span><span style="color:#0000ff;">&lt;?</span><span style="color:#ff00ff;">xml-stylesheet type="text/xsl" href="SortXML.xsl"</span><span style="color:#0000ff;">?&gt;</span><span style="color:#000000;"><br/></span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">multistatus</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>  </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">response</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>    </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">href</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;">http://sz.luohuedu.net/xml/</span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">href</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>    </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">getlastmodified</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;">2004-8-14 10:51:44</span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">getlastmodified</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>    </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">Title</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;">【孟宪会之精彩世界】</span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">Title</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>  </span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">response</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>  </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">response</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>    </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">href</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;">http://dotnet.aspx.cc/Play.aspx</span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">href</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>    </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">getlastmodified</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;">2004-10-23 11:11:10</span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">getlastmodified</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>    </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">Title</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;">【孟宪会之精彩世界】音乐频道</span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">Title</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>  </span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">response</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>  </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">response</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>    </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">href</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;">http://dotnet.aspx.cc/</span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">href</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>    </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">getlastmodified</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;">2004-02-10 18:36:19</span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">getlastmodified</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>    </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">Title</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;">【孟宪会之精彩世界】</span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">Title</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>  </span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">response</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>  </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">response</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>    </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">href</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;">http://lucky.myrice.com/</span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">href</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>    </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">getlastmodified</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;">2004-01-14 10:51:21</span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">getlastmodified</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>    </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">Title</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;">【孟宪会之精彩世界】</span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">Title</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>  </span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">response</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>  </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">response</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>    </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">href</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;">http://dotnet.aspx.cc/ShowList.aspx</span><span style="color:#ff0000;">&amp;amp;</span><span style="color:#000000;">id=1</span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">href</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>    </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">getlastmodified</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;">2003-11-2 10:52:26</span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">getlastmodified</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>    </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">Title</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;">【孟宪会之精彩世界】ASP.NET</span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">Title</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>  </span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">response</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>  </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">response</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>    </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">href</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;">http://dotnet.aspx.cc/CoolMenu/main.htm</span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">href</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>    </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">getlastmodified</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;">1999-02-21 22:07:43</span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">getlastmodified</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>    </span><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">Title</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;">【孟宪会之精彩世界】DHtml精彩放送</span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">Title</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/>  </span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">response</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/></span><span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">multistatus</span><span style="color:#0000ff;">&gt;</span><span style="color:#000000;"><br/></span></div></div><p><br/></p>                </div>                    </div>
7617	 BMP、GIF和JPEG文件格式简介及相互转换	数据结构  多媒体系统  算法  struct  descriptor  windows  	990188040	3341	CandyCat	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <table align="center" border="0" cellpadding="0" cellspacing="0" width="647"><tbody><tr><td colspan="16" width="647"><table border="0" cellpadding="2" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#330066" width="73%"><font color="#ffffff">BMP、GIF和JPEG文件格式简介及相互转换　作者：江平　发布时间：2000/11/27<!-- #EndEditable --></font></td></tr></tbody></table></td></tr><tr><td colspan="16" height="25" width="647"> </td></tr><tr><td colspan="16" width="647"></td></tr><tr><td colspan="16" height="22" width="647"><table align="left" border="0" cellpadding="5" cellspacing="0" width="95%"><tbody><tr bgcolor="#e6e6e6"><td><font size="2">文章摘要:</font></td></tr><tr><td><!-- #BeginEditable "summary" -->　<span class="line">　本文主要讨论的是位图的压缩方法。</span><!-- #EndEditable --> </td></tr></tbody></table><font size="2"><img alt="" height="1" src="" width="1"/>        </font></td></tr><tr><td colspan="16" width="647"><hr align="left" size="1" width="95%"/></td></tr></tbody></table><table align="center" border="0" cellpadding="5" cellspacing="0" width="647"><tbody><tr><td bgcolor="#e6e6e6" height="25" width="200"><font size="2">正文:</font></td><td align="right" bgcolor="#e6e6e6" width="395"><a><img alt="button_class.GIF" border="0" height="19" src="http://www.china-pub.com/images/button_class.GIF" width="66"/></a></td><td align="right" height="25" width="22"> </td></tr><tr><td colspan="2"><!-- #BeginEditable "topic" --><p align="center"><b><font size="5"><font class="font1" color="#c45868">BMP、GIF和JPEG文件格式简介及相互转换</font><font class="font1" color="#5288c7">　　</font></font></b></p><p><br/><span class="line">　　图象文件就是描绘了一幅图象的计算机磁盘文件。形成数字图象数据后，将其存储在计算机里的方法有2种，即位映射和向量处理方式。<br/>　　我们这里主要讨论的是位图。不同图象软件几乎都用各种的方法处理图象，图象格式也多种多样，它主要包括文件识别头和图象数据。文件识别头用来让计算机判断是哪种文件格式，图象数据包含了整个对图象描绘相关数据，包括调色板、位图映象等。根据压缩算法不同，映象方式也不同，下面简要介绍一下压缩算法。 </span></p><p><span class="line"><b><font color="#5288c7">一、 行程长度压缩</font></b> <br/>　　原理是将一扫描行中的颜色值相同的相邻像素用一个计数值和那些像素的颜色值来代替。例如:aaabccccccddeee，则可用3a1b6c2d3e来代替。对于拥有大面积，相同颜色区域的图像，用RLE压缩方法非常有效。由RLE原理派生出许多具体行程压缩方法: <br/>　　1.PCX行程压缩方法: 该算法实际上是位映射格式到压缩格式的转换算法，该算法对于连续出现1次的字节Ch，若Ch&gt;0xc0则压缩时在该字节前加上0xc1，否则直接输出Ch，对于连续出现N 次的字节Ch，则压缩成0xc0＋N，Ch这两个字节，因而N最大只能为ff－c0=3fh(十进制为63)，当N大于63时， 则需分多次压缩。 <br/>　　2.BI_RLE8压缩方法:在WINDOWS的位图文件中采用了这种压缩方法。该压缩方法编码也是以两个字节为基本单位。其中第一个字节规定了用第二个字节指定的颜色重复次数。 如编码 0504表示从当前位置开始连续显示5个颜色值为04的像素。当第二个字节为零时第二个字节有特殊含义:0表示行末;1表示图末;2转义后面2个字节， 这两个字节分别表示下一像素相对于当前位置的水平位移和垂直位移。这种压缩方法所能压缩的图像像素位数最大为8位(256色)图像。<br/>　　3.BI_RLE压缩方法: 该方法也用于WINDOWS位图文件中，它与 BI_RLE8编码类似，唯一不同是:BI_RLE4的一个字节包含了两个像素的颜色，因此，它只能压缩的颜色数不超过16的图像。因而这种压缩应用范围有限。 <br/>　　4.紧缩位压缩方法(Packbits):该方法是用于Apple公司的Macintosh机上的位图数据压缩 方法， TIFF 规范中使用了这种方法， 这种压缩方法与BI_RLE8压缩方法相似，如1c1c1c2132325648 压缩为:83 1c 21 81 32 56 48，显而易见， 这种压缩方法最好情况是每连续128个字节相同，这128个字节可压缩为一个数值7f。这种方法还是非常有效的。 </span></p><p><span class="line"><b><font color="#5288c7">二、霍夫曼编码压缩:</font></b> <br/>　　也是一种常用的压缩方法。是1952年为文本文件建立的，其基本原理是频繁使用的数据用较短的代码代替，很少使用的数据用较长的代码代替，每个数据的代码各不相同。这些代码都是二进制码，且码的长度是可变的。如: 有一个原始数据序列，ABACCDAA则编码为A(0)，B(10)，C(110),(D111)，压缩后为010011011011100。产生霍夫曼编码需要对原始数据扫描两遍，第一遍扫描要精确地统计出原始数据中的每个值出现的频率，第二遍是建立霍夫曼树并进行编码，由于需要建立二叉树并遍历二叉树生成编码，因此数据压缩和还原速度都较慢，但简单有效，因而得到广泛的应用。</span></p><p><span class="line"><b><font color="#5288c7">三、LZW压缩方法</font></b> <br/>　　LZW压缩技术比其它大多数压缩技术都复杂， 压缩效率也较高。其基本原理是把每一个第一次出现的字符串用一个数值来编码，在还原程序中再将这个数值还成原来的字符 串，如用数值0x100代替字符串"abccddeee"这样每当出现该字符串时，都用0x100代替，起到了压缩的作用。 至于0x100与字符串的对应关系则是在压缩过程中动态生成的，而且这种对应关系是隐含在压缩数据中，随着解压缩的进行这张编码表会从压缩数据中逐步得到恢复，后面的压缩数据再根据前面数据产生的对应关系产生更多的对应关系。直到压缩文件结束为止。LZW是可逆的， 所有信息全部保留。</span></p><p><span class="line"><b><font color="#5288c7">四、算术压缩方法</font> </b><br/>　　算术压缩与霍夫曼编码压缩方法类似，只不过它比霍夫曼编码更加有效。算术压缩适合于由相同的重复序列组成的文件，算术压缩接近压缩的理论极限。这种方法，是将不同的序列映像到0到1之间的区域内，该区域表示成可变精度(位数 )的二进制小数，越不常见的数据要的精度越高(更多的位数)，这种方法比较复杂，因而不太常用。</span></p><p><span class="line"><b><font color="#5288c7">五、 JPEG( 联合摄影专家组 Joint Photographic Exprerts Group)</font></b> <br/>　　JPEG标准与其它的标准不同，它定义了不兼容的编码方法，在它最常用的模式中，它是带失真的，一个从JPEG文件恢复出来的图像与原始图像总是不同的，但有损压缩重建后的图像常常比原始图像的效果更好。JPEG的另一个显著的特点是它的压缩比例相当高，原图像大小与压缩后的图像大小相比，比例可以从1％到80～90％不等。 这种方法效 果也好，适合多媒体系统。</span></p><p><span class="line">　　介绍完了压缩算法，我们来简要介绍一下三种位图格式的异同和它们之间的相互转换。<br/>　　<b>1. bmp图象</b><br/>　　　· 位图文件头(BITMAPHEADER)数据结构<br/>　　　· 位图信息(BITMAPINFO)数据结构<br/>　　　· 位图阵列</span></p><p><span class="line">　　1)位图文件头数据结构包含BMP图象文件的类型、显示内容等信息。<br/>　　Typedef struct{<br/>　　　　　　Int bfType; //must be "BM"<br/>　　　　　　Long bfSize; //位图大小<br/>　　　　　　Int bfReserved1;//must be "0"<br/>　　　　　　Int bfReserved2;//must be "0"<br/>　　　　　　Long bfOffBits;//位图阵列的起始位置<br/>　　}BITMAPEFILEHEADER;</span></p><p><span class="line">　　2)位图信息数据结构由BITMAPINFOHEADER和RGBQUAD两个数据结构组成，<br/>　　typedef struct{<br/>　　　　　　BITMAPINFOHEADER bmiHeader;<br/>　　　　　　RGBQUAD bmiColors[];<br/>　　}BITMAPINFO</span></p><p><span class="line">　　其中BITMAPINFOHEADER数据结构包含了有关BMP图象的宽、高、压缩方法等信息。<br/>　　数据结构RGBQUAD定义一种颜色。</span></p><p><span class="line">　　3）位图阵列<br/>　　位图阵列记录了图象的每一个象素值。从图象的左下角开始逐行扫描图象。从左到右，从上到下，将图象的象素值逐一记录下来，这些记录象素值的字节组成了位图阵列。<br/>　　位图阵列数据的存储格式有压缩和非压缩两种格式。<br/>　　1． 非压缩格式 位图中的每一个点的象素值对应与位图阵列的若干位，而位图阵列的若干位由图象的高度、宽度及图象的颜色数决定。<br/>　　2． 压缩格式 在bmp格式文件中，Windows支持BI-RLE8和BI-RLE4两种压缩类型的存储格式。</span></p><p><span class="line">　　<b>2、GIF图象文件格式</b><br/>　　GIF的全称是Graphics Interchange Format,.译做图形交换格式。GIF是一种公用的图象文件格式标准，但它归compuServe公司版权所有。<br/>GIF文件结构包含一个文件头，<br/>　　　　　　　　　　　　</span></p><p><span class="line">　　在一个GIF文件中首先碰到的是GIF的标志，这个标志告诉解码程序这是个GIF文件。这个标志是3字节的串：GIF。一个GIF文件中可以存放多幅图象，但绝大多数的文件都只包含一幅图象。<br/>　　然后是屏幕描述字(screen descriptor),说明了用来生成的显示文件中的图象的显示器分辨率，分别表示屏幕的宽和高。<br/>　　紧跟下来的一个字节是全局标志，其低三位说明了即将碰到的图象是多少颜色的。最高位表示是否存在一个全局色彩表。<br/>　　背景色表示把背景置成适当的颜色，实际上是一个指向全局色彩表的数。<br/>　　Struct Global_Data{<br/>　　　　Unsigned short screen_width;<br/>　　　　Unsigned short screen_height;<br/>　　　　Unsigned char background;<br/>　　　　har tail='/0';<br/>　　　　}<br/>　　接下来是全局色彩表，按顺序存放所有的严肃，每一种严肃由色彩表的一项来描述，每项是3字节，分别表示红、绿、蓝三种原色的强度。其长度有全局标志的低三位表示。<br/>　　以后的数据都是局部的了。是些数据块的集合。下面是图象数据块的结构。<br/>　　Struct Local_Head{<br/>　　　　　　Char heading=',';<br/>　　　　　　Unsigned short image_left;//图象的屏幕上显示的起始位置<br/>　　　　Unsigned short image_top;<br/>　　　　Unsigned short image_width;<br/>　　　　Unsigned short image-height;<br/>　　　　Unsigned char local_flag;//局部标志<br/>　　　　} </span></p><p><span class="line">　　局部标志和 全局标志的不同之处在于次高位，如果这位被置成1则表示图像的位图数据是以隔行方式存放的。也就是说，在解开的位图数据中，第一行存放的是屏幕上第一行，第二行对应屏幕上的第9行，第三行对应屏幕上的第17行，以此递增--这是第一遍扫描；第二遍扫描是从屏幕上的第5行开始，两行之间也是以8递增；第三遍扫描是从屏幕上的第3行开始，两行之间以4递增；第四遍扫描，也是最后一遍，从第2行开始，两行之间以2递增。隔行存放的图像数据和顺序（不隔行）存放的图像数据的对应关系如下图所示：<br/>　　</span></p><p><span class="line">　　隔行存放的GIF图像在边解码边显示的时候可分成四遍扫描。第一遍扫描虽然只显示了整个图像的八分之一，第二遍的扫描后也只显示了四分之一，但这已经把整个图像的概貌显示出来了。在显示GIF图像的时，隔行存放的图像会给你这样一个印象：向它的显示速度似乎要比其他图像快一些，这是隔行存放的优点。<br/>　　在GIF图像的编解码中用到了LZW压缩算法--把这些字符流转换成另一种形式的代码流，解码过程则是把这种代码流还原成原来的字符流。</span></p><p><span class="line">　　<b>3、JPEG图象文件格式</b><br/>　　JPEG是Joint Photographic Experts Group(联合摄影专家小组)的首字母缩写。JPEG的主要作用是用于数字化图象的标准编码技术。JPEG图象文件是一种象素格式文件格式，但它比诸如象GIF、BMP等图象文件要复杂的多。所幸,我们在使用由JPEG组成的JPEG库时,只要对该文件格式有个一般的了解就可以了。而没有必要对JPEG文件格式做一个全面细致的了解。<br/>　　JPEG格式是种有损的编码格式，但如果GIF文件比，他经过解码后的重构图象要比GIF图象更接近于原始的图象。 JPEG编码技术是由颜色转换、DCT变换、进行量化、编码。其压缩格式由著名的JPEG集团所著的4.0版本的库所定。</span></p><p><span class="line">　　关于这3种图象格式的互相转换，主要是用c语言或c++和汇编语言，因为这些语言可以 直接进行底层的操作，把图象解压缩后按用另一种格式要求进行压缩即可。</span></p></td></tr></tbody></table>                </div>                    </div>
7756	 《深入了解.NET框架》	.net  microsoft  语言  编译器  exception  框架  	992922360	1254	benben1hao	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p>深入了解.net框架(一)<br/>理解受管理的执行(managed excution)<br/>    在受管理的执行过程的第一步是设计源程序。如果你想你的应用程序受益于common language runtime(公共语言运行时)，你必须使用一个或多个支持运行时的语言编译器，比如visual basic,c#,visual c++或者其他第三方编辑器，比如perl或cobel编辑器。<br/>    由于运行时(runtime)是一种多语言执行环境，它广泛的支持多种数据类型和语言</p><p>特性。你所使用的编辑器决定了将要使用运行时(runtime)哪一部分的功能，这样，你</p><p>可以使用这些特性设计你的代码。你代码的语法时由编辑器决定的，而不是由运行时决定的。如果你的组件要能够被其他语言编写的组件完全可用，你必须在组件的导出类型中使用这种包括在common language specification(CLS)中的语言特性。<br/>    当你的代码被写好，编译好后，编辑器将它翻译成微软中间语言(MSIL)，并产生所需要的元数据(metadata)。当你准备执行你的代码时，MSIL就通过Just In Time(JIT)</p><p>编辑器编译成本地代码(即：适合本机执行环境的代码)。如果安全策略要求代码是安全类型的，JIT编辑器的还要检测IL是否是安全类型(type-safety)的；如果安全类系检查没有通过，当代码执行时，将抛出一个例外(exception)。<br/>    在执行过程中，运行时(runtime)提供许多服务，包括自动内存管理，调试支持，</p><p>加强安全性和使代码能和其他非管理代码(unmanaged code)比如COM组件之间协调工作的能力。下面将介绍更多的关于受管理的执行的详细信息。<br/>    1、<br/>    微软中间语言(Microsoft Intermediate Language MSIL)<br/>    如果你把你的源程序编译成受管理的代码(managed code)，编辑器将把你的源代码翻译成微软中间语言(MSIL)。MSIL与具体的CPU指令无关，并能有效的转化为本地代码。MSIL包括很多指令，比如用于转载，存储，初始化，调用对象方法的指令，以及用于算术、逻辑运算，控制流，直接内存访问，例外处理等指令。在代码被执行前，MSIL必须被JIT(Just In Time)编辑器转化成适合特定CPU的代码。由于运行时支持一个和多个用于不同计算机体系结构的JIT编辑器，所以相同的MSIL能够被JIT编译后在任何一台MSIL支持的计算机上运行。<br/>    当一个编辑器产生了MSIL后，它也产生了元数据(metadata)，它能够描述你的代码中的类型，包括每种类型定义，每种类型成员的识别标志，你的代码应用的成员和其他在代码执行的时候运行时(runtime)所要使用到的数据。MSIL和元数据被包含在PE (Portable Executable)文件中。这种文件是基于和扩展了已经发布了的Microsoft </p><p>Portable Executable(PE)和Common Object File Format(COFF)。这种包括了MSIL或者</p><p>本地代码一级元数据的文件格式使操作系统能识别公共语言运行时(Common Language </p><p>Runtime)映象。在这个有MSIL的文件里，元数据的存在使你的代码能够描述它自身，这就意味着不再需要类型库或者IDL。当在执行过程中，运行时(runtime)能定位和摘取所需要的元数据。<br/>    2、<br/>    JIT编译<br/>    在MSIL被执行之前，它必须被.net框架Just In Time(JIT)编译器转化成本地代码</p><p>(native code)，这是一种与特定CUP有关(CUP-specific)的代码，它能运行在有JIT编</p><p>辑器的相同体系结构的计算机上。由于运行时提供了一个能支持不同CPU的的JIT编辑器，开发人员就能够写出一套能被JIT编译后，在不同体系结构的计算机执行的MSIL。(如果你的受管理的代码调用了特定平台的本地APIs或者特定平台的类库，你的代码就只能运行在这个特定的操作系统。)<br/>    在JIT编辑后，我们可以获得某些代码在执行过程中从来不会被调用的信息。这样，与其消耗许多时间和内存将包含所有的MSIL的PE文件转化成本地代码，不如只将要使用MSIL转化为本地代码。装载器在装载时为每种类型的方法创建一个stub(关于将MSIL转化成本地代码的方法的信息描述，包括方法的入口地址等)，并和方法联系起来。在调用方法的初始化时，这个stub将控制传给JIT编译器，编译器把方法的MSIL转化成本地代码并将stub指向本地代码的地方。以后在被JIT编译的指向先前生成的本地代码的方法调用时，就会减少被JIT编译器和执行代码所花费的时间。<br/>    在将MSIL转化成本地代码的过程中，代码必须通过一个认证过程(除非管理员已经建立了安全策略，这样就可以将代码绕过认证)。认证检查MSIL和元数据，以便知道代码是否时类型安全的(type-safe)，这也就意味着对经过授权的内存进行访问。类型安全对确定对象之间是否时安全独立的很重要。这样就能防止无意和恶意的冲突。类型安全也为代码的安全限制可靠的加强提供了保障。<br/>    由于代码时经过安全类型检测的，所以运行时就能保证下面的几条：<br/>    .对类型的引用是和正在应有的类型是严格兼容的<br/>    .只有正确的定义的操作才能被一个对象调用<br/>    .标识符是被申明了的<br/>    在认证过程中，检查MSIL代码以便确定代码是否被允许访问的内存地址和是否通过正确定义的类型调用方法。例如，代码不能访问所限定的内存以外的地址。此外，由于错误的MSIL能导致类型安全规则错误，认证要观察代码，看MSIL是否被正确的产生。认证过程只传递类型安全的代码。然而，某些类型安全的代码由于认证过程的限制而不能通过认证，并且有些语言也不能产生可认证的类型安全代码。</p>                </div>                    </div>
7795	 DOM4J 使用简介	interface  xml  iterator  文档  stylesheet  string  	1071676680	9207	icecloud	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <div class="Section1">   <p class="MsoNormal"><b><span lang="en-us" style="font-size:14pt;font-family:Georgia;" xml:lang="en-us">Dom4j </span></b><b><span style="font-size:14pt;font-family:'黑体';">使用简介</span></b></p>   <p class="MsoNormal"><span style="font-family:'宋体';color:#000080;">作者：冰云</span><span lang="en-us" style="font-family:'Courier New';color:#000080;" xml:lang="en-us"> icecloud(AT)sina.com</span></p>   <p class="MsoNormal"><span style="font-family:'宋体';color:#000080;">时间：</span><span lang="en-us" style="font-family:'Courier New';color:#000080;" xml:lang="en-us">2003.12.15</span></p>   <table border="1" cellpadding="0" cellspacing="0" class="MsoTableGrid"><tbody><tr><td bgcolor="#EAEAEA" height="216" valign="top" width="500"> <blockquote>        <p class="MsoNormal"> </p>        <p class="MsoNormal"><b><span style="font-family:'宋体';color:#CC0000;">版权声明：</span></b></p>        <p class="MsoNormal"><span style="font-family:'宋体';">本文由冰云完成，首发于</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">CSDN</span><span style="font-family:'宋体';">，未经许可，不得使用于任何商业用途。</span></p>      <p class="MsoNormal"><span style="font-family:'宋体';">文中代码部分引用自</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">DOM4J</span><span style="font-family:'宋体';">文档。</span></p>      <p class="MsoNormal"><span style="font-family:'宋体';">欢迎转载，但请保持文章及版权声明完整。</span></p>      <p class="MsoNormal"><span style="font-family:'宋体';">如需联络请发邮件：</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">icecloud(AT)sina.com</span></p>      </blockquote>        <p class="MsoNormal"> </p></td>     </tr></tbody></table><p class="MsoNormal"><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">    DOM4J</span><span style="font-family:'宋体';">是</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">dom4j.org</span><span style="font-family:'宋体';">出品的一个开源</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">XML</span><span style="font-family:'宋体';">解析包，它的网站中这样定义：</span></p>   <p class="MsoNormal"><i><span lang="en-us" style="font-family:'Courier New';color:#000080;" xml:lang="en-us">Dom4j</span></i><i><span lang="en-us" style="font-family:'Courier New';color:#000080;" xml:lang="en-us"> is an easy to use, open source library for working with XML, XPath and XSLT on the Java platform using the Java Collections Framework and with full support for DOM, SAX and JAXP.</span></i></p>   <p class="MsoNormal"><b><span lang="en-us" style="font-family:'Courier New';color:#000080;" xml:lang="en-us">Dom4j</span></b><b><span style="font-family:'宋体';color:#000080;">是一个易用的、开源的库，用于</span></b><b><span lang="en-us" style="font-family:'Courier New';color:#000080;" xml:lang="en-us">XML</span></b><b><span style="font-family:'宋体';color:#000080;">，</span></b><b><span lang="en-us" style="font-family:'Courier New';color:#000080;" xml:lang="en-us">XPath</span></b><b><span style="font-family:'宋体';color:#000080;">和</span></b><b><span lang="en-us" style="font-family:'Courier New';color:#000080;" xml:lang="en-us">XSLT</span></b><b><span style="font-family:'宋体';color:#000080;">。它应用于</span></b><b><span lang="en-us" style="font-family:'Courier New';color:#000080;" xml:lang="en-us">Java</span></b><b><span style="font-family:'宋体';color:#000080;">平台，采用了</span></b><b><span lang="en-us" style="font-family:'Courier New';color:#000080;" xml:lang="en-us">Java</span></b><b><span style="font-family:'宋体';color:#000080;">集合框架并完全支持</span></b><b><span lang="en-us" style="font-family:'Courier New';color:#000080;" xml:lang="en-us">DOM</span></b><b><span style="font-family:'宋体';color:#000080;">，</span></b><b><span lang="en-us" style="font-family:'Courier New';color:#000080;" xml:lang="en-us">SAX</span></b><b><span style="font-family:'宋体';color:#000080;">和</span></b><b><span lang="en-us" style="font-family:'Courier New';color:#000080;" xml:lang="en-us">JAXP</span></b><b><span style="font-family:'宋体';color:#000080;">。</span></b></p>   <p class="MsoNormal"><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">DOM4J</span><span style="font-family:'宋体';">使用起来非常简单。只要你了解基本的</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">XML-DOM</span><span style="font-family:'宋体';">模型，就能使用。然而他自己带的指南只有短短一页（</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">html</span><span style="font-family:'宋体';">），不过说的到挺全。国内的中文资料很少。因而俺写这个短小的教程方便大家使用，这篇文章仅谈及基本的用法，如需深入的使用，请</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">……</span><span style="font-family:'宋体';">自己摸索或查找别的资料。</span></p>   <p class="MsoNormal"><span style="font-family:'宋体';">之前看过</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">IBM developer</span><span style="font-family:'宋体';">社区的文章（参见附录），提到一些</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">XML</span><span style="font-family:'宋体';">解析包的性能比较，其中</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">DOM4J</span><span style="font-family:'宋体';">的性能非常出色，在多项测试中名列前茅。（事实上</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">DOM4J</span><span style="font-family:'宋体';">的官方文档中也引用了这个比较）所以这次的项目中我采用了</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">DOM4J</span><span style="font-family:'宋体';">作为</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">XML</span><span style="font-family:'宋体';">解析工具。</span></p>   <p class="MsoNormal"><span style="font-family:'宋体';">在国内比较流行的是使用</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">JDOM</span><span style="font-family:'宋体';">作为解析器，两者各擅其长，但</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">DOM4J</span><span style="font-family:'宋体';">最大的特色是使用大量的接口，这也是它被认为比</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">JDOM</span><span style="font-family:'宋体';">灵活的主要原因。大师不是说过么，</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">“</span><span style="font-family:'宋体';">面向接口编程</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">”</span><span style="font-family:'宋体';">。目前使用</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">DOM4J</span><span style="font-family:'宋体';">的已经越来越多。如果你善于使用</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">JDOM</span><span style="font-family:'宋体';">，不妨继续用下去，只看看本篇文章作为了解与比较，如果你正要采用一种解析器，不如就用</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">DOM4J</span><span style="font-family:'宋体';">吧。</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us"> </span></p>   <p class="MsoNormal"><span style="font-family:'宋体';">它的主要接口都在</span><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">org.dom4j</span><span style="font-family:'宋体';">这个包里定义：</span></p>   <div align="center">     <table border="1" cellpadding="0" cellspacing="0" class="MsoTableGrid" width="543"><tbody><tr><td bgcolor="#EAEAEA" width="154"> <p class="MsoNormal"><b><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"><a href="../Local%20Settings/Temporary%20Internet%20Files/MyWeb/myclasses/dom4j-1.4/doc/apidocs/org/dom4j/Attribute.html"><i><span style="text-decoration:none;">Attribute</span></i></a></span></b></p></td>         <td width="389"> <p class="MsoNormal"><code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">Attribute</span></code><code><span style="font-size:9pt;">定义了</span></code><code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">XML</span></code><code><span style="font-size:9pt;">的属性</span></code></p></td>       </tr><tr><td bgcolor="#EAEAEA" width="154"> <p class="MsoNormal"><b><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"><a href="../Local%20Settings/Temporary%20Internet%20Files/MyWeb/myclasses/dom4j-1.4/doc/apidocs/org/dom4j/Branch.html"><i><span style="text-decoration:none;">Branch</span></i></a></span></b></p></td>         <td width="389"> <p class="MsoNormal"><code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">Branch</span></code><code><span style="font-size:9pt;">为能够包含子节点的节点如</span></code><code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">XML</span></code><code><span style="font-size:9pt;">元素</span></code><code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">(Element)</span></code><code><span style="font-size:9pt;">和文档</span></code><code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">(Docuemnts)</span></code><code><span style="font-size:9pt;">定义了一个公共的行为，</span></code></p></td>       </tr><tr><td bgcolor="#EAEAEA" width="154"> <p class="MsoNormal"><b><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"><a href="../Local%20Settings/Temporary%20Internet%20Files/MyWeb/myclasses/dom4j-1.4/doc/apidocs/org/dom4j/CDATA.html"><i><span style="text-decoration:none;">CDATA</span></i></a></span></b></p></td>         <td width="389"> <p class="MsoNormal"><code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">CDATA</span></code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"> </span><span style="font-size:9pt;font-family:'宋体';">定义了</span><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">XML CDATA </span><span style="font-size:9pt;font-family:'宋体';">区域</span></p></td>       </tr><tr><td bgcolor="#EAEAEA" width="154"> <p class="MsoNormal"><b><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"><a href="../Local%20Settings/Temporary%20Internet%20Files/MyWeb/myclasses/dom4j-1.4/doc/apidocs/org/dom4j/CharacterData.html"><i><span style="text-decoration:none;">CharacterData</span></i></a></span></b></p></td>         <td width="389"> <p class="MsoNormal"><code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">CharacterData</span></code><code><span style="font-size:9pt;">是一个标识借口，标识基于字符的节点。如</span></code><code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">CDATA</span></code><code><span style="font-size:9pt;">，</span></code><code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">Comment, Text</span></code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">.</span></p></td>       </tr><tr><td bgcolor="#EAEAEA" width="154"> <p class="MsoNormal"><b><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"><a href="../Local%20Settings/Temporary%20Internet%20Files/MyWeb/myclasses/dom4j-1.4/doc/apidocs/org/dom4j/Comment.html"><i><span style="text-decoration:none;">Comment</span></i></a></span></b></p></td>         <td width="389"> <p class="MsoNormal"><code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">Comment</span></code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"> </span><span style="font-size:9pt;font-family:'宋体';">定义了</span><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">XML</span><span style="font-size:9pt;font-family:'宋体';">注释的行为</span></p></td>       </tr><tr><td bgcolor="#EAEAEA" width="154"> <p class="MsoNormal"><b><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"><a href="../Local%20Settings/Temporary%20Internet%20Files/MyWeb/myclasses/dom4j-1.4/doc/apidocs/org/dom4j/Document.html"><i><span style="text-decoration:none;">Document</span></i></a></span></b></p></td>         <td width="389"> <p class="MsoNormal"><code><span style="font-size:9pt;">定义了</span></code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">XML</span><span style="font-size:9pt;font-family:'宋体';">文档</span></p></td>       </tr><tr><td bgcolor="#EAEAEA" width="154"> <p class="MsoNormal"><b><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"><a href="../Local%20Settings/Temporary%20Internet%20Files/MyWeb/myclasses/dom4j-1.4/doc/apidocs/org/dom4j/DocumentType.html"><i><span style="text-decoration:none;">DocumentType</span></i></a></span></b></p></td>         <td width="389"> <p class="MsoNormal"><code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">DocumentType</span></code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"> </span><span style="font-size:9pt;font-family:'宋体';">定义</span><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">XML DOCTYPE</span><span style="font-size:9pt;font-family:'宋体';">声明</span></p></td>       </tr><tr><td bgcolor="#EAEAEA" width="154"> <p class="MsoNormal"><b><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"><a href="../Local%20Settings/Temporary%20Internet%20Files/MyWeb/myclasses/dom4j-1.4/doc/apidocs/org/dom4j/Element.html"><i><span style="text-decoration:none;">Element</span></i></a></span></b></p></td>         <td width="389"> <p class="MsoNormal"><code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">Element</span></code><span style="font-size:9pt;font-family:'宋体';">定义</span><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">XML </span><span style="font-size:9pt;font-family:'宋体';">元素</span></p></td>       </tr><tr><td bgcolor="#EAEAEA" width="154"> <p class="MsoNormal"><b><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"><a href="../Local%20Settings/Temporary%20Internet%20Files/MyWeb/myclasses/dom4j-1.4/doc/apidocs/org/dom4j/ElementHandler.html"><i><span style="text-decoration:none;">ElementHandler</span></i></a></span></b></p></td>         <td width="389"> <p class="MsoNormal"><code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">ElementHandler</span></code><span style="font-size:9pt;font-family:'宋体';">定义了</span><span style="font-size:9pt;font-family:'Courier New';"> <code><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">Element</span></code><span lang="en-us" xml:lang="en-us"> </span></span><span style="font-size:9pt;font-family:'宋体';">对象的处理器</span></p></td>       </tr><tr><td bgcolor="#EAEAEA" width="154"> <p class="MsoNormal"><b><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"><a href="../Local%20Settings/Temporary%20Internet%20Files/MyWeb/myclasses/dom4j-1.4/doc/apidocs/org/dom4j/ElementPath.html"><i><span style="text-decoration:none;">ElementPath</span></i></a></span></b></p></td>         <td width="389"> <p class="MsoNormal"><span style="font-size:9pt;font-family:'宋体';">被</span><span style="font-size:9pt;font-family:'Courier New';"> <span lang="en-us" xml:lang="en-us"><a href="../Local%20Settings/Temporary%20Internet%20Files/MyWeb/myclasses/dom4j-1.4/doc/apidocs/org/dom4j/ElementHandler.html"><code><span style="font-family:'Courier New';text-decoration:none;">ElementHandler</span></code></a> </span></span><span style="font-size:9pt;font-family:'宋体';">使用，用于取得当前正在处理的路径层次信息</span></p></td>       </tr><tr><td bgcolor="#EAEAEA" width="154"> <p class="MsoNormal"><b><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"><a href="../Local%20Settings/Temporary%20Internet%20Files/MyWeb/myclasses/dom4j-1.4/doc/apidocs/org/dom4j/Entity.html"><i><span style="text-decoration:none;">Entity</span></i></a></span></b></p></td>         <td width="389"> <p class="MsoNormal"><code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">Entity</span></code><span style="font-size:9pt;font-family:'宋体';">定义</span><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"> XML entity</span></p></td>       </tr><tr><td bgcolor="#EAEAEA" width="154"> <p class="MsoNormal"><b><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"><a href="../Local%20Settings/Temporary%20Internet%20Files/MyWeb/myclasses/dom4j-1.4/doc/apidocs/org/dom4j/Node.html"><i><span style="text-decoration:none;">Node</span></i></a></span></b></p></td>         <td width="389"> <p class="MsoNormal"><code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">Node</span></code><code><span style="font-size:9pt;">为所有的</span></code><code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">dom4j</span></code><code><span style="font-size:9pt;">中</span></code><code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">XML</span></code><code><span style="font-size:9pt;">节点</span></code><span style="font-size:9pt;font-family:'宋体';">定义了多态行为</span></p></td>       </tr><tr><td bgcolor="#EAEAEA" width="154"> <p class="MsoNormal"><b><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"><a href="../Local%20Settings/Temporary%20Internet%20Files/MyWeb/myclasses/dom4j-1.4/doc/apidocs/org/dom4j/NodeFilter.html"><i><span style="text-decoration:none;">NodeFilter</span></i></a></span></b></p></td>         <td width="389"> <p class="MsoNormal"><code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">NodeFilter</span></code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"> </span><span style="font-size:9pt;font-family:'宋体';">定义了在</span><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">dom4j</span><span style="font-size:9pt;font-family:'宋体';">节点中产生的一个滤镜或谓词的行为（</span><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">predicate</span><span style="font-size:9pt;font-family:'宋体';">）</span></p></td>       </tr><tr><td bgcolor="#EAEAEA" width="154"> <p class="MsoNormal"><b><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"><a href="../Local%20Settings/Temporary%20Internet%20Files/MyWeb/myclasses/dom4j-1.4/doc/apidocs/org/dom4j/ProcessingInstruction.html"><i><span style="text-decoration:none;">ProcessingInstruction</span></i></a></span></b></p></td>         <td width="389"> <p class="MsoNormal"><code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">ProcessingInstruction</span></code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"> </span><span style="font-size:9pt;font-family:'宋体';">定义</span><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"> XML </span><span style="font-size:9pt;font-family:'宋体';">处理指令</span><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">.</span></p></td>       </tr><tr><td bgcolor="#EAEAEA" width="154"> <p class="MsoNormal"><b><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"><a href="../Local%20Settings/Temporary%20Internet%20Files/MyWeb/myclasses/dom4j-1.4/doc/apidocs/org/dom4j/Text.html"><i><span style="text-decoration:none;">Text</span></i></a></span></b></p></td>         <td width="389"> <p class="MsoNormal"><code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">Text</span></code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"> </span><span style="font-size:9pt;font-family:'宋体';">定义</span><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">XML </span><span style="font-size:9pt;font-family:'宋体';">文本节点</span><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">.</span></p></td>       </tr><tr><td bgcolor="#EAEAEA" width="154"> <p class="MsoNormal"><b><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"><a href="../Local%20Settings/Temporary%20Internet%20Files/MyWeb/myclasses/dom4j-1.4/doc/apidocs/org/dom4j/Visitor.html"><i><span style="text-decoration:none;">Visitor</span></i></a></span></b></p></td>         <td width="389"> <p class="MsoNormal"><code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">Visitor</span></code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"> </span><span style="font-size:9pt;font-family:'宋体';">用于实现</span><code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">Visitor</span></code><span style="font-size:9pt;font-family:'宋体';">模式</span><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">.</span></p></td>       </tr><tr><td bgcolor="#EAEAEA" width="154"> <p class="MsoNormal"><b><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"><a href="../Local%20Settings/Temporary%20Internet%20Files/MyWeb/myclasses/dom4j-1.4/doc/apidocs/org/dom4j/XPath.html"><i><span style="text-decoration:none;">XPath</span></i></a></span></b></p></td>         <td width="389"> <p class="MsoNormal"><code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">XPath</span></code><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us"> </span><span style="font-size:9pt;font-family:'宋体';">在分析一个字符串后会提供一个</span><span lang="en-us" style="font-size:9pt;font-family:'Courier New';" xml:lang="en-us">XPath </span><span style="font-size:9pt;font-family:'宋体';">表达式</span></p></td>       </tr></tbody></table></div>   <p class="MsoNormal"><span style="font-family:'宋体';">看名字大致就知道它们的涵义如何了。</span></p>   <p class="MsoNormal"><span style="font-family:'宋体';">要想弄懂这套接口，关键的是要明白接口的继承关系：</span></p>   <ul type="circle"><li class="MsoNormal" style="text-align:left;"><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">interface java.lang.<a href="http://java.sun.com/products/jdk/1.3/docs/api/java/lang/Cloneable.html"><b><span style="text-decoration:none;">Cloneable</span></b></a> </span><ul type="circle"><li class="MsoNormal" style="text-align:left;"><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">interface org.dom4j.<a href="../Local%20Settings/Temporary%20Internet%20Files/MyWeb/myclasses/dom4j-1.4/doc/apidocs/org/dom4j/Node.html"><b><span style="text-decoration:none;">Node</span></b></a> </span></li>     </ul></li>     </ul><ul type="circle"><li><ul type="circle"><li><ul type="square"><li class="MsoNormal" style="text-align:left;"><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">interface org.dom4j.<a href="../Local%20Settings/Temporary%20Internet%20Files/MyWeb/myclasses/dom4j-1.4/doc/apidocs/org/dom4j/Attribute.html"><b><span style="text-decoration:none;">Attribute</span></b></a> </span></li>         <li class="MsoNormal" style="text-align:left;"><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">interface org.dom4j.<a href="../Local%20Settings/Temporary%20Internet%20Files/MyWeb/myclasses/dom4j-1.4/doc/apidocs/org/dom4j/Branch.html"><b><span style="text-decoration:none;">Branch</span></b></a> </span></li>       </ul></li></ul></li></ul><ul type="circle"><li><ul type="circle"><li><ul type="square"><li><ul type="square"><li class="MsoNormal" style="text-align:left;"><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">interface org.dom4j.<a href="../Local%20Settings/Temporary%20Internet%20Files/MyWeb/myclasses/dom4j-1.4/doc/apidocs/org/dom4j/Document.html"><b><span style="text-decoration:none;">Document</span></b></a> </span></li>           <li class="MsoNormal" style="text-align:left;"><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">interface org.dom4j.<a href="../Local%20Settings/Temporary%20Internet%20Files/MyWeb/myclasses/dom4j-1.4/doc/apidocs/org/dom4j/Element.html"><b><span style="text-decoration:none;">Element</span></b></a></span></li>         </ul></li><li class="MsoNormal" style="text-align:left;"><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">interface org.dom4j.<a href="../Local%20Settings/Temporary%20Internet%20Files/MyWeb/myclasses/dom4j-1.4/doc/apidocs/org/dom4j/CharacterData.html"><b><span style="text-decoration:none;">CharacterData</span></b></a> </span><ul type="square"><li class="MsoNormal" style="text-align:left;"><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">interface org.dom4j.<a href="../Local%20Settings/Temporary%20Internet%20Files/MyWeb/myclasses/dom4j-1.4/doc/apidocs/org/dom4j/CDATA.html"><b><span style="text-decoration:none;">CDATA</span></b></a> </span></li>           <li class="MsoNormal" style="text-align:left;"><span lang="en-us" style="font-family:'Courier New';" xml:lang="en-us">interface org.dom4j.<a href="../Local%20Settings
8543	 在 Delphi 下自定义通用对话框------自定义打开文件对话框	delphi  interface  button  windows  dialog  command  	1074604260	4546	happyjoe	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <span style="font-size:9pt;font-family:'宋体';"> </span><p><font style="font-weight:bold;font-size:10pt;">在 Delphi 下自定义通用对话框</font><br/>--------------自定义打开文件对话框</p> <p>    几次碰到有人在论坛里问如何在 Delphi 下自定义通用对话框，本人对此问题也比较感兴趣，所以抽点时间搞了下，现在把“成果”与大家分享。本文的题目大了点，通用对话框有好多，但这里只以打开文件对话框为例。其实自定义所有通用对话框的原理是一样的。</p> <p><font style="font-weight:bold;font-size:9pt;">第一步：建立对话框模版</font></p> <p>    先来说个概念：对话框模版。对话框模版是一种资源，在 .rc 文件中定义，编译后生成 .res 文件，最终一般存在于资源动态链接库(DLL)中或可执行程序中。在专业的共享软件中一般都大量使用模版来创建对话框。通过模版生成的对话框一般用来采集用户输入，上面可以放标准的 Windows 控件，比如 Button, Label, TextBox, ListBox, ListView, TreeView 等。 </p> <p>    通用对话框也是由对话框模版生成的窗体，只不过这些对话框模版由操作系统定义，自定义通用对话框就是通过更改这些模版来实现的（打开和保存文件对话框例外，它们是通过添加新的模版来自定义的）。所以第一步要知道怎样定义对话框模版，可以在 Notpad 里直接敲 .rc 文件（这种方法这里就不使用了），还可以使用现有的工具，我机器上最好的工具是 Visual Studio .Net IDE，只需要点几下鼠标即可。（用它也可以查看、修改可执行文件中的资源，直接点打开-&gt;文件，打开可执行文件即可）。现在就先在 VS.Net 中定义一个对话框模版（过程略），该模版就是我们在打开文件对话框上自定义的部分，需要注意的是该模版必须具有 DS_3DLOOK 、DS_CONTROL 、WS_CHILD 、WS_CLIPSIBLINGS 风格且不能有 Border，因为通用对话框是将我们的整个模版当作子窗体SubClass 到原有对话框的（类似 Button 等标准控件与其拥有者的关系）。我将对话框模版的外观和 .rc 文件的内容贴出来：</p> <p><img alt="o_DialogTemplate.gif" src="/images/blog_csdn_net/happyjoe/23329/o_DialogTemplate.gif"/></p><pre style="border-right:#cccccc 1px solid;border-top:#cccccc 1px solid;font-size:9pt;border-left:#cccccc 1px solid;border-bottom:#cccccc 1px solid;font-family:'Courier New', Courier, mono;background-color:#eeeeee;">// .rc 文件内容 <br/>131 DIALOGEX 0, 0, 282, 36 <br/>STYLE DS_SETFONT | DS_3DLOOK | DS_FIXEDSYS | DS_CONTROL | WS_CHILD | WS_CLIPSIBLINGS <br/>FONT 8, "MS Shell Dlg", 400, 0, 0x1 <br/>BEGIN <br/>   LTEXT "文件名称：",-1,7,8,40,8 <br/>   LTEXT "此静态控件用来显示文件名称",1004,51,8,224,8, SS_PATHELLIPSIS <br/>   CONTROL "如果选中文件是图片文件则进行预览",1005,"Button", BS_AUTOCHECKBOX | WS_TABSTOP,7,18,268,10 <br/>END </pre> <p><br/>    上面对话框模版中的 CheckBox 没有任何实际意义，只用来说明功能。将此 .rc 文件编译成 .res 文件（可以用 VS.Net 直接编译，也可以用 Delphi 带的 brcc32 工具）以备后面例子使用。</p> <p><font style="font-weight:bold;font-size:9pt;">第二步：继承 TOpenDialog 类 </font></p> <p>    调用打开文件对话框只需一个 API：GetOpenFileName，这个 API 需要一个 OPENFILENAME 结构的参数，自定义对话框时将该结构的 lpTemplateName 成员指定为对话框模版的标识（Identifier）并在 flags 成员中包含 OFN_ENABLETEMPLATE 常数即可。</p> <p>    对话框模版及其包含的每个控件都应该有自己唯一的标识，而且这些标识不能与通用对话框上原有控件的标识重复。标识有2种：字符串标识和数字标识，在本例中使用数字标识：对话框模版的标识为 131，第一个静态控件的标识为 -1，第二个静态控件的标识为 1004，CheckBox 的标识为 1005。（标识为 -1 的控件一般为内容固定不变的静态控件。） OPENFILENAME 结构的 lpTemplateName 成员的类型是 null-terminated 字符串指针，如果对话框模版的标识为字符串，则可直接赋值，比如某模版的标识为 IDD_MYDIALOG，那么赋值语句为：lpTemplateName := PChar('IDD_MYDIALOG')，如果为数字，比如本例中的模版的标识为 131，赋值语句则为：lpTemplateName := Windows.MakeIntResource(131)。</p> <p>    Delphi 中所有通用对话框类都继承自 TCommonDialg 抽象类，在这个抽象类中定义了个受保护的(Protected)属性：Template，类型为 PChar。这个属性就是用来存放模版标识的，但遗憾的是我们不能在除它的继承类以外的地方访问到它（因为受保护）。所以我们需要在它的孙子类中重新定义一公有(Public)属性来间接访问它。</p> <p>    在 Delphi 里新建一个 VCL 类 TMyOpenDialog 继承自 TOpenDialog 类，定义一公有属性 TemplateRes ，通过其写入方法为受保护的 Template 属性赋值，下面列出代码：</p> <div style="border-right:#cccccc 1px solid;border-top:#cccccc 1px solid;font-size:9pt;border-left:#cccccc 1px solid;border-bottom:#cccccc 1px solid;font-family:'Courier New', Courier, mono;background-color:#eeeeee;">//******************************************** <br/>// MyOpenDialog.pas <br/>// TMyOpenDialog 类实现自定义打开文件对话框 <br/>// by: Joe Huang date: 2004-01-05 <br/>//******************************************** <br/>unit MyOpenDialog; <br/><br/>interface <br/><br/>uses <br/>SysUtils, Classes, Dialogs, Windows, Messages, CommDlg; <br/><br/>type <br/>   TCommandEvent = procedure (ControlID: Word) of object; <br/>   TMyOpenDialog = class(TOpenDialog) <br/>   private <br/>      { Private declarations } <br/>      FTemplateRes: PChar; <br/>      FOnCommand: TCommandEvent; <br/><br/>      procedure SetTemplateRes(const Value: PChar); <br/>   protected <br/>      { Protected declarations } <br/>      procedure WndProc(var Message: TMessage); override; <br/>   public <br/>      { Public declarations } <br/>      //该属性用来指定自定义模版的标识 <br/>      property TemplateRes: PChar read FTemplateRes write SetTemplateRes; <br/>   published <br/>      { Published declarations } <br/>      property OnCommand: TCommandEvent read FOnCommand write FOnCommand; <br/>   end; <br/><br/>procedure Register; <br/><br/>implementation <br/><br/>procedure Register; <br/>begin <br/>   RegisterComponents('Samples', [TMyOpenDialog]); <br/>end; <br/><br/>{ TMyOpenDialog } <br/><br/>procedure TMyOpenDialog.SetTemplateRes(const Value: PChar); <br/>begin <br/>   FTemplateRes := Value; <br/>   Self.Template := Value; <br/>end; <br/><br/>procedure TMyOpenDialog.WndProc(var Message: TMessage); <br/>begin <br/>   Message.Result := 0; <br/>   if (Message.Msg = WM_COMMAND) then <br/>   begin <br/>      if Assigned(FOnCommand) then <br/>         FOnCommand(Message.WParamLo); <br/>   end; <br/>   inherited WndProc(Message); <br/>end; <br/><br/>end. </div> <p>    TMyOpenDialog 类还定义了一个事件用来捕获对话框模版上控件状态发生的改变（后面说明此事件的用法）。将该类注册到组件面板的 Samples 页中。</p> <p><font style="font-weight:bold;font-size:9pt;">第三步：建立工程实现自定义对话框 </font></p> <p>    新建一工程保存至目录，将第一步中的 .res 文件放至该目录中并加入到工程文件中。从 Samples 页中把我们的新控件拖入 Form1 中，名字为 MyOpenDialog1，再在 Form1 上放入 Button1，Button1 的 On_Click 事件代码如下：</p> <div style="border-right:#cccccc 1px solid;border-top:#cccccc 1px solid;font-size:9pt;border-left:#cccccc 1px solid;border-bottom:#cccccc 1px solid;font-family:'Courier New', Courier, mono;background-color:#eeeeee;">procedure TForm1.Button1Click(Sender: TObject); <br/>begin <br/>   MyOpenDialog1.TemplateRes := Windows.MakeIntResource(131); <br/>   MyOpenDialog1.Execute; <br/>end;</div> <p>MyOpenDialog1 的 On_Show 事件代码如下：</p> <div style="border-right:#cccccc 1px solid;border-top:#cccccc 1px solid;font-size:9pt;border-left:#cccccc 1px solid;border-bottom:#cccccc 1px solid;font-family:'Courier New', Courier, mono;background-color:#eeeeee;">procedure TForm1.MyOpenDialog1Show(Sender: TObject); <br/>begin <br/>   //标识为 1004 的控件为第二个静态控件，用来显示选择的文件全名 <br/>   //此事件一般用来初始化模版上的控件内容和状态 <br/>   SetDlgItemText(MyOpenDialog1.Handle, 1004, '初始化...'); <br/>end;</div> <p>MyOpenDialog1 的 On_SelectionChange 事件代码如下：</p> <div style="border-right:#cccccc 1px solid;border-top:#cccccc 1px solid;font-size:9pt;border-left:#cccccc 1px solid;border-bottom:#cccccc 1px solid;font-family:'Courier New', Courier, mono;background-color:#eeeeee;">procedure TForm1.MyOpenDialog1SelectionChange(Sender: TObject); <br/>begin <br/>   //在第二个静态控件上显示选择的文件全名 <br/>   SetDlgItemText(MyOpenDialog1.Handle, 1004, PChar(MyOpenDialog1.FileName)); <br/>end;</div> <p>MyOpenDialog1 的 On_Command 事件代码如下：</p> <div style="border-right:#cccccc 1px solid;border-top:#cccccc 1px solid;font-size:9pt;border-left:#cccccc 1px solid;border-bottom:#cccccc 1px solid;font-family:'Courier New', Courier, mono;background-color:#eeeeee;">procedure TForm1.MyOpenDialog1Command(ControlID: Word); <br/>var <br/>   hCtrl: HWND; <br/>begin <br/>   if ControlID = 1005 then //模版上的 CheckBox 控件，当状态发生改变时触发此事件 <br/>   begin <br/>      hCtrl := GetDlgItem(MyOpenDialog1.Handle, ControlID); <br/>      if hCtrl &lt;= 0 then Exit; <br/>      if SendMessage(hCtrl, BM_GETCHECK, 0, 0) = BST_CHECKED then <br/>         ShowMessage('You checked me.') <br/>      else <br/>         ShowMessage('You unchecked me.'); <br/>   end; <br/>end;</div> <p>运行后效果见下图：<br/><img alt="o_Result.gif" src="/images/blog_csdn_net/happyjoe/23329/o_Result.gif"/></p> <p><font style="font-weight:bold;font-size:9pt;">小结</font></p> <p>    本例中的自定义部分默认的放在了对话框原有部分的下面，那么如何把对话框中自定义部分放在其它位置呢？其实这个工作不是在代码里做的，而是在第一步创建模版的时候。方法是在模版上放置一个不显示的静态控件（从 MSDN 带的例子来看可以放多个这样的控件），并且这个静态控件的标识必须为 stc32 ，即 0x045F 。通用对话框通过模版上其他控件相对于这个静态控件的位置来定位自定义部分相对于原有部分的位置，模版中位于 stc32 静态控件上方和左边的控件将被安放在通用对话框原有部分的上方和左边，同理，位于 stc32 静态控件下方和右边的控件将被安放在通用对话框原有部分的下方和右边。（ All new controls above and to the left of the stc32 control are positioned the same amount above and to the left of the controls in the default dialog box. New controls below and to the right of the stc32 control are positioned below and to the right of the default controls. In general, each new control is positioned so that it has the same position relative to the default controls as it had to the stc32 control. ）</p> <p>    再说说我个人认为 Delphi 封装通用对话框不够完美的地方，一般来说通用对话框都有一个父窗体(Parent Window)或拥有者(Owner)，拿打开文件对话框来说：OPENFILENAME 结构的 hwndOwner 成员指定其父窗体或拥有者的句柄，但 Delphi 并没有让我们来指定，而是将它指定为 Application.Handle，其他通用对话框也都是这样。</p> <p>MSDN 中有个 C++ 的完整例子，也是自定义打开文件对话框，很短也很容易看懂，它的对话框模版涉及到定位，可在下面位置找到该例子：<br/>User Interface Design and Development<br/>  └User Interface Design &amp; Usability<br/>      └Technicle Articles<br/>          └Using the Common Dialogs Under Windows 95</p> <p>本文参考了 MSDN 以下部分：<br/>User Interface Design and Development<br/>  └Windows Management<br/>      └User Input<br/>          └Common Dialog Box Library<br/>和<br/>User Interface Design and Development<br/>  └Windows Management<br/>      └Windowing<br/>          └Dialog Box</p> <p style="color:#808080;">The end. 作者：Joe Huang 欢迎来 Email 讨论：happyjoe@21cn.com 时间：2004年1月5日 6:01 PM</p>                </div>                    </div>
8578	 程序员，你的逻辑思维有多强（一道推理题测试，不可错过）	测试  random  算法  语言  	983814180	7762	along3000	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p>　　要做一个程序员，逻辑思维能力是关键，写程序也是对该能力的一种锻炼，这里有一个测试题，你可以对自己现在的能力进行评诂。也希望大家回贴谈谈感受。</p><p>　　本题是柏林大学的一次考试题，要求在30分钟内做出，不过只有少于10%的人完成了要求。计分是这样的，共150分，从1到30分钟，每加1分钟减2分,那么30分钟答出就是90分，是及格分；从30分钟以后每加1分钟减1分。我当时用了22分钟，大家也试试，看自己能得多少分。</p><p>  　原题：<font color="#c43c8d">有五位小姐排成一列，所有的小姐姓不同、穿的衣服颜色不同、喝不同的饮料、养不同的宠物、吃不同的水果。<br/>      钱小姐穿红色衣服；翁小姐养了一只狗；陈小姐喝茶；穿绿衣服的站在穿<br/>白衣服的左边；穿绿衣服的小姐喝咖啡；吃西瓜的小姐养鸟；穿黄衣服的小姐吃<br/>梨；站在中间的小姐喝牛奶；赵小姐站在最左边；吃橘子的小姐站在养猫的旁边；<br/>养鱼的小姐旁边的那位吃梨；吃苹果的小姐喝香槟；江小姐吃香蕉；赵小姐站在<br/>穿蓝衣服的小姐旁边；喝开水的小姐站在吃橘子的小姐旁边；请问哪位小姐养蛇？</font></p><p><font color="#c43c8d">        </font><font color="#000000">你可以收到题后，看三遍，然后开始计时做题。</font></p><p>    下面引号中是答案，为了大家不受影响，引号内的答案全是白色，你选中这一块，反色即可看到答案。</p><p><br/>    符加声明：<font color="#ff0066">大家一定要推出全部的答案，并且要没有相当然的部分，这样才能算推出，一定要以这个标准来做题。当然我不是出题老师，标准在你心，是否作弊在你心。</font></p><p>    补记一： 其实这个问题的关键在于方法，现在最好的方法就是xlili和Random的方法，这也是许多人能想到的，不过不同的人思路明晰化程度不同。<br/>    我想说的是难道没有别的方法了，我开始曾想用数组的方法，后来发觉很乱，也是用了以上所说的矩阵方法，希望有人能有别的方法，不一定要是最好的方法。</p><p>    如果你已做完该题，你现在在回想一下，看看你刚才的思路，你会明白自己在大多数情况下思考问题的方式。<br/>    我的初衷就是你关心自己思考问题的方式么？你往往怎么思考问题？而这道题毕竟只是一道题，它真正的来源是爱因斯坦的一道题，被大家改得很烂了。</p><p>    补记二：lonsh的推理比较明晰，不过相对来说jc77的还是直观些，winion 提出的解法已是比较明确的数学算法。希望HaoGeGe能把自己的方法说一下，我也很感兴趣。<br/>    希望大家在以下三点上做文章，回贴尽量以此为中心(因为推理方法大家都谈得不少了)：<br/>        <font color="#ff0033">1、建立一个模型<br/>        2、写出相应的数学算法<br/>        3、程序实现方法(什么语言都可以)</font></p><p> </p><p> </p><p>　　答案如下（双引内）</p><p>　　“<font color="#ffffff">赵小姐穿黄色衣服，喝白开水，吃梨，奍猫<br/>       陈小姐穿蓝色衣服，喝茶，吃橘子，奍鱼<br/>      钱小姐穿红色衣服，喝牛奶，吃西瓜，奍鸟<br/>       江小姐穿绿色衣服，喝咖啡，吃香蕉，奍蛇<br/>      翁小姐穿白色衣服，喝香槟，吃苹果，奍狗</font>”<br/><br/><br/></p>                </div>                    </div>
9270	 用VC＋＋实现自绘按钮控制	button  initialization  microsoft  struct  float  properties  	1009326840	6301	peachblossom	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <strong><font color="#0000ff" size="6">用VC＋＋实现自绘按钮控制<br/><br/></font></strong><big>Microsoft Windows以其丰富一致的</big><font color="#181818"><big>图形用户界面，</big></font><big>简单灵便的操</big><br/><big>作，被广大用户所接受。对话框就是其中一个非常重要的界面形式，</big><br/><big>并且Windows为其应用程序的开发者提供了相当丰富的界面资源，许多</big><br/><big>控制可以方便地加入对话框中。但当我们需要编写一个商业应用，需</big><br/><big>要一个更友好的图形用户界面时，就会发现资源的贫乏。</big><br/><big>Visual C＋＋提供了一个CBitmap Button类在一定程序上缓解了</big><br/><big>增加新资源的要求。但当我们要求在程序中能动态地改变图形时，我</big><br/><big>们就不得不考虑放弃CBitmapButton类，而坐下来自己做一点工作了。</big><br/><big>一个可行的办法就是重载CButton类（即按钮控制）。这样对这块区域</big><br/><big>的大小、位置和ID号都可以通过AppStadio方便地制作。当然这样作最</big><br/><big>大的好处还是在于充分利用C＋＋的特性把绘制控制的代码封装了起来</big><br/><big>，既避免了重复性开发，又使程序变得更简洁，增强了代码的可读性</big><br/><big>。</big><br/><big>现在我们就通过创建一个名叫CColorButton的类来学习这种方法</big><br/><big>。虽然这是一个功能非常简单的类，通过调用成员函数ChangeColor可</big><br/><big>改变其颜色，鼠标点中时则高亮边框表示选中。但利用这种思路我们</big><br/><big>只需添加几个数据成员和重载一个函数就可以方便地实现你所需要的</big><br/><big>功能。</big><br/><big>在创建这个类之前，我们必须先了解WM＿DRAWITEM消息。当按钮</big><br/><big>、组合框、列表框或菜单的某一视觉状况发生变化时，系统就会发送</big><br/><big>一条WM＿DRAWITEM消息给这些控制的拥有者窗口。这个消息的wParam</big><br/><big>指出这个控制的 id 号，而IParam则是一个指向DRAWITEMSTRUCT结构</big><br/><big>的指针，该结构存放有关要绘制的项的信息以及绘制所需的类型。DR</big><br/><big>AWITEMSTRUCT结构具有如下格式。</big><br/><big>typedef struct tagDRAWITEMSTRUCT｛</big><br/><big>UINT CtlType； ／／ 控制类型</big><br/><big>UINT CtlID；／／ 控制的ID号</big><br/><big>UNIT itemID；／／菜单项的索引</big><br/><big>UINT itemAction；／／ 说明需要的绘图操作</big><br/><big>UINT itemState； ／／ 指明绘图后的可见状态</big><br/><big>HWND hwndItem； ／／ 控制的窗口句柄</big><br/><big>HDC hDC； ／／ 相关的设备环境</big><br/><big>RECT rcItem；／／被画控制的边框</big><br/><big>DWORD itemData；／／ 指定与菜单项相联系的应用程序定义的</big><br/><big>32位值</big><br/><big>｝DRAWITEMSTRUCT；</big><br/><big>其中itemAction 和 itemState决定了需要的绘图操作。itemAct</big><br/><big>ion 说明需要的绘图操作，可为下列值中的一个或多个； </big><br/><big>值 含 义</big><br/><big>ODA＿DRAWENTIRE 需要重来全部控制时 </big><br/><big>ODA＿FOCUS 获得或失去输入焦点 </big><br/><big>ODA＿SELECT 选择状态改变</big><br/><big>itemState指明当前绘图动作发生之后，项的可见状态。下面是状</big><br/><big>态标志： </big><br/><big>值 含 义 </big><br/><big>ODS＿CHECKD 只用于菜单中 </big><br/><big>ODS＿DISABLE 该项被屏蔽 </big><br/><big>ODS＿FOCUS 该项具有输入焦点 </big><br/><big>ODS＿GRAYED 只用于菜单中 </big><br/><big>ODS＿SELECT 该项处于被选中状态</big><br/><big>（上） □成都 曾志</big><br/><big>用VC＋＋实现自绘按钮控制</big><br/><big>利用VC＋＋编程会发现，当按钮控制接收到WM－DRMAWITEM消息时</big><br/><big>会调用Cbotton类的DrawItem函数。因此我们要做的就是利用C＋＋的</big><br/><big>多态性通过重载CButton类的Drawitem函数来响应MW－DRAWITEM消息。</big><br/><big>下面我们就实际构造一个CColorButton类。</big><br/><big>class ccolorButton：public CButton</big><br/><big>｛ private：</big><br/><big>COLORREF m－color：</big><br/><big>public：</big><br/><big>CColorButton（）：CButton（），m－color（0）｛｝； ／／构</big><br/><big>造函数</big><br/><big>void ChangeColor（COLORREF color）； ／／改变颜色</big><br/><big>virtual void DrawItem（LPDRAWITEMSTRUCT lpDrawItemStruct</big><br/><big>）；／／重载的函数</big><br/><big>｝；</big><br/><big>／／重载的虚函数</big><br/><big>void CColorButton：：DrawItem（LPDRAWITEMSTRUCT lpDrawIt</big><br/><big>emtruct）</big><br/><big>｛</big><br/><big>CDC dc；</big><br/><big>dc．Attach（lpDrawItemStruct－＞hDC）； ／／得到绘制的设</big><br/><big>备环境CDC</big><br/><big>VERIFY（ lpDrawItemStruct－＞CtlType＝＝ODT－BUTTON）；</big><br/><big>if （lpDrawItemStruct－＞itemAction ＆ ODA－DRAWENTIRE）</big><br/><big>｛</big><br/><big>／／重绘整个控制 </big><br/><big>CBrush brush（m－Color）；</big><br/><big>dc．FillRect（＆（lpDrawItemstruct－＞reItem），＆brush）</big><br/><big>；</big><br/><big>｝ if （（lpDrawItemStruct－＞itemstate ＆ ODS－SELECTED</big><br/><big>） ＆＆</big><br/><big>（lpDrawItemStruct－＞itemAction ＆</big><br/><big>（ODA－SELECT ｜ ODA－DRAWENTIRE））） ｛ ／／选中了本控</big><br/><big>制＝＝＝＞高亮边框</big><br/><big>COLORREF fc＝RGB（255－GetRvalue（m－color）， 255－GetG</big><br/><big>Value（m－color）， 255－GetBValue（m－color））；</big><br/><big>CBrush brush（fc）；</big><br/><big>dc．FrameRect（＆（lpDrawItemStruct－＞rcItem），＆brush</big><br/><big>）；</big><br/><big>｝ if （！（lpDrawItemStruct－＞itemState ＆ ODS－SELECT</big><br/><big>ED） ＆＆</big><br/><big>（lpDrawItemStruct－＞itemAction ＆ ODA－SELECT））｛</big><br/><big>／／控制的选中状态结束＝＝＝＞去掉边框</big><br/><big>CBrush brush（m－color）；</big><br/><big>dc．FrameRect（＆lpDrawItemStruct－＞rcItem，＆brush）；</big><br/><big>｝ dc．Detach（）；</big><br/><big>｝ ／／用于改变颜色的成员函数</big><br/><big>void CColorButton：：ChangeColor（COLORREF color） ｛ CR</big><br/><big>ect rect； </big><br/><big>m－color＝color； </big><br/><big>GetClientRect（＆rect）； </big><br/><big>｝</big><br/><big>m－colorChangeColor（COLORREF color）color，WM－DRAWITEM</big><br/><big>上面代码中数据成员m－color和来保存按钮的颜色。ChangeColo</big><br/><big>r（COLORREF color）函数负责改变按钮颜色值为color，然后通过使</big><br/><big>控制的客户区无效而激发WM－DRAWITEM消息。现在这个按钮控制类就</big><br/><big>算搭好了。下面我们把它加入到对话框中来试验一下（中） </big><br/><big>用VC＋＋实现自绘按钮控制</big><br/><big>1．首先通过AppWizard创建一个单文档的应用。</big><br/><big>2．紧接着启动AppStadio创建一个对话框。添加一个按钮控制，</big><br/><big>并将其ID设置为 IDC－COLORBUTTON。最后一定要记住将push Button </big><br/><big>Properties对话框中的Owner Draw检查框置上检查标志。</big><br/><big>3．在AppStadio内运行ClassWizzand来产生CTestDialog类。然</big><br/><big>后在CTestdialog类中加入数据成员，在CTestDialog类说明加入如下</big><br/><big>的private型数据成员：</big><br/><big>private：</big><br/><big>ccolorButton m－ColorButton；</big><br/><big>4．现在剩下的问题是到底要怎样才能使m－ColorButton的DrawI</big><br/><big>tem函数能响应系统发往ID值为IDC－COLORBUTTON的按钮控制的WM－D</big><br/><big>RAWITEM消息。这时就要用到CWnd类的成员函数BOOL CWnd：：Subcla</big><br/><big>ssDlgItem（UINT nID，CWnd ＊pParent）。通过调用这个函数，我们</big><br/><big>可以动态地接管从对话框模板产生的控制，并把它隶属于CWnd对象。</big><br/><big>即用当前的CWnd对象接管发向隶属于pParent的ID号为nID的控制的一</big><br/><big>切消息。对于按钮控制而言，它把当前的按钮控制的位置和大小也清</big><br/><big>成和nID对应的按钮控制一样。于是我们对CTestDialog的源文件进行</big><br/><big>如下的编辑：</big><br/><big>BOOL CTestDialog：：OnInitDialog（）</big><br/><big>｛ CDialog：：OnInitDialog（）；</big><br/><big>／／TODO：Add extra initialization here</big><br/><big>m－ColorButton．SubclassDlgtem（IDC－COLORBUTTON，this）</big><br/><big>；／／接管消息</big><br/><big>m－ColorButton．ChangeColor（RGB（255，0，0）；／／设置为</big><br/><big>红色（可设为任何颜色）</big><br/><big>return（TRUE）；</big><br/><big>｝</big><br/><big>接着通过ClassWizzard在CTestDialog中加入一个响应鼠标点击I</big><br/><big>DC－COLORBUTTON按钮的消息的函数：</big><br/><big>void CTestDialog：：OnColerbutton（）</big><br/><big>｛ ／／TODO：Add your control notification handler code </big><br/><big>here</big><br/><big>int r＝int（（（float）rand（）／RAND－MAX）＊255</big><br/><big>int g＝int（（（float）rand（）／RAND－MAX）＊255</big><br/><big>int b＝int（（（float）rand（）／RAND－MAX）＊255</big><br/><big>m－ColorButton．ChangeColor（RGB（r，g，b））；</big><br/><big>｝</big><br/><big>5．最后，利用ClassWizzard为View加入一个响应WM－LBUTTONDO</big><br/><big>WN的函数，以便激活对话框。请按如下代码对其进行编辑。</big><br/><big>void CTestView：：OnLButtonDown（UINT nflags，POINT po</big><br/><big>int）</big><br/><big>｛ CTestDialog dlg；</big><br/><big>dlg．Domodal（）；</big><br/><big>｝</big><br/><big>6．编译并测试该程序。当鼠标在落视窗中时，按下鼠标左键应能</big><br/><big>弹出一个对话框。在对话框中的红色矩形区域内按下鼠标左键就会使</big><br/><big>其边框变成高亮状态，若在这块区域内释放左键则这城区域就会改变</big><br/><big>颜色且颜色是随机的。</big><br/><big>只需更改DrawItem函数中的重绘代码，就可以得到自己的需要图</big><br/><big>形按钮。 （下） □四川 曾 志</big><br/>                </div>                    </div>
9401	 24点游戏探秘系列1：探秘概述	游戏  算法  	1057539000	1415	ococo	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p><strong>24点游戏探秘系列1：探秘概述 </strong><em>(作者 ococo 2003/1/30)</em></p><p>24点游戏是经典的纸牌益智游戏。我从小玩到大的游戏。</p><p><strong>规则：</strong></p><p>是从扑克中每次取出4张牌。使用加减乘除，第一个能得出24者为赢。赢者把这四张牌收走。先没有了牌者为输。</p><p>昨天晚上考虑如何用电脑求解。写出了算法。</p><p>以下便是用该程序进行的分析：</p><p>四个数，每个数字都是1到13之间。</p><p>允许重复数字时，有答案的局面有：1361 ；没有答案的局面有459 个<br/>不重复时，有答案的局面为607； 没有答案为：108 </p><p>答案最多者，也就是最容易的是：（1 4 8 12 ）。有解117 个。</p>                </div>                    </div>
9446	 [安装]ISO文件解析	linux  windows  扩展  工作  	991019460	1941	hem	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <b></b><h2><b>[安装]ISO文件解析</b></h2><b></b><p></p><a href="http://www.linuxaid.com.cn/training/">www.linuxaid.com.cn/training/</a> <a href="mailto:fjxufeng@linuxaid.com.cn">fjxufeng(风过留枫)</a><br/><br/>〖<a>返回</a>〗〖转发〗<br/><br/><table border="0" cellpadding="0" cellspacing="0" width="96%"><tbody><tr><td><p align="left"><br/>1.什么是ISO文件<br/>    ISO文件：就是以iso为扩展名的文件，它是iso9660文件格式，一种光盘（CD）上的文件系统格式。简单地说，就是数据在数据光盘上的组织形式：<br/>    它的特点是：<br/>  　1）最多只包含8级子目录（可以用RockRidge Extension增大这个限制） <br/>　　2）文件名最大32字符 <br/>　　3）文件大小不超过650M <br/>2.在Linux下如何使用ISO文件<br/>    通常，Linux系统的内核(Kernel）是支持iso9660文件格式的，如果不支持你需重新编译内核增加对其的支持。<br/>    你只需简单使用以下命令就可以从/path目录中读到它的内容了：<br/>　　mount -t iso9660 -o loop xxx.iso /path <br/>3.如果将其刻成光盘<br/>    使用Windows下的光盘刻录软件，它能够直接完成这个工作。<br/>4.在Linux系统中如何制作ISO文件： <br/>　　在Linux系统中，我们可以通过拷贝命令，将光驱上的内容拷贝到一个ISO文件中，如：<br/>    cp /dev/cdrom xxx.iso </p></td></tr></tbody></table>                </div>                    </div>
9728	 如何动态改变Frame的大小？	javascript  button  浏览器  function  input  html  	988745100	1917	51JS	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <table border="0" cellpadding="8" width="100%"><tbody><tr><td bgcolor="#f7f7f7">简介：我想大家应该见过有些网站如Msdn.microsoft.com内一些分帧的页面在按下页面的某个按钮后，页面中的某个帧就会隐藏了，其实这种效果实现起来挺简单的，现在我们就来看看如何用Javascript来访问和修改Frame对象。</td></tr><tr><td><b>1.在开始前我先讲一下Frame的结构与语法:</b> //下面是一个用frame页面的帧的代码<br/><table bgcolor="#dddddd" border="0" cellpadding="7" cellspacing="0" width="100%"><tbody><tr><td>&lt;html&gt; <img alt="frame.gif" height="280" src="http://www.51js.com/tips/temp/frame.gif" width="255"/><br/>&lt;head&gt;<br/>&lt;title&gt;Untitled Document&lt;/title&gt;<br/>&lt;meta http-equiv="Content-Type" content="text/html; charset=gb2312"&gt;<br/>&lt;/head&gt;<br/>&lt;frameset rows="117,498"&gt; <font color="#666666">//如图这代表黄色框的分帧结构为上下分[rows表示上下 cols表示左右] 上为117下为498 包含top.htm与包含left.htm与main.htm的红色框的对象这两个属于同一级对象 </font><br/>&lt;frame src="top.htm"&gt;<br/>&lt;frameset id=frame_bottom cols="200,*"&gt; <font color="#666666">//这表示的是红色框内的分帧结构为左右左是200,右是除了左帧占据200后的所有空间，在这里我给了这个frameset一个id:frame_bottom这是为了方便后面用Javascript来访问这个对象</font><br/>&lt;frame src="left.htm"&gt;<br/>&lt;frame src="main.htm"&gt;<br/>&lt;/frameset&gt;<br/>&lt;/frameset&gt;<br/>&lt;noframes&gt; <font color="#666666">//这是的用来显示当浏览器不支持frame时显示的页面内容</font><br/>&lt;body bgcolor="#FFFFFF" text="#000000"&gt;<br/>你的浏览器不支持frame<br/>&lt;/body&gt;<br/>&lt;/noframes&gt; <br/>&lt;/html&gt;</td></tr></tbody></table><b><br/>2.动态修改frameset的内容</b> <input name="Button" type="button" value="点这里看看显示的效果"/><br/>看完上面的代码你应该知道定义 frame_bottom 这个frameset对象的结构代码为 cols="200,*" 下面是动态修改的代码<br/><table bgcolor="#dddddd" border="0" cellpadding="7" cellspacing="0" width="100%"><tbody><tr><td>&lt;input type="button" name="Button" value="点这按钮将关闭左边的帧" onClick=reSetFrames()&gt;<br/>&lt;script language="JavaScript"&gt;<br/>function reSetFrames(){ <br/>top.frame_bottom.cols=(top.frame_bottom.cols=="0,*")?"200,*":"0,*"; <font color="#666666">//top代表的是所有frame对象的最高级对象也就是上面定义整体结构的代码，top.frame_bottom 就取得红色框这个对象，然后就修改 top.frame_bottom 对象的cols属性为一个新的值.来达到隐藏帧的效果</font><br/>}<br/>&lt;/script&gt;</td></tr></tbody></table></td></tr></tbody></table>                </div>                    </div>
9904	 VB.NET VS C#.	vb.net  c#  overloading  class  vb  assembly  	1057159140	8052	kld3000	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p>本文譯自 <a href="http://www.mightywords.com/browse/details_bc05.jsp?privateLabel=true&amp;sku=MW8NN0&amp;etailerId=1063">http://www.mightywords.com/browse/details_bc05.jsp?privateLabel=true&amp;sku=MW8NN0&amp;etailerId=1063</a></p><h2><b>Visual Basic.NET 是 Visual Basic--但不是你以前所熟悉的 Visual Basic</b></h2><p>這表示每一個 VB6 的開發者要成為一個熟練的 Visual Basic.NET 將會有一段不算平滑的學習曲線。因為新的語法與觀念，以及 .NET 架構上的 Class 都需要去了解。這引發的一個疑問</p><p><b>”既然我無論如何都需要學一個新語言，哪我為何不學新的 C#”</b></p><p>在回答這個問題之前，讓我先提供 Visual Basic 與 C++ 程式設計師另外一個問題</p><p><b>”C# 是一個全新的語言，既然要全新的 C# 那為何不學 VB.NET”</b></p><p>第一個問題其實潛藏了一個想法，當 VB6 的程式設計師問到”為何我不學習 C# 來取代 VB.NET”時，他實際代表的意義是：</p><p>”我可以用 VB 做很多不錯的程式設計，但 C++ 的程式設計師卻仍然瞧不起我。他們賺更多的錢，他們都說 VB 是玩具語言 -- VB 不如 C++ 的速度與能力。他們一再強調 C++ 可以做到但 VB 做不到的部分。現在，所有的 C++ 程式設計師都被告知 C# 是 .NET 環境中最好的語言，而 C# 也的確非常像 C++ 或 Java。既然我在學 VB.NET 時需要花費很多心力，那為何不將這些努力放在 C# 上，讓我今後可以成為<i><b>真正</b></i>的程式設計師，可以含他們一樣賺更多的錢。”</p><p>在討論真正的主題時，我們需要先釐清以下的觀念：</p><ol><li>VB.NET 是完全與 CLS ( common language spec)相容，也就是說它可以完全發揮 .NET 執行環境的能力。 </li><li>C# 提供少數在 VB.NET 無法辦到的特色，但這些特色對絕大多數的 VB 程式設計師來說是沒有用的。 </li><li>兩個語言都與 CLS 相容，也就是說你在極少數的狀況下需要 C# 的特色，也可以在 VB.NET 專案中利用這些 C# 程式碼。 </li></ol><p>如果你接受這些觀念，則很明顯的 VB 程式設計師應該不再在 C++ 或 C# 的程式設計師的面前感到自卑。</p><h2>VB.NET 與 C# 一樣好，甚至在某些方面更好</h2><p>你應該考慮真正符合經濟效益的語言</p><p>符合經濟效益？</p><p>是的，如果兩個語言如此的相似，那決定的因子應該是經濟效益。</p><h2><b>在評估語言時的經濟效益因子</b></h2><p>當一個專業的軟體開發人員你應該尋找最經濟的軟體開發解決方案。在這個前提下，你應該考慮軟體專案整個開發週期的成本，也就是在你心中應該有以下的考量因素</p><ul><li>學習需要時間且花成本 </li><li>在同一時間使用多種語言需要心智上的位移，讓部分的程式設計師會降低開發效率(困擾多於成本的考量) </li><li>在開發時期撰寫正確的程式碼比在其它任何時期校正程式碼﹔在成本上都比較便宜 </li><li>長遠來說容易讀以及了解的程式碼在除錯與維護的成本上較便宜 </li></ul><p>讓我們就以這幾點來討論</p><h3>學習需要時間且花成本</h3><p>基本上我假定 VB 的程式設計師學 VB.NET，C++ 的程式設計師學 C# 比較快。VB 的程式設計師基本上在 VB.NET 只要注意一些細節上的差異，如整數變成 32 位元，參數傳遞預設是 ByVal 而不再是 ByRef 等等。但我相信 VB6 的程式設計師熟悉 VB.NET 的語法會快過 C# 的語法。</p><h3>在同一時間使用多種語言需要心智上的位移</h3><p>以我個人的經驗我常常在 VB 寫 C++ 程式碼，在 C++ 寫 VB 的程式碼。</p><h3>在開發時期撰寫正確的程式碼比在其它任何時期校正程式碼﹔在成本上都比較便宜</h3><p>哪一個語言可以讓你較容易完成無錯誤的程式碼？哪一個語言在撰寫與編譯時期可以抓出最多的錯誤。你將會發現 VB.NET 和 C# 在這方面是非常相似的。</p><h3>長遠來說容易讀以及了解的程式碼在除錯與維護的成本上較便宜</h3><p>在後面的文章將會更進一步說明此點</p><h1>讓我們開始比較</h1><p>在以下的文章我們將逐項比較 VB.NET 和 C#。需要強調的是這裡做的是兩個語言差異上的比較，而不是表列兩個語言的特色，所以兩個語言共有的特色或不需比較的，在本文中不會出現。</p><h3>資料和變數</h3><p>VB.NET 支援所有的 CLS 標準資料型態，C# 增加支援無正負號的資料型態。下表列出兩個語言的基礎型態以及是否與 CLS 相容</p><table border="1" width="100%"><tbody><tr><td width="33%">VB.NET</td><td width="33%">C#</td><td width="34%">與 CLS 相容</td></tr><tr><td width="33%">Object</td><td width="33%">object</td><td width="34%">Y</td></tr><tr><td width="33%">String</td><td width="33%">string</td><td width="34%">Y</td></tr><tr><td width="33%">　</td><td width="33%">sbyte</td><td width="34%">N</td></tr><tr><td width="33%">Short</td><td width="33%">short</td><td width="34%">Y</td></tr><tr><td width="33%">Integer</td><td width="33%">int</td><td width="34%">Y</td></tr><tr><td width="33%">Long</td><td width="33%">long</td><td width="34%">Y</td></tr><tr><td width="33%">Byte</td><td width="33%">byte</td><td width="34%">Y</td></tr><tr><td width="33%">　</td><td width="33%">ushort</td><td width="34%">N</td></tr><tr><td width="33%">　</td><td width="33%">uint</td><td width="34%">N</td></tr><tr><td width="33%">　</td><td width="33%">ulong</td><td width="34%">N</td></tr><tr><td width="33%">Single</td><td width="33%">float</td><td width="34%">Y</td></tr><tr><td width="33%">Double</td><td width="33%">double</td><td width="34%">Y</td></tr><tr><td width="33%">Boolean</td><td width="33%">bool</td><td width="34%">Y</td></tr><tr><td width="33%">Char</td><td width="33%">char</td><td width="34%">Y</td></tr><tr><td width="33%">Decimal</td><td width="33%">decimal</td><td width="34%">Y</td></tr></tbody></table><p> 第一眼看起來 C# 贏得這一項，但真正重要的是贏得這一項應該考慮與 CLS 相容。</p><p>當你的元件與 CLS 相容時，就可以百分之百保證任何其他與 CLS 相容的語言都可以存取元件的方法、屬性都沒有問題。也保證其他的 CLS 相容語言都可以實做你所定義的介面，繼承你的 Classes。也同時保證其他與 CLS 相容的工具可以使用這個元件。</p><p>換句話說，CLS 相容是 .NET 的基礎。C# 可以使用無符號的變數，但應該在應用程式的內部使用。你應該在定義 structures、方法、和屬性等等會出現在 assembly 的內容時避免使用.</p><p>VB 的程式設計師會希望使用無符號型態是因為需要呼叫 Win32 API，但 .NET 大幅降低了 Win32 API 的重要性，且透過 .NET 的 interop system 會自動 marshalling 有符號與無符號之間的資料。</p><p><b>判決：</b>若不考慮與 CLS 相容，C# 在這個主題上獲勝，反之則 VB.NET 獲勝，因為除了違反 CLS 的相容性外，使用不相容的無符號變數會有潛在資料轉換的錯誤，以及因為增加了複雜性而以長遠來看會提升維護成本。</p><h3>Shift 運算子</h3><p>C# 提供與 C 和 C++ 相似的 left-shift 和 right-shift(&lt;&lt; 和 &gt;&gt;)運算子。對 VB 程式程式設計師來說這是公認少用的需要，因為他們比較專注商業應用程式，但我個人希望微軟將它們加到 VB.NET</p><p><b>判決：</b>C++ 在這種少用的運算子上獲勝</p><h3>Operator Overloading</h3><p>C# 支援 Operator Overloading，讓 +、-、* 等等運算子可以在定義新的資料型態後，重新定義運算子對這些型態的意義。</p><p>Operator Overloading 往往被程式設計師高估了。有一個傾向是一些 C++ 的程式設計師會定義一些 class 使用的 overloaded 運算子，但卻沒有任何意義。你應該在很直觀的情境下使用 overloaded 運算子，否則要開發者去記憶某些運算子的特有意義是強人所難。當然，為複數 overloading "+" 是來做向量加法是一個不錯的例子。</p><p>VB.NET(至少 Beta1)並不支援 Operator Overloading。</p><p>當與 CLS 相容的語言如 VB.NET 嘗試要使用有 overloaded operators 的 Class 時會發生什麼狀況呢？在 VB.NET 這個運算子是不能用的，但你可以利用 overloaded 函數如 op_Addition 或 op_Subtraction 來做同樣的事。</p><p>大部分的 VB 程式設計師都不需要 operator overloading。C# 程式設計師若要建立其他語言使用的 assemblies 也要避免使用 operator overloading，取而代之的是利用簡單易懂的函數。 </p><p><b>判決：</b>C# 贏得這個主題，尤其對於某些在科學領域的程式設計師尤其重要，但這個特點對 VB 程式設計師來說毫不重要</p><h3>變數初始化和 local scoping</h3><p>VB.NET 自動將所有的變數初始化成 0 或 nothing。C# 在你未初始化變數之前不准你用該變數。在大多數的狀況下這不成問題，但因為 VB.NET 只有在建立時初始化變數，所以會有一些微小的狀況。以下列 C# 程式而言</p><font size="2"></font><p></p><font color="#0000ff" size="2">int</font><font size="2"> x;</font><p></p><font color="#0000ff" size="2">for</font><font size="2">(x=1;x&lt;3;x++)</font><p>{</p><p></p><font color="#0000ff" size="2">    int</font><font size="2"> i=0;</font><p>    Console.WriteLine(i);</p><p>    i++;</p><p>}</p><p>會連續出現兩個 0，但若以同樣的 VB.NET</p><font size="2"></font><p></p><font color="#0000ff" size="2">Dim</font><font size="2"> x </font><font color="#0000ff" size="2">As</font><font size="2"> </font><font color="#0000ff" size="2">Integer</font><font size="2"></font><p></p><font color="#0000ff" size="2">For</font><font size="2"> x = 1 </font><font color="#0000ff" size="2">To</font><font size="2"> 2</font><p></p><font color="#0000ff" size="2">    Dim</font><font size="2"> i </font><font color="#0000ff" size="2">As</font><font size="2"> </font><font color="#0000ff" size="2">Integer</font><font size="2"></font><p>    Console.WriteLine(i)</p><p>    i += 1</p><p></p><font color="#0000ff" size="2">Next</font><p>則會出現 0 和 1，當然若你以下列的語法</p><p><font color="#0000ff" size="2">Dim</font><font size="2"> i </font><font color="#0000ff" size="2">As</font><font size="2"> </font><font color="#0000ff" size="2">Integer</font><font size="2"> = 0</font></p><p>會出現兩個 0</p><p><b>判決：</b>C# 小贏</p><h3>型別轉換支援(Conversion Support)</h3><p>VB.NET 不支援從一個結構型別定義自訂型別轉換到另外一個。取而代之的是要以特別命名的方法來完成這個動作。以下的程式碼表列出你可以</p><font size="2"></font><p></p><font color="#0000ff" size="2">public</font><font size="2"> </font><font color="#0000ff" size="2">struct</font><font size="2"> SomeStruct</font><p>{</p><p></p><font color="#0000ff" size="2">    public</font><font size="2"> </font><font color="#0000ff" size="2">int</font><font size="2"> x;</font><p>   <font color="#0000ff"></font></p><font color="#0000ff" size="2">public</font><font size="2"> </font><font color="#0000ff" size="2">static</font><font size="2"> </font><font color="#0000ff" size="2">explicit</font><font size="2"> </font><font color="#0000ff" size="2">operator</font><font size="2"> </font><font color="#0000ff" size="2">string</font><font size="2">(SomeStruct s)</font><p>    {</p><p></p><font color="#008000" size="2">        //故意讓 (string) 的結果不同，做自訂轉換的動作</font><font size="2"></font><p></p><font color="#0000ff" size="2">        return</font><font size="2"> s.x.ToString()+10.ToString();</font><p>    }</p><p></p><font color="#0000ff" size="2">    public</font><font size="2"> </font><font color="#0000ff" size="2">override</font><font size="2"> </font><font color="#0000ff" size="2">string</font><font size="2"> ToString()</font><p>    {</p><p></p><font color="#0000ff" size="2">        return</font><font size="2">((</font><font color="#0000ff" size="2">string</font><font size="2">)</font><font color="#0000ff" size="2">this</font><font size="2">);</font><p>    }</p><p>}</p><p></p><font color="#0000ff" size="2">public</font><font size="2"> </font><font color="#0000ff" size="2">class</font><font size="2"> Class1</font><p>{</p><p></p><font color="#0000ff" size="2">    public</font><font size="2"> </font><font color="#0000ff" size="2">static</font><font size="2"> </font><font color="#0000ff" size="2">int</font><font size="2"> Main(</font><font color="#0000ff" size="2">string</font><font size="2">[] args)</font><p>    {</p><p></p><font color="#0000ff" size="2">        string</font><font size="2"> ResultString;</font><p>        SomeStruct s;</p><p>        s.x=5;</p><p>        ResultString=(</p><font color="#0000ff" size="2">string</font><font size="2">)s;</font><p>        Console.WriteLine(ResultString);</p><p>        Console.WriteLine(s.ToString());</p><p></p><font color="#0000ff" size="2">        return</font><font size="2"> 0;</font><p>    }</p><p>}</p><p>為何仍然要 Override ToString 方法？因為這種自訂型別轉換並不與 CLS 相容，CLS 允許自訂型別轉換，但需要以正確的 ToXXX 或 FromXXX 的格式建立方法，讓不支援 C# 格式的其他語言可以執行轉換。</p><p><b>判決：</b>在不考慮與 CLS 相容下，C# 小贏。我希望微軟會將這項功能加入到 VB.NET</p><h2>函數語法</h2><p>VB.NET 和 C# 在函數呼叫的方法上有許多不同</p><h3>函數回傳值</h3><p>VB.NET 維持原先若函數不提供回傳值便自行回傳 0 或 Nothing(若回傳字串，則等於 Null 字串)。C# 要求每一個可以離開的程式執行路徑一定要有明確的回傳語法。因此 C# 編譯器在你沒有提供需要的回傳值時會警告你。</p><p><b>判決：</b>C# 提供了明顯的好處在函數編譯的第一時間幫忙解決潛在的回傳值錯誤</p><h3>選擇性參數(Optional parameters)</h3><p>C# 不提供函數選擇性參數，但仍可以利用會獲得相同結果的 overloading，所以不算大輸。</p><p><b>判決：</b>VB.NET 提供以一個函數做到多個函數才能做的 overloading 而贏得這一項</p><h3>模組(Modules)和靜態(Static)成員(Members)</h3><p>C# 所有的程式碼都要存放在 Class，VB.NET 持續支援標準模組。定義在標準模組的函數和變數會在 assembly 中以 global 的方式呈現。標準模組是與 CLS 相容的，C# 無法定義這一點。</p><p>C# 和 VB.NET 都在 Class 支援靜態方法、屬性和 fields(在 VB.NET 稱為 <i>Shared</i>)。它們在使用時不需真正建立物件，例如</p><font size="2"></font><p></p><font color="#0000ff" size="2">class</font><font size="2"> AClass</font><p>{</p><p></p><font color="#0000ff" size="2">    public</font><font size="2"> </font><font color="#0000ff" size="2">static</font><font size="2"> </font><font color="#0000ff" size="2">void</font><font size="2"> StaticMethod()</font><p>    {</p><p>        Console.WriteLine("不需要建立物件就可以呼叫");</p><p>    }</p><p>}</p><p>則呼叫 StaticMethod 只需要</p><p><font size="2">AClass.StaticMethod();</font></p><p>在 C# 呼叫靜態方法只能透過 type 名稱，在 VB.NET 則同時可以利用 type 名稱或是物件的 instance 來呼叫，範例如下</p><font size="2"></font><p></p><font color="#0000ff" size="2">Class</font><font size="2"> AClass</font><p></p><font color="#0000ff" size="2">    Public</font><font size="2"> </font><font color="#0000ff" size="2">Shared</font><font size="2"> </font><font color="#0000ff" size="2">Sub</font><font size="2"> ShareMethod()</font><p>        Console.WriteLine("可以不建立物件來呼叫函數")</p><p></p><font color="#0000ff" size="2">    End</font><font size="2"> </font><font color="#0000ff" size="2">Sub</font><font size="2"></font><p></p><font color="#0000ff" size="2">End</font><font size="2"> </font><font color="#0000ff" size="2">Class</font><p>可以透過以下兩種的程式碼使用</p><font size="2"></font><p>AClass.ShareMethod()</p><p></p><font color="#0000ff" size="2">Dim</font><font size="2"> a </font><font color="#0000ff" size="2">As</font><font size="2"> </font><font color="#0000ff" size="2">New</font><font size="2"> AClass()</font><p>a.ShareMethod()</p><p>這變成是哲理性的考量了，C# 提供了紀律：如果你想要建立與物件無關但以函數組成的函式庫(library)，你必須建立 Class 來實際地將函數群組在一起，雖然你從來都不會為該 type 建立物件。由於所有的靜態成員仍需以 type 名稱來存取，會強制要求程式設計師明確知道該成員的共享特色。</p><p>VB.NET 提供了開發人員更大的彈性。你可以為一般功能函數建立傳統的標準模組，它可以在不指定任何 class 或模組名稱下直接使用。你可以存取物件的 instance 的 shared 成員，但這有讓 shared 物件與 instance 物件混淆的危險。</p><p><b>判決：</b>我會為標準模組判  VB.NET 小贏，但仍強調這比較是個人偏見而非令人信服的邏輯判讀。我會在少有狀況下﹔程式設計師在 shared 和非 shared 成員混淆時，判給 C# 要求一定要透過 class 名稱來使用靜態成員的方式小贏。</p><h3>Switch 和 Select Case 語法</h3><p>在 C# 的 switch 語法讓你以某個值或語法跳到一個程式區塊。每一個區塊與一個常數值連結在一起。你可以使用多個常數值與 case 語法建立如下的程式碼</p><font size="2"></font><p></p><font color="#0000ff" size="2">switch</font><font size="2">(i)</font><p>{</p><p></p><font color="#0000ff" size="2">    case</font><font size="2"> 4:</font><p></p><font color="#0000ff" size="2">    case</font><font size="2"> 5:</font><p></p><font color="#0000ff" size="2">        break</font><font size="2">;</font><p></p><font color="#0000ff" size="2">    case</font><font size="2"> 6:</font><p></p><font color="#0000ff" size="2">    case</font><font size="2"> 7:</font><p></p><font color="#0000ff" size="2">        break</font><font size="2">;</font><p></p><font color="#0000ff" size="2">    default</font><font size="2">:</font><p></p><font color="#0000ff" size="2">        break</font><font size="2">;</font><p>}</p><p>VB 則讓你可以組合常數或更複雜的語法，如下</p><font size="2"></font><p></p><font color="#0000ff" size="2">Select</font><font size="2"> </font><font color="#0000ff" size="2">Case</font><font size="2"> i</font><p></p><font color="#0000ff" size="2">    Case</font><font size="2"> 4, 5</font><p></p><font color="#0000ff" size="2">    Case</font><font size="2"> 6 </font><font color="#0000ff" size="2">To</font><font size="2"> 9</font><p></p><font color="#0000ff" size="2">    Case</font><font size="2"> </font><font color="#0000ff" size="2">Else</font><font size="2"></font><p></p><font color="#0000ff" size="2">End</font><font size="2"> </font><font color="#0000ff" size="2">Select</font><p>不只如此，VB.NET 也讓你可以在 Select Case 語法中如同使用常數一般使用變數</p><p><b>判決：</b>VB.NET 在這方面明顯獲勝，雖然 C# 簡單的語法對讓撰寫有效率的程式碼有稍稍的幫助。</p><h2>物件語法</h2><p>以下是在 VB.NET 和 C# 間使用物件上語法相異的討論。這裡沒有做各項的評分，僅提供一個整體的判決。</p><h3>傳值或傳址呼叫</h3><p>所有的 VB.NET 參數都要明確地利用 ByVal 和 ByRef 宣告，C# 的參數都是傳值，除非以 ref 關鍵字宣告。</p><h3>Overloads</h3><p>如果在 C# 宣告兩個相同方法名稱但不同的組成參數就自動是 overloads 的函數方式，VB.NET 需要明確地使用 <i>Overloads</i> 關鍵字。</p><h3>呼叫基礎建構子(Base Constructors)</h3><p>在 C# 要呼叫基礎建構子的語法如下</p><font size="2"></font><p></p><font color="#0000ff" size="2">public</font><font size="2"> AClass():</font><font color="#0000ff" size="2">base</font><font size="2">()</font><p>{</p><p>}</p><p>而 VB.NET 的語法如下</p><font size="2"></font><p></p><font color="#0000ff" size="2">Public</font><font size="2"> </font><font color="#0000ff" size="2">Sub</font><font size="2"> </font><font color="#0000ff" size="2">New</font><font size="2">()</font><p></p><font color="#0000ff" size="2">    MyBase</font><font size="2">.New()</font><p></p><font color="#0000ff" size="2">End</font><font size="2"> </font><font color="#0000ff" size="2">Sub</font><h3>Virtual/Overridable 方法</h3><p>C# 使用 <i>Virtual</i> 關鍵來宣告就算是參照到基礎 Class，但仍是呼叫到正確衍生類別的方法。</p><p>VB.NET 使用 <i>Overridable</i> 關鍵字來宣告 virtual 函數，並需要使用 Overrides 關鍵字來宣告衍生的函數，以 override 基礎 Class 的函數。</p><h3>Abstract/MustInherit 方法</h3><p>C# 用關鍵字 <i>abstract</i> 關鍵字來標示需要藉由衍生 Class 來實做的方法，VB.NET 使用 MustInherit 關鍵字來做同樣的標示(同時使用在 Class 和方法)。</p><h3>Sealed/NoInheritable Classes</h3><p>C# 用關鍵字 Sealed 來標示不可以被繼承的 Classs，VB.NET 以 NotInheritable 關鍵字來做相同的事。</p><h3>其他的屬性</h3><p>C# 使用 <i>internal</i> 關鍵字來定義 class 或成員的 scope 是在 assembly 之內，而 VB.NET 以 <i>Friend</i> 做相同的宣告。</p><h3>Shadowing</h3><p>VB.NET 當你在衍生的 class 宣告了與基礎 class 相同的成員名稱會提出警告，以強迫你 override 或是利用 Shadows 關鍵字(譯者註：Shadows 關鍵字在 VB.NET Beta1 似乎尚未支援)來標示當參照到衍生 Class 時，使用衍生 class 的成員而非基礎 class 的成員，而參照基礎 class 的 instance 時，使用基礎 class 的方法。C# 使用 new 關鍵字來隱藏從基礎 Class 繼承來的方法，並用 <i>override</i> 關鍵字來 override virtual 或 abstract 基礎 class 的方法。</p><h3>介面(Interface)和繼承(Inheritance)</h3><p>讓我們看一下 C# 和 VB.NET 如何實做 class 繼承和介面繼承。在這個範例中我們定義了介面 Iint，以及基礎 Class 稱為 AClass，以及衍生 AClass 的 BClass，並實做 Iint 介面。</p><p>在 C# 程式碼如下</p><font color="#0000ff" size="2"></font><p>namespace</p><font size="2"> ConsoleApplication2</font><p>{</p><p></p><font color="#0000ff" size="2">    using</font><font size="2"> System;</font><p></p><font color="#0000ff" size="2">    interface</font><font size="2"> Iint</font><p>    {</p><p></p><font color="#0000ff" size="2">        int</font><font size="2"> x();</font><p>    }</p><p></p><font color="#0000ff" size="2">    public</font><font size="2"> </font><font color="#0000ff" size="2">class</font><font size="2"> AClass</font><p>    {</p><p></p><font color="#0000ff" size="2">        public</font><font size="2"> </font><font color="#0000ff" size="2">int</font><font size="2"> x()</font><p>        {</p><p>            Console.WriteLine("在基礎 Class 的 x");</p><p></p><font color="#0000ff" size="2">            return</font><font size="2">(0);</font><p>        }</p><p>    }</p><p></p><font color="#0000ff" size="2">    public</font><font size="2"> </font><font color="#0000ff" size="2">class</font><font size="2"> BClass:AClass,Iint</font><p>    {</p><p></p><font color="#0000ff" size="2">        int</font><font size="2"> Iint.x()</font><p>        {</p><p>            Console.WriteLine("在介面上的 x");</p><p></p><font color="#0000ff" size="2">            return</font><font size="2">(0);</font><p>        }</p><p>    }</p><p></p><font color="#0000ff" size="2">    class</font><font size="2"> Class1</font><p>    {</p><p></p><font color="#0000ff" size="2">        static</font><font size="2"> </font><font color="#0000ff" size="2">void</font><font size="2"> Main(</font><font color="#0000ff" size="2">string</font><font size="2">[] args)</font><p>        {</p><p>            BClass c=</p><font color="#0000ff" size="2">new</font><font size="2"> BClass();</font><p>            Iint i=c;</p><p>            c.x();</p><p>            i.x();</p><p>            Console.ReadLine();</p><p>        }</p><p>    }</p><p>}</p><p>C# 不需要你明確地定義哪個函數實做哪個介面，也就是以下的程式碼</p><p><font color="#0000ff" size="2">int</font><font size="2"> Iint.x()</font></p><p>換成</p><p><font color="#0000ff" size="2">new public int</font><font size="2"> x()</font></p><p>則認為這個 x() 函數不僅可以直接存取，也是實做介面的 x() 方法。</p><p>而 VB.NET 的對應語法如下</p><font color="#0000ff" size="2"></font><p>Imports</p><font size="2"> System.Console</font><font color="#0000ff" size="2"></font><p>Interface</p><font size="2"> Iint</font><p></p><font color="#0000ff" size="2">    Function</font><font size="2"> x() </font><font color="#0000ff" size="2">As</font><font size="2"> </font><font color="#0000ff" size="2">Integer</font><p>End</p><font size="2"> </font><font color="#0000ff" size="2">Interface</font><p>Public</p><font size="2"> </font><font color="#0000ff" size="2">Class</font><font size="2"> AClass</font><p></p><font color="#0000ff" size="2">    Function</font><font size="2"> x() </font><font color="#0000ff" size="2">As</font><font size="2"> </font><font color="#0000ff" size="2">Integer</font><font size="2"></font><p>        Console.WriteLine("在基礎 Class 的 x")</p><p></p><font color="#0000ff" size="2">        Return</font><font size="2"> 0</font><p></p><font color="#0000ff" size="2">    End</font><font size="2"> </font><font color="#0000ff" size="2">Function</font><p>End</p><font size="2"> </font><font color="#0000ff" size="2">Class</font><p>Public</p><font size="2"> </font><font color="#0000ff" size="2">Class</font><font size="2"> BClass</font><p></p><font color="#0000ff" size="2">    Inherits</font><font size="2"> AClass</font><p></p><font color="#0000ff" size="2">    Implements</font><font size="2"> Iint</font><p></p><font color="#0000ff" size="2">    Private</font><font size="2"> </font><font color="#0000ff" size="2">Function</font><font size="2"> IintX() </font><font color="#0000ff" size="2">As</font><font size="2"> </font><font color="#0000ff" size="2">Integer</font><font size="2"> </font><font color="#0000ff" size="2">Implements</font><font size="2"> Iint.x</font><p>        Console.WriteLine("在介面上的 x")</p><p></p><font color="#0000ff" size="2">    End</font><font size="2"> </font><font color="#0000ff" size="2">Function</font><p>End</p><font size="2"> </font><font color="#0000ff" size="2">Class</font><p>Module</p><font size="2"> Module1</font><p></p><font color="#0000ff" size="2">    Sub</font><font size="2"> Main()</font><p></p><font color="#0000ff" size="2">        Dim</font><font size="2"> b </font><font color="#0000ff" size="2">As</font><font size="2"> </font><font color="#0000ff" size="2">New</font><font size="2"> BClass()</font><p></p><font color="#0000ff" size="2">        Dim</font><font size="2"> i </font><font color="#0000ff" size="2">As</font><font size="2"> Iint</font><p>        i = b</p><p>        b.x()</p><p>        i.x()</p><p>        Console.ReadLine()</p><p></p><font color="#0000ff" size="2">    End</font><font size="2"> </font><font color="#0000ff" size="2">Sub</font><p>End</p><font size="2"> </font><font color="#0000ff" size="2">Module</font><p>VB.NET 需要使用 Implements 關鍵字來明確定義哪個方法實做哪個介面方法。事實上，你可以一個方法來實做多個不同的介面方法，如果介面定義如下：</p><font color="#0000ff" size="2"></font><p>Interface</p><font size="2"> Iint</font><p></p><font color="#0000ff" size="2">    Function</font><font size="2"> x() </font><font color="#0000ff" size="2">As</font><font size="2"> </font><font color="#0000ff" size="2">Integer</font><font size="2"></font><p></p><font color="#0000ff" size="2">    Function</font><font size="2"> y() </font><font color="#0000ff" size="2">As</font><font size="2"> </font><font color="#0000ff" size="2">Integer</font><p>End</p><font size="2"> </font><font color="#0000ff" size="2">Interface</font><p>你可以一個方法實做這兩個，程式範例如下</p><font size="2"></font><p></p><font color="#0000ff" size="2">Private</font><font size="2"> </font><font color="#0000ff" size="2">Function</font><font size="2"> IintX() </font><font color="#0000ff" size="2">As</font><font size="2"> </font><font color="#0000ff" size="2">Integer</font><font size="2"> </font><font color="#0000ff" size="2">Implements</font><font size="2"> Iint.x, Iint.y</font><p>    Console.WriteLine("在介面上的 x")</p><p></p><font color="#0000ff" size="2">End</font><font size="2"> </font><font color="#0000ff" size="2">Function</font><p>當你有兩個相似的介面並共享許多相同的方法，這個實做方式就很有用。</p><h3>對物件語法的判決</h3><p>程式語法對程式設計師來說是信仰問題，大家都比較喜歡自己熟悉的語法，其實沒啥好評斷的。</p><p>從以上的描述中你也可以發現其實這兩的語言的差異性很小，兩者都有相似的功能。</p><p>但無論如何，我必須在物件語法上判 VB.NET 贏，就以以下繼承語法來看</p><font size="2"></font><p></p><font color="#0000ff" size="2">    public</font><font size="2"> </font><font color="#0000ff" size="2">class</font><font size="2"> BClass:AClass,Iint</font><p>與</p><font color="#0000ff" size="2"></font><p>Public</p><font size="2"> </font><font color="#0000ff" size="2">Class</font><font size="2"> BClass</font><p></p><font color="#0000ff" size="2">    Inherits</font><font size="2"> AClass</font><p></p><font color="#0000ff" size="2">    Implements</font><font size="2"> Iint</font><p>以及以下控制繼承的關鍵字</p><p><i>abstract，sealed，virtual，new</i></p><p>與</p><p><i>MustInherit，NotInheritable</i> 與 <i>Overridable，Overrides</i> 和 <i>Shadows</i></p><p>當一看到程式碼想要了解它在做啥事，特別是剛畢業的新程式設計師要接舊程式時，如欲他迅速上手並解決模糊不清的錯誤，或想增加新功能時，哪一種語法較容易理解？</p><p>Visual Basic.NET</p><p>雖然兩者差不多，但 VB.NET 贏得這一項。</p><h3>事件(Events)</h3><p>在 C# 你必須要完成很多的動作後才能定義事件,第一步你必須要宣告事件所需的 delegate type 如下</p><p><font color="#0000ff" size="2">public</font><font size="2"> </font><font color="#0000ff" size="2">delegate</font><font size="2"> </font><font color="#0000ff" size="2">void</font><font size="2"> ChangedEventHandler(</font><font color="#0000ff" size="2">object</font><font size="2"> sender, EventArgs e);</font></p><p>這定義了事件的 signature(參數和參數型態)。 e 參數是繼承自 EventArgs class 的任意 class 以包含事件參數的各種欄位。</p><p>接著 Class 要定義一個該 delegate 型態的事件變數</p><p><font color="#0000ff" size="2">public</font><font size="2"> </font><font color="#0000ff" size="2">event</font><font size="2"> ChangedEventHandler Changed;</font></p><p>要觸發這個事件，Class 呼叫</p><p><font size="2">Changed(</font><font color="#0000ff" size="2">this</font><font size="2">,TheEventArguments);</font></p><p>要承接這個事件，使用者程式必須要定義一個與 delegate signature 相同的函數</p><font size="2"></font><p></p><font color="#0000ff" size="2">private</font><font size="2"> </font><font color="#0000ff" size="2">void</font><font size="2"> ObjectChanged(</font><font color="#0000ff" size="2">object</font><font size="2"> sender,EventArgs e)</font><p>{</p><p>    Console.WriteLine(e.ToString);</p><p>}</p><p>並且需要連結這個函數與發出事件 delegate 的物件</p><p><font size="2">a.Changed+=</font><font color="#0000ff" size="2">new</font><font size="2"> ChangedEventHandler(ObjectChanged);</font></p><p>譯者註：整個架構如下</p><font color="#0000ff" size="2"></font><p>namespace</p><font size="2"> ConsoleApplication2</font><p>{</p><p></p><font color="#0000ff" size="2">    using</font><font size="2"> System;</font><p></p><font color="#0000ff" size="2">    public</font><font size="2"> </font><font color="#0000ff" size="2">class</font><font size="2"> EvtArg:System.EventArgs</font><p>    {</p><p></p><font color="#0000ff" size="2">        public</font><font size="2"> </font><font color="#0000ff" size="2">string</font><font size="2"> strEvt;</font><p>   <font color="#0000ff">     </font></p><font color="#0000ff" size="2">public</font><font size="2"> EvtArg(</font><font color="#0000ff" size="2">string</font><font size="2"> strIn)</font><p>        {</p><p>            strEvt=strIn;</p><p>        }</p><p>    }</p><p></p><font color="#0000ff" size="2">    public</font><font size="2"> </font><font color="#0000ff" size="2">delegate</font><font size="2"> </font><font color="#0000ff" size="2">void</font><font size="2"> ChangedEventHandler(</font><font color="#0000ff" size="2">object</font><font size="2"> sender, EvtArg e);</font><p></p><font color="#0000ff" size="2">    public</font><font size="2"> </font><font color="#0000ff" size="2">class</font><font size="2"> AClass</font><p>    {</p><p></p><font color="#0000ff" size="2">        public</font><font size="2"> </font><font color="#0000ff" size="2">event</font><font size="2"> ChangedEventHandler Changed;</font><p>   <font color="#0000ff">     </font></p><font color="#0000ff" size="2">public</font><font size="2"> </font><font color="#0000ff" size="2">virtual</font><font size="2"> </font><font color="#0000ff" size="2">int</font><font size="2"> x()</font><p>        {</p><p>            Console.WriteLine("在基礎 Class 的 x 以 Changed 觸發事件");</p><p>            Changed(</p><font color="#0000ff" size="2">this</font><font size="2">,</font><font color="#0000ff" size="2">new</font><font size="2"> EvtArg("事件原因..."));</font><p>   <font color="#0000ff">         </font></p><font color="#0000ff" size="2">return</font><font size="2">(0);</font><p>        }</p><p>    }</p><p></p><font color="#0000ff" size="2">    class</font><font size="2"> EvtHand</font><p>    {</p><p></p><font color="#0000ff" size="2">        public</font><font size="2"> </font><font color="#0000ff" size="2">void</font><font size="2"> ObjectChanged(</font><font color="#0000ff" size="2">object</font><font size="2"> sender,EvtArg e)</font><p>        {</p><p>            Console.WriteLine("ObjectChanged 處理事件:" + e.strEvt);</p><p>        }</p><p>    }</p><p></p><font color="#0000ff" size="2">    class</font><font size="2"> Class1</font><p>    {</p><p></p><font color="#0000ff" size="2">        static</font><font size="2"> </font><font color="#0000ff" size="2">void</font><font size="2"> Main(</font><font color="#0000ff" size="2">string</font><font size="2">[] args)</font><p>        {</p><p>            AClass a =</p><font color="#0000ff" size="2">new</font><font size="2"> AClass();</font><p>            EvtHand h=</p><font color="#0000ff" size="2">new</font><font size="2"> EvtHand();</font><p>            a.Changed+=</p><font color="#0000ff" size="2">new</font><font size="2"> ChangedEventHandler(h.ObjectChanged);</font><p>            a.x();</p><p>            Console.ReadLine();</p><p>        }</p><p>    }</p><p>}</p><p>一剛開始這一定會造成困擾，就算使用一陣後仍不太能夠適應。</p><p>VB.NET 的程式設計師可以用完全相同的方式觸發事件，另外也可以使用與 VB6 相容的傳統方式觸發事件，在 Class 中可以定義事件如下</p><p><font color="#0000ff" size="2">Event</font><font size="2"> Changed()</font> </p><p>你可以使用任何你想定義的事件 signature，一般會用 Sender，EventArgs 的技巧如下</p><p><font color="#0000ff" size="2">Event</font><font size="2"> Changed(</font><font color="#0000ff" size="2">Byval</font><font size="2"> Sender </font><font color="#0000ff" size="2">As</font><font size="2"> </font><font color="#0000ff" size="2">Object</font><font size="2">,</font><font color="#0000ff" size="2">ByVal</font><font size="2"> e </font><font color="#0000ff" size="2">As</font><font size="2"> EventArgs)</font></p><p>觸發事件可以透過 <i>RaiseEvent</i> 關鍵字</p><p><font color="#0000ff" size="2">RaiseEvent</font><font size="2"> Changed()</font></p><p>使用事件的物件可以宣告如下</p><p><font color="#0000ff" size="2">Dim</font><font size="2"> </font><font color="#0000ff" size="2">WithEvents</font><font size="2"> b </font><font color="#0000ff" size="2">As</font><font size="2"> BClass</font></p><p>並透過以下的方式將處理事件的方法和事件連結起來</p><font size="2"></font><p></p><font color="#0000ff" size="2">Sub</font><font size="2"> EventHandle() </font><font color="#0000ff" size="2">Handles</font><font size="2"> b.Changed</font><p></p><font color="#0000ff" size="2">End</font><font size="2"> </font><font color="#0000ff" size="2">Sub</font><p>對於 VB6 來說 event 處理是一項改良，副函數可以從任何物件、任何函數名稱處理事件，並且事實上同一個函數可以處理多種事件。</p><p><b>判決：</b>VB.NET 大勝。VB.NET 可以使用與 C# 一樣複雜的語法，也可以簡單的語法提供動態建立的屬性，以宣告事件的語法提供多種狀況下任何 signature 形式的事件。</p><h3>VB 命令</h3><p>想一下 VB6 與 C++ 的差異，C++ 是一種非常簡練的語言--它的關鍵字非常少。也就是說 C++ 程式設計師要靠大量的函式庫--不管是標準的 C runtime、標準的範本函式庫，或是撰寫 Windows 程式的 ATL 或 MFC class library。比起 VB6 的軟體開發人員而言，C++ 的程式設計師也需要對 Win32 API 有更多的了解。</p><p>VB 在歷史上真正的力量就在於將那些函數、class libraries 包裝成非常豐富的內建函數或關鍵字。</p><p>在 .NET 上，C# 程式設計師可以幾乎使用所有的 .NET framework classes，以及一些 class library 為包含的 Win32 API。VB.NET 當然也可以完全存取這些資源，但它仍然保留了原先內建，強固的關鍵字集合。</p><p>但在你以這個原因為主要考量決定採用 VB.NET 時，可以考慮以下的 C# 程式碼</p><font size="2"></font><p>String s="asdf";</p><p>Microsoft.VisualBasic.Strings.Mid((s,2,2));</p><p>這是什麼，在 C# 呼叫 Visual Basic 的函數？(譯者註：要測試這種做法，C# 要參照 Microsoft.VisualBasic)</p><p>是的，大部分 VB 內建的函數現在 .NET 環境下都屬於 Microsoft.VisualBasic namespace。因為它屬於 .NET framework 的一部份，且與 CLS 完全相容，所以這些功能可以被 C# 或是任何其他的語言使用。</p><p>當然，這並不表示完全相同，VB.NET 並不需要使用完整的 Namespace 和物件名稱來確認使用的方法。同事 VB.NET 可以執行一些聰明的動作，如利用 mid 函數來設定字串中的子字串</p><font size="2"></font><p></p><font color="#0000ff" size="2">Dim</font><font size="2"> s </font><font color="#0000ff" size="2">As</font><font size="2"> </font><font color="#0000ff" size="2">String</font><font size="2"> = "abcdef"</font><p>Console.WriteLine(Mid(s, 2, 2))</p><p>Mid(s, 2, 2) = "xx"</p><p>Console.WriteLine(s)</p><p>VB 程式設計師在以上的程式碼中不會覺得有啥奇怪，但這真是一個令人訝異的動作。因為在 .NET 中字串是永遠不變的(它們不可以被修改)，但 VB.NET 讓整個動作看起來是在私地下建立一個新的字串，並賦予到傳進 mid 函數的字串變數。</p><p><b>判決：</b>VB.NET 贏。從語言的角度看，這是小贏。因為其他的 .NET classes 可以所有在 Microsoft.VisualBasic 中的操作。但從經濟的角度上考量就算不是大贏，也贏得不小。因為 VB 的程式設計師已經熟悉這些 VB.NET 的命令，使用它們可以快速成為 .NET 的開發人員。這是一個短期的好處(因為就算 VB 程式設計師選擇了 C# 最終也會學到 .NET 中對等的功能)，但畢竟它是一個好處。對於 C++ 在 .NET 要選擇何種開發語言，這個優點就毫無意義了(譯者註：因為 C++ 的程式設計師本來也不知道 VB 所提供的命令)。</p><h3>其他不同的語法</h3><p>我在這裡不討論 VB.NET 與 C# 基礎語法上的差異，用大括號"{}"還是 Begin...End，用分號還是換行，以 for(,,) 或 For...Next。這些都是語言特色，沒啥麼好比較的。一但你熟悉了一個語言，要在對應到另外一個語言的特色是很容易的。</p><p><b>判決：</b>完全依個人喜好，在這裡不做判決。</p><h3>效能</h3><p>我不願意在 Beta 版本比較兩個語言的效能，但記住兩點</p><p>1.VB.NET  和 C# 都大量使用了 .NET Framework，它才是兩個語言效能上的主要考量。</p><p>2.兩個語言都建立相同的中介語言(Intermediate Language IL)碼，以相同的 Just-in-time(JIT) 編譯器編譯。</p><p>基於以上兩點你很難說兩者的效能上有何差異</p><p><b>判決：</b>平手</p><h3>Using 或 Imports</h3><p>C# 和 VB.NET 都提供了直接(也可以說是減少撰寫)使用 .NET Framework 架構物件的語法。例如，如果為了除錯你想要輸出一句話到 Visual Studio 視窗上，你可以利用以下的程式碼</p><p><font size="2">System.Diagnostics.Debug.WriteLine("你的除錯碼")</font></p><p>C# 可以撰寫一模一樣的程式碼，只是加個分號。</p><p>在 C# 你可以利用 <i>Using</i> 命令來避免需要以全名來參照 <i>Debug</i> 物件，用法如下</p><p><font color="#0000ff" size="2">using</font><font size="2"> System.Diagnostics;</font></p><p>這讓你可以直接使用 Debug 物件，程式碼如下</p><p><font size="2">Debug.WriteLine("除錯碼");</font></p><p>在 VB.NET 可以用 <i>Imports</i> 做到相同的事</p><p><font color="#0000ff" size="2">Imports</font><font size="2"> System.Diagnostics</font></p><p>第一眼看來這兩者是相同的，但以撰寫 Console 應用程式為例，在 C# 你要存取 Console.WriteLine 函數，需要撰寫如下</p><p><font size="2">Console.WriteLine("你的輸出字串");</font></p><p>在這裡需要注意的是 C# 一定要定義 <i>Console</i> 物件的名稱。Using 語法只提供不用重複撰寫 Namespace，但與 Object 無關。在 VB.NET，你可以利用 Imports 直接提供到物件的簡寫，範例如下</p><p><font color="#0000ff" size="2">Imports</font><font size="2"> System.Console</font></p><p>所以程式碼可以更簡寫成</p><p><font size="2">WriteLine("你的輸出字串")</font></p><p><b>判決：</b>VB.NET 贏。可以直接引用的物件會帶來許多方便，尤其是在列舉一串的控制字元時。</p><h3>Unmanaged Code</h3><p>C# 讓你可以定義一個 unmanaged code 區塊--可以利用指標來存取 unmanaged memory。</p><p>在第一眼看來這似乎是 C# 的主要好處，但以下列理由來說，它並不見得真好</p><p>當下的 benchmarks 顯示 unmanaged code 並未比 managed code 顯著提升效能</p><p>因為 managed code 所提供的好處，強烈建議不要使用 unmanaged code(如減少 memory leak、memory 存取錯誤等等)</p><p>與一般的想法相反的是 C# 直接存取 unmanaged code 的能力並不表示你可以避免掉如 .NET interop 函數對 managed 與 unmanaged 程式碼間資料的 marshal。</p><p>VB.NET 可以完整存取 .NET interop 函數，包含呼叫任何API 函數，並使用所有標準的 marshaling 屬性從 managed memory(包括 COM 的呼叫)來 marshal 資料、物件和結構</p><p>VB.NET 可以使用 unmanaged memory，它可以獲取或釋放一個 unmanaged memory 區塊。它可以來回複製 unmanaged memory。它只是卻少內建的關鍵字，而必須要藉由 .NET interop 方法。</p><p><b>判決：</b>C# 小贏</p><h3>Assembly 組織</h3><p>C# 讓你可以將 assembly 切成多個輸出檔案。這在你需要以多個檔案的方式來散佈應用程式時用到，如透過網路下載。VB.NET 的專案建立一個單一的輸出(DLL 或 EXE)。</p><p>因為部分散佈的方式可以同樣多個 assemblies 的方式散佈，所以很難說這是 C# 主要的好處。可能還會有人強調維護 assemblies 和可執行檔間的一對一對應是比較好維護與散佈的。</p><p><b>判決：</b>C# 贏，但代價多大</p><p>(譯者註：據譯者的測試，這部分 VB.NET 也可以多個編譯過的 mod ，透過一個 manifest 以 al.exe 組成一個執行檔，似乎兩者應該是平手。但不確定是否是 Daniel Appleman 所強調的)</p><h3>分別大小寫(case sensitivity)</h3><p>分別大小寫也是信仰問題。C++ 的程式設計師偶爾會強調變數、方法、指令分別大小寫的重要。VB 的程式設計師則享受的不分大小寫的自由，並讓編譯器來修正他們曾經定義的變數的大小寫差異。</p><p>除了一點以外其實我們可以不討論這的問題， CLS 要求所有公共的名稱是不分大小寫的。這表示 C# 的程式設計師可以定義不同公共的成員 method1 和 Method1，從 C# 的角度來看是不同的，但對其他的 assembly 來說是相同的，這個結果會讓人混淆。所以若 C# 的程式設計師若要考慮與 CLS 相容，就必須小心不要在定義公共元素上以大小寫來區分不同。</p><p><b>判決：</b>VB.NET 贏在與 CLS 相容</p><h3>XML 文件</h3><p>C# 讓你可以內建 XML 格式的說明文件到程式碼中，格式的範例如下</p><font size="2"></font><p></p><font color="#008000" size="2">/// &lt;summary&gt;</font><font size="2"></font><p></p><font color="#008000" size="2">/// 對於 Class1 的描述</font><font size="2"></font><p></p><font color="#008000" size="2">/// &lt;/summary&gt;</font><p>編譯器也可以對於 XML 文件做一些聰明的判斷，例如 <i>seealso</i> 標籤不僅僅讓編譯器建立程式碼元素交互參照，也可以確認被參照的元素是否存在，也就是說你可以有標籤如下</p><p><font color="#008000" size="2">&lt;seealso cref="Class2"&gt;</font></p><p>若在你的程式中沒有找到 Class2，編譯器會警告你。</p><p><b>判決：</b>第一眼看起來 XML 文件似乎是個很好的構想。我很難判斷它是否會因此流行起來，但讓程式碼本身就具備說明能力，且讓編譯器可以不僅判讀文件的正確性，也提醒程式設計師所疏忽的公共物件與方法的文件是一個很吸引人的概念。所以我認為這是 C# 重大的贏面，並請問微軟為何 VB.NET 沒有？</p><h2>語法之外的</h2><p>有一些考量與語言的語法本身無關，但仍是選擇兩個語言時需要考慮的。</p><h3>背景編譯與解析</h3><p>C# 有一個非常聰明的分析器，幫你在編輯程式碼時標註錯誤，如漏寫分號或語法錯誤。但它畢竟不是完整的編譯器，所以無法抓到一些語意上的錯誤，如</p><p><font color="#0000ff" size="2">using</font><font size="2"> System.一些不存在的Namespace;</font></p><p>分析器在沒有編譯器的幫忙下無法方便錯誤而接受，這個錯誤要到編譯時期才會被發現。</p><p>如果你在 VB.NET 輸入相同的程式碼</p><p><font color="#0000ff" size="2">Imports</font><font size="2"> System.一些不存在的Namespace</font></p><p>VB 會立刻標出錯誤所在，並表示它找不到這個 namespace。VB 可以這麼做是因為 VB 的編譯器在你撰寫程式時已經完整地在背景執行。</p><p>問題是：收到即時錯誤有多重要？這又是一定程度的個人偏好。我相信有些程式設計師會先僅僅編寫程式，再在程式 build 時回來檢視錯誤﹔以往我個人用這種方式就已經足夠了。但以我個人的觀點來看，在開發環境提供撰寫程式時立刻錯誤檢查會大幅提升效率，我可以確定在移到下一行之前每一行程式碼都可以編譯，對我來說一開始就寫正確比事後在編譯時期發現錯誤再修改要有效率得多。</p><p>我鄭重地建議你在兩種編輯環境各花一小時來編寫程式，相信一但你熟悉了 VB.NET 的背景編譯，就會感受到沒有它的痛苦。</p><p><b>判決：</b>VB.NET 大贏</p><h3>從 VB6 升級</h3><p>對於將 VB6 的程式碼升級到 VB.NET，我已經強調過 "移植是不聰明的"，可能還不如再 .NET 建立相的程式碼，或是利用 interop system 來與已有的 COM 物件或 DLL 合作。</p><p>但仍有一些元件適合升級程式碼--尤其是希望用到 .NET free threading 特色的商業邏輯元件，或是有 memory leak 問題而希望透過 .NET 的記憶體管理獲得改善的元件。</p><p>我已經強調在大多數狀況下移植是不聰明的，若還要將 VB6 的程式碼轉成 C# 更是愚蠢至極。VB.NET 最少還提供了升級精靈來幫忙處理大部分乏味的苦工。最重要的是 VB  程式碼所使用的 Visual Basic 風格的錯誤處理與 VB.NET 和 C# 徹底不同。但與 C# 不同的是 VB.NET 仍然支援舊的錯誤處理方式，讓你在升級程式碼時可以結合新舊的錯誤處理，而不需要大費周章地重新設計錯誤處理邏輯。</p><p>不要搞錯：以 Exception 為基礎的錯誤處理是遠較 VB 舊格式的錯誤處理機制來得好。但若你需要升級舊有的程式碼，你最好還是升級錯誤處理的方式。</p><p><b>判決：</b>VB.NET 大贏，但只對 VB6</p><h3>聰明的格式化</h3><p>C# 和 VB.NET 都提供某種程式化地自動完成語法--如自動加上結尾的大括號或是 <i>End</i> 區塊語法。也包含某種層度的自動縮排。</p><p>但 VB.NET 的編譯器要遠比 C# 來得聰明。我立刻發現我不再需要注意程式縮排的問題，只要讓 VB.NET 的編輯器去做就可以了，我在任何地方敲上程式碼它都可以立刻以正確的格式縮排，非常酷。</p><p>C# 在括號配對上做得不錯(所以你可以輕易分辨程式區塊)，但從編輯程式的角度上來看，我仍然判定 VB.NET 贏</p><p><b>判決：</b>VB.NET 徹底省掉了格式化程式的麻煩</p><h3>熟悉與學習成本</h3><p>熟悉語法是程式設計師最需要的，也是學新語言最貴的成本。</p><p>明顯地不管是選擇 VB.NET 或 C# 學習 .NET 都比學語法來得重要。事實上，語言是如此的相似，只要你熟悉一種語言，在幾天之內就可以熟悉另一種語言。</p><p>在短期的好處上是使用原來熟悉的語法，只要努力去了解 .NET 的架構即可</p><p><b>判決：</b>VB.NET 給 Visual Basic 程式設計師，C# 給 C++ 和 Java 的程式設計師</p><h2>結論</h2><h3>較重要的考量</h3><p>下表列出明顯的差異，當你在選兩種語言時可以慎重考慮，這些比較長遠地影響開發成本</p><table border="1" width="100%"><tbody><tr><td width="50%">特色</td><td width="50%">贏家</td></tr><tr><td width="50%">背景編譯與分析</td><td width="50%">VB.NET--尤其影響撰寫程式的效率</td></tr><tr><td width="50%">函數回傳值</td><td width="50%">C#--自動偵測沒有回傳值的程式執行路徑</td></tr><tr><td width="50%">從舊有的 VB6 升級</td><td width="50%">VB.NET--要把程式碼升級到 C# 簡直就是把錢丟到水溝</td></tr><tr><td width="50%">XML 文件</td><td width="50%">C#--為何 VB.NET 沒有？</td></tr><tr><td width="50%">Event 語法</td><td width="50%">VB.NET--宣告是事件讓程式更容易瞭解並減低學習曲線</td></tr></tbody></table><h3>次要考量</h3><p>下表列出兩個語言的次要考量，不像前述重要考量上對軟體開發生命週期長遠成本的影響。而比較偏向對先前版本的個人因素考量。</p><table border="1" width="100%"><tbody><tr><td width="50%">特色</td><td width="50%">贏家</td></tr><tr><td width="50%">Modules</td><td width="50%">VB.NET--不需要以 Class 名稱定義公共函數 </td></tr><tr><td width="50%">Static/Shared 成員存取</td><td width="50%">C#--不會混淆 shared 和非 shared 的 class 成員</td></tr><tr><td width="50%">Object Syntax</td><td width="50%">VB.NET--關鍵字更符合長遠維護所需的語意易於了解</td></tr><tr><td width="50%">變數初始化</td><td width="50%">C#--需要在使用之前明確初始化，VB.NET 會將其初始化為 0</td></tr><tr><td width="50%">Shift Operators(&lt;&lt; 和 &gt;&gt;)</td><td width="50%">C#--VB.NET 沒有</td></tr><tr><td width="50%">VB 關鍵字</td><td width="50%">VB.NET--減少 VB6 程式設計師的學習曲線。對於 C++ 的程式設計不重要。</td></tr><tr><td width="50%">熟悉程度</td><td width="50%">VB.NET 對 VB，C# 對 C++ 和 Java</td></tr><tr><td width="50%">Switch/Select Case</td><td width="50%">VB.NET--讓 case 的元素可以常數和變數組合</td></tr><tr><td width="50%">Unmanaged Code</td><td width="50%">C#--VB.NET 要透過 .NET interop 的各種方法存取 unmanaged memory</td></tr><tr><td width="50%">Assembly Organization</td><td width="50%">C#--VB.NET 將每個 Assembly 建成單一的 exe 或 dll</td></tr><tr><td width="50%">程式碼結構化(編輯的結構化)</td><td width="50%">VB.NET--自動格式化，不會有任何縮排的錯誤</td></tr><tr><td width="50%">選擇性參數</td><td width="50%">VB.NET--C# 可以 overloads 做到相同的事情</td></tr></tbody></table><h3>考量是否與 CLS 相容</h3><p>下表列出是否你需要考慮與 CLS 相容的各點</p><table border="1" width="100%"><tbody><tr><td width="33%">特色</td><td width="33%">贏家(如果你考慮與 CLS 相容)</td><td width="34%">贏家(如果你不考慮與 CLS 相容)</td></tr><tr><td width="33%">Unsigned 變數</td><td width="33%">VB.NET -- 減少使用上發生錯誤</td><td width="34%">C#--VB.NET 沒有</td></tr><tr><td width="33%">運算子 Overloading</td><td width="33%">VB.NET -- 減少使用上發生錯誤</td><td width="34%">C#--VB.NET 沒有</td></tr><tr><td width="33%">Custom Conversions</td><td width="33%">VB.NET -- 減少使用上發生錯誤</td><td width="34%">C#--VB.NET 沒有</td></tr><tr><td width="33%">區分大小寫</td><td width="33%">VB.NET -- 減少轉換上發生錯誤</td><td width="34%">完全個人喜好</td></tr></tbody></table><p>　</p><p>　</p>                </div>                    </div>
9975	 图像分割的一些简单实现	图像处理  算法  div  pascal  integer  出版  	1049074260	2085	dmgf	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p align="center" class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;text-align:center;"><b><span style="font-size:15pt;font-family:'隶书';">图像分割中阈值的自动选取的研究及其算法实现</span></b><b><span lang="en-us" style="font-size:15pt;" xml:lang="en-us">&lt;?xml:namespace prefix = o ns = "urn:schemas-microsoft-com:office:office" /&gt;</span></b></p><p><b></b></p><b></b><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><font size="3"><span style="font-family:'宋体';">图像分割是图像处理这门学科中的基础难题，基于阈值的分割则又是图像分割的最基本的难题之一，其难点在于阈值的选取。事实证明，阈值的选择的恰当与否对分割的效果起着决定性的作用。由于阈值选取对图像分割的基础性，本文主要在【</span><span lang="en-us" xml:lang="en-us">1</span><span style="font-family:'宋体';">】、【</span><span lang="en-us" xml:lang="en-us">2</span><span style="font-family:'宋体';">】、【</span><span lang="en-us" xml:lang="en-us">3</span><span style="font-family:'宋体';">】、【</span><span lang="en-us" xml:lang="en-us">4</span><span style="font-family:'宋体';">】等的基础上，对一些当前流行的阈值选取算法做了探讨、实现和比较。多阈值分割虽然能进一步提高图像分割的质量，但由于它只是分割技巧的处理问题，而与单阈值分割并无本质的区别。因此本文并不对多阈值分割进行讨论，而只考虑单阈值分割的情形。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"></font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 39pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us"><font size="3">1．</font><span style="font:7pt 'Times New Roman';">  </span></span><span style="font-family:'宋体';"><font size="3">双峰法</font></span></p><p class="MsoBodyTextIndent" style="margin:0cm 0cm 0pt;"><font size="3"><span style="font-family:'宋体';">双峰法的原理及其简单：它认为图像由前景和背景组成，在灰度直方图上，前后二景都形成高峰，在双峰之间的最低谷处就是图像的阈值所在。根据这一原理，我们给出了它的实现，部分代码如下（</span><span lang="en-us" xml:lang="en-us">Pascal</span><span style="font-family:'宋体';">语言描述，以下同）：</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><font size="3"><span lang="en-us" xml:lang="en-us">//intPeak</span><span style="font-family:'宋体';">、</span><span lang="en-us" xml:lang="en-us">intPeak2</span><span style="font-family:'宋体';">、</span><span lang="en-us" xml:lang="en-us">intValley</span><span style="font-family:'宋体';">：峰值和直方图值</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><font size="3"><span lang="en-us" xml:lang="en-us">//intIndx:</span><span style="font-family:'宋体';">：相应的灰度值</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3">intPeak,intIndx,intPeak2,intIndx2,intValley,intValleyIndx:integer;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><font size="3"><span lang="en-us" xml:lang="en-us">//</span><span style="font-family:'宋体';">初始双峰值</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>    </span>intPeak:=0;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>    </span>intPeak2:=0;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><font size="3"><span lang="en-us" xml:lang="en-us">//</span><span style="font-family:'宋体';">取得第一峰值</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>    </span>for intLoop:=0 to 255 do</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>      </span>if intPeak&lt;=intGrayLevel[intLoop] then</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>      </span>begin</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>        </span>intPeak:=intGrayLevel[intLoop];</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>        </span>intIndx:=intLoop;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>      </span>end;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><font size="3"><span lang="en-us" xml:lang="en-us">//</span><span style="font-family:'宋体';">取得第二峰值</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>    </span>for intLoop:=0 to 255 do</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>    </span>Begin</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>      </span>if (intPeak2&lt;=intGrayLevel[intLoop]) and (intLoop&lt;&gt;intIndx) then</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>      </span>begin</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>        </span>intPeak2:=intGrayLevel[intLoop];</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>      </span><span>  </span>intIndx2:=intLoop;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>      </span>end</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>    </span>end;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><font size="3"><span lang="en-us" xml:lang="en-us">//</span><span style="font-family:'宋体';">取得双峰之间的谷值</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>    </span>intValley:=intSize;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>    </span>if intIndx2&lt;intIndx then</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>      </span>for intLoop:=intIndx2 to intIndx do</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>        </span>if intValley&gt;intGrayLevel[intLoop] then</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>        </span>begin</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>          </span>intValley:=intGrayLevel[intLoop];</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>  </span><span>        </span>intValleyIndx:=intLoop;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>        </span>end;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><font size="3"><span style="font-family:'宋体';">从分割的效果来看，当前后景的对比较为强烈时，分割效果较好；否则基本无效。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 39pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us"><font size="3">2．</font><span style="font:7pt 'Times New Roman';">  </span></span><span style="font-family:'宋体';"><font size="3">迭代法</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span style="font-family:'宋体';"><font size="3">迭代法是基于逼近的思想，其步骤如下：</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 60pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us"><font size="3">1．</font><span style="font:7pt 'Times New Roman';">  </span></span><font size="3"><span style="font-family:'宋体';">求出图象的最大灰度值和最小灰度值，分别记为</span><span lang="en-us" xml:lang="en-us">Z<sub>MAX</sub></span><span style="font-family:'宋体';">和</span><span lang="en-us" xml:lang="en-us">Z<sub>MIN</sub></span><span style="font-family:'宋体';">，令初始阈值</span><span lang="en-us" xml:lang="en-us">T<sub>0</sub>=(Z<sub>MAX</sub>+Z<sub>MIN</sub>)/2</span><span style="font-family:'宋体';">；</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 60pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us"><font size="3">2．</font><span style="font:7pt 'Times New Roman';">  </span></span><font size="3"><span style="font-family:'宋体';">根据阈值</span><span lang="en-us" xml:lang="en-us">TK</span><span style="font-family:'宋体';">将图象分割为前景和背景，分别求出两者的平均灰度值</span><span lang="en-us" xml:lang="en-us">Z<sub>O</sub></span><span style="font-family:'宋体';">和</span><span lang="en-us" xml:lang="en-us">Z<sub>B</sub></span><span style="font-family:'宋体';">；</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 60pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us"><font size="3">3．</font><span style="font:7pt 'Times New Roman';">  </span></span><font size="3"><span style="font-family:'宋体';">求出新阈值</span><span lang="en-us" xml:lang="en-us">T<sub>K+1</sub>=(Z<sub>O</sub>+Z<sub>B</sub>)/2</span><span style="font-family:'宋体';">；</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 60pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us"><font size="3">4．</font><span style="font:7pt 'Times New Roman';">  </span></span><font size="3"><span style="font-family:'宋体';">若</span><span lang="en-us" xml:lang="en-us">T<sub>K</sub>=T<sub>K+1</sub></span><span style="font-family:'宋体';">，则所得即为阈值；否则转</span><span lang="en-us" xml:lang="en-us">2</span><span style="font-family:'宋体';">，迭代计算。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span style="font-family:'宋体';"><font size="3">以下给出迭代求阈值的部分实现：</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><font size="3"><span lang="en-us" xml:lang="en-us">//</span><span style="font-family:'宋体';">阈值初始为</span><span lang="en-us" xml:lang="en-us">0</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3">intThresholdVal:=0;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>  </span><span>    </span>intThresholdVal2:=0;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><font size="3"><span lang="en-us" xml:lang="en-us"><span>  </span>//</span><span style="font-family:'宋体';">总灰度值</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>  </span>intTotalGrayLevel:=0;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>  </span>for intLoop:=0 to 255 do</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>    </span>if intGrayLevel[intLoop]&lt;&gt;0 then</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>      </span>intTotalGrayLevel:=intTotalGrayLevel+intLoop*intGrayLevel[intLoop];</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><font size="3"><span lang="en-us" xml:lang="en-us"><span>  </span>//</span><span style="font-family:'宋体';">求出初始最大灰度值</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>  </span>for intLoop:=0 to 255 do</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>    </span>if intGrayLevel[intLoop]&gt;0 then</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>    </span>begin</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>      </span>intLGrayLevel:=intLoop;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>      </span>intThresholdVal:=intLoop;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>      </span>break;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>    </span>end;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><font size="3"><span lang="en-us" xml:lang="en-us"><span>  </span>//</span><span style="font-family:'宋体';">求出初始最小灰度值和初始阈值</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>  </span>for intLoop:=255 downto 0 do</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>    </span>if intGrayLevel[intLoop]&gt;0 then</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>    </span>begin</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>      </span>intRGrayLevel:=intLoop;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>      </span>intThresholdVal:=(intThresholdVal+intLoop)div 2;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>      </span>break;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>    </span>end;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><font size="3"><span lang="en-us" xml:lang="en-us"><span>  </span>//</span><span style="font-family:'宋体';">迭代求解</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>  </span>while intThresholdVal&lt;&gt;intThresholdVal2 do</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>    </span>begin</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>      </span>intThresholdVal2:=intThresholdVal;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>      </span>intCount:=0;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>      </span>intLGrayLevel:=0;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>      </span>for intLoop:=0 to intThresholdVal do</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>        </span>if intGrayLevel[intLoop]&lt;&gt;0 then</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>        </span>begin</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>          </span>intCount:=intCount+intGrayLevel[intLoop];</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>          </span>intLGrayLevel:=intLGrayLevel+intLoop*intGrayLevel[intLoop];</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>        </span>end;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>      </span>intRGrayLevel:=intTotalGrayLevel-intLGrayLevel;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>      </span>intLGrayLevel:=intLGrayLevel div intCount;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>    </span><span>  </span>intRGrayLevel:=intRGrayLevel div (intSize-intCount);</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>      </span>intThresholdVal:=(intLGrayLevel+intRGrayLevel)div 2;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>    </span>end;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><font size="3"><span style="font-family:'宋体';">迭代所得的阈值分割的图象效果良好。</span></font><font size="3"><span style="font-family:'宋体';">基于迭代的阈值能区分出图像的前景和背景的主要区域所在，但在图像的细微处（如图</span><span lang="en-us" xml:lang="en-us">1</span><span style="font-family:'宋体';">中的浅色线条）还没有很好的区分度。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><font size="3"><span style="font-family:'宋体';">但令人惊讶的是，对某些特定图象，微小数据的变化却会引起分割效果的巨大改变，</span><span style="font-family:'宋体';">两者的数据只是稍有变化，但分割效果却反差极大，个</span></font><span style="font-family:'宋体';"><font size="3">中原因还有待进一步研究。</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 39pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us"><font size="3">3．</font><span style="font:7pt 'Times New Roman';">  </span></span><font size="3"><span style="font-family:'宋体';">大津法（</span><span lang="en-us" xml:lang="en-us">OTSU</span><span style="font-family:'宋体';">法）</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><font size="3"><span style="font-family:'宋体';">大津法由大津于</span><span lang="en-us" xml:lang="en-us">1979</span><span style="font-family:'宋体';">年提出，对图像</span><span lang="en-us" xml:lang="en-us">Image</span><span style="font-family:'宋体';">，记</span><span lang="en-us" xml:lang="en-us">t</span><span style="font-family:'宋体';">为前景与背景的分割阈值，前景点数占图像比例为</span><span lang="en-us" xml:lang="en-us">w0</span><span style="font-family:'宋体';">，</span> <span style="font-family:'宋体';">平均灰度为</span><span lang="en-us" xml:lang="en-us">u0</span><span style="font-family:'宋体';">；背景点数占图像比例为</span><span lang="en-us" xml:lang="en-us">w1</span><span style="font-family:'宋体';">，平均灰度为</span><span lang="en-us" xml:lang="en-us">u1</span><span style="font-family:'宋体';">。图像的总平均灰度为：</span><span lang="en-us" xml:lang="en-us">u=w0*u0+w1*u1</span><span style="font-family:'宋体';">。从最小灰度值到最大灰度值遍历</span><span lang="en-us" xml:lang="en-us">t</span><span style="font-family:'宋体';">，当</span><span lang="en-us" xml:lang="en-us">t</span><span style="font-family:'宋体';">使得值</span><span lang="en-us" xml:lang="en-us">g=w0*(u0-u)<sup>2</sup>+w1*(u1-u)<sup>2 </sup></span><span style="font-family:'宋体';">最大时</span><span lang="en-us" xml:lang="en-us">t</span><span style="font-family:'宋体';">即为分割的最佳阈值。对大津法可作如下理解：该式实际上就是类间方差值，阈值</span><span lang="en-us" xml:lang="en-us">t</span><span style="font-family:'宋体';">分割出的前景和背景两部分构成了整幅图像，而前景取值</span><span lang="en-us" xml:lang="en-us">u0</span><span style="font-family:'宋体';">，概率为</span><span lang="en-us" xml:lang="en-us">w0</span><span style="font-family:'宋体';">，背景取值</span><span lang="en-us" xml:lang="en-us">u1</span><span style="font-family:'宋体';">，概率为</span><span lang="en-us" xml:lang="en-us">w1</span><span style="font-family:'宋体';">，总均值为</span><span lang="en-us" xml:lang="en-us">u</span><span style="font-family:'宋体';">，根据方差的定义即得该式。因方差是灰度分布均匀性的一种度量</span><span lang="en-us" xml:lang="en-us">,</span><span style="font-family:'宋体';">方差值越大</span><span lang="en-us" xml:lang="en-us">,</span><span style="font-family:'宋体';">说明构成图像的两部分差别越大</span><span lang="en-us" xml:lang="en-us">,</span><span style="font-family:'宋体';">当部分目标错分为背景或部分背景错分为目标都会导致两部分差别变小，因此使类间方差最大的分割意味着错分概率最小。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><font size="3"><span style="font-family:'宋体';">直接应用大津法计算量较大，因此我们在实现时采用了等价的公式</span><span lang="en-us" xml:lang="en-us">g=w0*w1*(u0-u1)<sup>2</sup></span><span style="font-family:'宋体';">。部分计算过程如下：</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><font size="3"><span lang="en-us" xml:lang="en-us">//</span><span style="font-family:'宋体';">遍历所有灰度值求</span><span lang="en-us" xml:lang="en-us">Max g</span><span style="font-family:'宋体';">。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3">for intCurrentLevel:=0 to intArrLen do</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>  </span>begin</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>    </span>if intSclGrayLevel[intCurrentLevel]=0 then</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>      </span>continue</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>    </span>else</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>      </span>begin</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><font size="3"><span lang="en-us" xml:lang="en-us"><span>              </span>//</span><span style="font-family:'宋体';">计算当阈值为</span><span lang="en-us" xml:lang="en-us">intCurrentLevel</span><span style="font-family:'宋体';">时的</span><span lang="en-us" xml:lang="en-us">g</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>        </span>intCount:=0;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>        </span>intSumPels:=0;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>        </span>for intLoop:=0 to intCurrentLevel do</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>          </span>begin</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>            </span>intCount:=intCount+intSclGrayLevel[intLoop];</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>            </span>intSumPels:=intSumPels+intSumPelsArr[intLoop];</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>          </span>end;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>        </span>w0:=intCount/intSize;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>        </span>u0:=intSumPels/intCount;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>        </span>w1:=1-w0;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>        </span>if intSize-intCount&lt;&gt;0 then</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>          </span>u1:=(intTotalPels-intSumPels)/(intSize-intCount)</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>        </span>else</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>          </span>u1:=0;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>        </span>RlTempO:=w0*w1*(u0-u1)*(u0-u1);</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>        </span>if RlTempO&gt;RlMaxO then</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>        </span>begin</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>          </span>RlMaxO:=RlTempO;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>          </span>Result:=intCurrentLevel;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>        </span>end;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"><span>      </span>end;</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><font size="3"><span style="font-family:'宋体';">我们在测试中发现：大津法选取出来的阈值非常理想，对各种情况的表现都较为良好。虽然它在很多情况下都不是最佳的分割，但分割质量通常都有一定的保障，可以说是最稳定的分割。</span></font><font size="3"><span style="font-family:'宋体';">由上可知，大津算法是一种较为通用的分割算法。在它的思想的启迪下，人们进一步提出了多种类似的评估阈值的算法，具体可参加【</span><span lang="en-us" xml:lang="en-us">5</span><span style="font-family:'宋体';">】、【</span><span lang="en-us" xml:lang="en-us">6</span><span style="font-family:'宋体';">】等。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 39pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us"><font size="3">4．</font><span style="font:7pt 'Times New Roman';">  </span></span><span style="font-family:'宋体';"><font size="3">灰度拉伸－一种改进的大津法</font></span></p><p class="MsoBodyTextIndent" style="margin:0cm 0cm 0pt;"><font size="3"><span style="font-family:'宋体';">大津法得到了广泛的应用，但有人发现，大津法致命的缺陷是当目标物与背景灰度差不明显时，会出现无法忍受的大块黑色区域，甚至会丢失整幅图像的信息。为了解决这个问题，有人提出了灰度拉伸的增强大津法。这种方法的原理其实就是在大津法的基础上通过增加灰度的级数来增强前后景的灰度差，从而解决问题。灰度增加的方法是用原有的灰度级乘上同一个系数，从而扩大灰度的级数，特别地，当乘上的系数为</span><span lang="en-us" xml:lang="en-us">1</span><span style="font-family:'宋体';">时，这就是大津法的原型，因此，大津法可以看做是这种方法的一个特例。</span></font></p><p class="MsoBodyTextIndent" style="margin:0cm 0cm 0pt;"><font size="3"><span style="font-family:'宋体';">在实现中，我们实现了多种灰度拉伸，发现对不同的图像，当遇上不同的拉伸系数时，分割效果也相差甚远。</span></font></p><p class="MsoBodyTextIndent" style="margin:0cm 0cm 0pt;"><font size="3"><span style="font-family:'宋体';"></span></font><span lang="en-us" xml:lang="en-us"><font size="3">5．</font><span style="font:7pt 'Times New Roman';">  </span></span><font size="3"><span lang="en-us" xml:lang="en-us">Kirsh</span><span style="font-family:'宋体';">算子</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><font size="3"><span style="font-family:'宋体';">在【</span><span lang="en-us" xml:lang="en-us">4</span><span style="font-family:'宋体';">】中提出了基于</span><span lang="en-us" xml:lang="en-us">Kirsh</span><span style="font-family:'宋体';">算子的分割方法，其思想为：对数字图像的每个像素</span><span lang="en-us" xml:lang="en-us">i</span><span style="font-family:'宋体';">，考虑它的八个邻点的灰度值，以其中三个相邻点的加权和减去剩下五个邻点的加权和得到差值，令三个邻点绕该像素点不断移位，取此八个差值的最大值作为</span><span lang="en-us" xml:lang="en-us">Kirsh</span><span style="font-family:'宋体';">算子。即：设</span><span lang="en-us" xml:lang="en-us">Si</span><span style="font-family:'宋体';">为三邻点之和，</span><span lang="en-us" xml:lang="en-us">Ti</span><span style="font-family:'宋体';">为五邻点之和，则</span><span lang="en-us" xml:lang="en-us">Kirsh</span><span style="font-family:'宋体';">算子定义为</span><span lang="en-us" xml:lang="en-us">K(i)=max{1,max</span><span style="font-family:'宋体';">〔</span><span lang="en-us" xml:lang="en-us">5Si-3Ti</span><span style="font-family:'宋体';">〕</span><span lang="en-us" xml:lang="en-us">}</span><span style="font-family:'宋体';">如取阈值</span><span lang="en-us" xml:lang="en-us">THk</span><span style="font-family:'宋体';">，则当</span><span lang="en-us" xml:lang="en-us">K(i)&gt;THk</span><span style="font-family:'宋体';">时，像素</span><span lang="en-us" xml:lang="en-us">i</span><span style="font-family:'宋体';">为阶跃边缘点。此外，【</span><span lang="en-us" xml:lang="en-us">4</span><span style="font-family:'宋体';">】的作者认为：假设图像大小为</span><span lang="en-us" xml:lang="en-us">H</span><span style="font-family:'宋体';">×</span><span lang="en-us" xml:lang="en-us">W</span><span style="font-family:'宋体';">个像素点，其边缘点像素一般不会超过</span><span lang="en-us" xml:lang="en-us">5</span><span style="font-family:'宋体';">×</span><span lang="en-us" xml:lang="en-us">H</span><span style="font-family:'宋体';">个。基于这一假设，该文作者提出：（对一幅图像）用</span><span lang="en-us" xml:lang="en-us">Kirsh</span><span style="font-family:'宋体';">算法，取某一较低的初始阈值</span><span lang="en-us" xml:lang="en-us">THk</span><span style="font-family:'宋体';">（以保证目标和背景间灰度变化很小的图像边缘也能被取出），对于每个像素点</span><span lang="en-us" xml:lang="en-us">i</span><span style="font-family:'宋体';">计算其</span><span lang="en-us" xml:lang="en-us">Kirsh</span><span style="font-family:'宋体';">算子，如果</span><span lang="en-us" xml:lang="en-us">K(i)&gt;THk</span><span style="font-family:'宋体';">，则</span><span lang="en-us" xml:lang="en-us">i</span><span style="font-family:'宋体';">为边缘点</span><span lang="en-us" xml:lang="en-us">,</span><span style="font-family:'宋体';">边缘点数</span><span lang="en-us" xml:lang="en-us">N(</span><span style="font-family:'宋体';">初始值为</span><span lang="en-us" xml:lang="en-us">0)</span><span style="font-family:'宋体';">加</span><span lang="en-us" xml:lang="en-us">1,</span><span style="font-family:'宋体';">一旦边缘点数超过</span><span lang="en-us" xml:lang="en-us">5</span><span style="font-family:'宋体';">×</span><span lang="en-us" xml:lang="en-us">H </span><span style="font-family:'宋体';">，而</span><span lang="en-us" xml:lang="en-us">i</span><span style="font-family:'宋体';">还小于整幅图像的像素数，说明阈值取得太低，致使许多不是边缘点的像素也被取出，因此需提高阈值。如此反复，即可获得分割图像所需的阈值。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><font size="3"><span style="font-family:'宋体';">但在实现中，本文作者发现，【</span><span lang="en-us" xml:lang="en-us">4</span><span style="font-family:'宋体';">】中的叙述颇有值得探讨之处，如在</span><span lang="en-us" xml:lang="en-us">H</span><span style="font-family:'宋体';">×</span><span lang="en-us" xml:lang="en-us">W</span><span style="font-family:'宋体';">图像中，</span><span lang="en-us" xml:lang="en-us">H</span><span style="font-family:'宋体';">和</span><span lang="en-us" xml:lang="en-us">W</span><span style="font-family:'宋体';">之间的关系是完全对称的，两者之间如何抉择？此外，在求</span><span lang="en-us" xml:lang="en-us">Kirsh</span><span style="font-family:'宋体';">算子</span><span lang="en-us" xml:lang="en-us">K(i)=max{1,max</span><span style="font-family:'宋体';">〔</span><span lang="en-us" xml:lang="en-us">5Si-3Ti</span><span style="font-family:'宋体';">〕</span><span lang="en-us" xml:lang="en-us">}</span><span style="font-family:'宋体';">时也颇有疑虑之处，由其求得的结果分割图像效果并不明显。基于对称性和归一化的考虑，笔者把</span><span lang="en-us" xml:lang="en-us">Kirsh</span><span style="font-family:'宋体';">算子改为：</span><span lang="en-us" xml:lang="en-us">K(i)=max{1,max abs(5Si-3Ti) div 15 }</span><span style="font-family:'宋体';">，并根据在实际运行中的效果，对</span><span lang="en-us" xml:lang="en-us">W</span><span style="font-family:'宋体';">和</span><span lang="en-us" xml:lang="en-us">H</span><span style="font-family:'宋体';">的选取为：</span><span lang="en-us" xml:lang="en-us">if W&gt;H then use 5*H else use 5*W</span><span style="font-family:'宋体';">。在实际应用中表明，修改后的分割质量显著提高。但与【</span><span lang="en-us" xml:lang="en-us">4</span><span style="font-family:'宋体';">】文中作者声称的效果及其示例相比，仍有相当的距离，特别是它不能解决前后景对比不强烈时的分割情形。</span></font><font size="3"><span style="font-family:'宋体';">但当前后背景对比十分强烈且集中时，</span><span lang="en-us" xml:lang="en-us">Kirsh</span><span style="font-family:'宋体';">算子法却会有十分突出的表现。</span></font><span style="font-family:'宋体';"><font size="3">参考文献</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 57pt;text-indent:-36pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us"><font size="3">【1】</font><span style="font:7pt 'Times New Roman';">       </span></span><font size="3"><span style="font-family:'宋体';">崔屹，数字图像处理技术与应用，电子工业出版社，</span><span lang="en-us" xml:lang="en-us">1997</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 57pt;text-indent:-36pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us"><font size="3">【2】</font><span style="font:7pt 'Times New Roman';">       </span></span><font size="3"><span style="font-family:'宋体';">付忠良，图像阈值选取方法，计算机应用，</span><span lang="en-us" xml:lang="en-us">2000</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 57pt;text-indent:-36pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us"><font size="3">【3】</font><span style="font:7pt 'Times New Roman';">       </span></span><font size="3"><span style="font-family:'宋体';">吴冰、秦志远，自动确定图像二值化最佳阈值的新方法，绘测学院学报，</span><span lang="en-us" xml:lang="en-us">2000</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 57pt;text-indent:-36pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us"><font size="3">【4】</font><span style="font:7pt 'Times New Roman';">       </span></span><font size="3"><span style="font-family:'宋体';">曹莉华，图像边缘提取中的一种动态阈值获取法，小型微型计算机系统，</span><span lang="en-us" xml:lang="en-us">1997</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 57pt;text-indent:-36pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us"><font size="3">【5】</font><span style="font:7pt 'Times New Roman';">       </span></span><font size="3"><span style="font-family:'宋体';">付忠良，基于图像差距度量的阈值选取方法，计算机研究与发展，</span><span lang="en-us" xml:lang="en-us">2001</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 57pt;text-indent:-36pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us"><font size="3">【6】</font><span style="font:7pt 'Times New Roman';">       </span></span><font size="3"><span style="font-family:'宋体';">付忠良，一些新的图像阈值选取方法，计算机应用，</span><span lang="en-us" xml:lang="en-us">2001</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 57pt;text-indent:-36pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us"><font size="3">【7】</font><span style="font:7pt 'Times New Roman';">       </span></span><font size="3"><span lang="en-us" xml:lang="en-us">Kenneth.R.Castleman</span><span style="font-family:'宋体';">著，朱志刚等译，数字图像处理，电子工业出版社，</span><span lang="en-us" xml:lang="en-us">1998</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" xml:lang="en-us"><font size="3"> </font></span></p>                </div>                    </div>
10084	 利用ASP.NET服务器端自定义控件实现XML文件中还原表单	服务器  asp.net  xml  html  数据结构  编程  	1081179660	1475	shanyou	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p>      最近在公司从事的一项web表单的还原，采用ASP.NET的服务器端自定义控件还原表单，其中涉及到的许多自定义控件的技术要点对于每一个自定义的服务器端控件具有普遍性，现将各个技术要点向各位简要介绍，源代码不能提供（涉及公司利益）。</p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><font size="3"><span style="font-family:'宋体';">使用</span><span lang="en-us" xml:lang="en-us">ASP.NET</span><span style="font-family:'宋体';">服务器端自定义控件从</span><span lang="en-us" xml:lang="en-us">XML</span><span style="font-family:'宋体';">文件中读入表单的信息（表单的各个控件），动态的生成各个控件。涉及几个技术点，</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 39pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us"><span><font size="3">1、</font><span style="font:7pt 'Times New Roman';">  </span></span></span><font size="3"><span style="font-family:'宋体';">读</span><span lang="en-us" xml:lang="en-us">XML</span><span style="font-family:'宋体';">文件</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 39pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us"><span><font size="3">2、</font><span style="font:7pt 'Times New Roman';">  </span></span></span><span style="font-family:'宋体';"><font size="3">复合控件</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 39pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us"><span><font size="3">3、</font><span style="font:7pt 'Times New Roman';">  </span></span></span><span style="font-family:'宋体';"><font size="3">控件数组</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 39pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us"><span><font size="3">4、</font><span style="font:7pt 'Times New Roman';">  </span></span></span><span style="font-family:'宋体';"><font size="3">编程方式控制控件的各种属性。</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 39pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us"><span><font size="3">5、</font><span style="font:7pt 'Times New Roman';">  </span></span></span><font size="3"><span style="font-family:'宋体';">呈现</span><span lang="en-us" xml:lang="en-us">HTML</span><span style="font-family:'宋体';">方法</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span style="font-size:11pt;font-family:'宋体';">服务器端控件是一组逻辑，提供了一个独立于浏览器的用户接口组件，它包含方法和属性，当页面提交时，它在服务器中引发事件，服务器控件可以探测客户设备的类型，然后以所支持的标记语言呈现自己。它支持的标记语言包括<span lang="en-us" xml:lang="en-us">HTML</span>、<span lang="en-us" xml:lang="en-us">XML</span>和<span lang="en-us" xml:lang="en-us">DHTML</span>。</span></p><span style="font-size:11pt;font-family:'宋体';"></span><p style="margin-left:21pt;text-indent:-21pt;"><span lang="en-us" style="font-family:Wingdings;" xml:lang="en-us"><span><font size="3">²</font><span style="font:7pt 'Times New Roman';">       </span></span></span><font size="3">读取<span lang="en-us" xml:lang="en-us">XML，这个我就不说了</span></font></p><p style="margin-left:21pt;text-indent:-21pt;"><span lang="en-us" style="font-family:Wingdings;" xml:lang="en-us"><span><font size="3">²</font><span style="font:7pt 'Times New Roman';">       </span></span></span><span lang="en-us" xml:lang="en-us"><a><span lang="en-us" xml:lang="en-us"><span lang="en-us" xml:lang="en-us"><font face="宋体" size="3">服务器控件的生命周期</font></span></span></a></span><font face="宋体" size="3">：</font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:-21pt;"><span lang="en-us" style="font-family:Wingdings;" xml:lang="en-us"><span><font size="3">²</font><span style="font:7pt 'Times New Roman';">        </span></span></span><font size="3"><span style="font-family:'宋体';">复合控件：使用类的组合（在父控件中结合使用两个或者更多的控件），从而创建复合控件。这个新控件中使用的控件此时都是子控件，但生成的控件包含了所有子控件的功能，新控件呈现了一个用户接口，可以重用已有控件的功能，包括这些控件的属性和事件。父控件可以处理由子控件引发的事件。创建复合控件时需要考虑两件事。为了控件添加到控件集中去，必须重写受保护的</span><span lang="en-us" xml:lang="en-us">CreateChildControls()</span><span style="font-family:'宋体';">方法，该方法从控件继承下来的。在该方法中使用</span><span lang="en-us" xml:lang="en-us">Controls.Add()</span><span style="font-family:'宋体';">方法添加每个子控件到控件树中。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><font size="3"><span style="font-family:'宋体';">为了避免子控件与页面其他控件之间的命名冲突，就必须使用</span><span lang="en-us" xml:lang="en-us">INamingContainer</span><span style="font-family:'宋体';">接口。如果控件有任何类型的数据绑定，或者它是模版控件，或者它需要向子控件发送事件，就需要使用这个接口。（注意：子控件为控件处理所有的呈现，因此不需要重写</span><span lang="en-us" xml:lang="en-us">Render()</span><span style="font-family:'宋体';">方法）。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:-21pt;"><span lang="en-us" style="font-family:Wingdings;" xml:lang="en-us"><span><font size="3">²</font><span style="font:7pt 'Times New Roman';">        </span></span></span><font size="3"><span style="font-family:'宋体';">控件数组：由于在还原表单中，存在大量的同类型的控件，最直接的数据结构就是数组，可是</span><span lang="en-us" xml:lang="en-us">.net framework</span><span style="font-family:'宋体';">不支持控件数组，通过查找资料，找到一种方法模拟控件数组：使用</span><span lang="en-us" xml:lang="en-us"><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemcollectionscollectionbaseclasstopic.asp">CollectionBase</a></span><span style="font-family:'宋体';">类，<span style="color:#333333;">该类提供了一个抽象的强类型集合的基类</span></span><span lang="en-us" style="color:#333333;" xml:lang="en-us">.</span><span style="color:#333333;font-family:'宋体';">我们可以用它来实现我们的控件数组。控件数组中可以包含任意数量的控件。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:-21pt;"><span lang="en-us" style="font-family:Wingdings;" xml:lang="en-us"><span><font size="3">²</font><span style="font:7pt 'Times New Roman';">        </span></span></span><font size="3"><span style="font-family:'宋体';">呈现服务器控件：还原表单中有线条等表单元素没有对应的服务器标准控件，需要通过编程方式控制服务器端控件的呈现；这里使用的关键类是</span><span lang="en-us" xml:lang="en-us">HtmlTextWritter</span><span style="font-family:'宋体';">：不仅可以编写</span><span lang="en-us" xml:lang="en-us">HTML</span><span style="font-family:'宋体';">内容和文本，在把</span><span lang="en-us" xml:lang="en-us">HTML</span><span style="font-family:'宋体';">内容呈现到请求客户端时，它还提供了格式化的能力，包括标记管理、为</span><span lang="en-us" xml:lang="en-us">HTML</span><span style="font-family:'宋体';">内容添加样式等。</span></font></p><p> </p>                </div>                    </div>
10107	 .Net 是未来的趋势, 为什么?	.net  vc++  服务器  数据库  vb  asp.net  	998199960	775	willsound	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p>.Net姗姗来迟了.但是终于我觉得应该谈论一下.NET的未来了.原因很简单,我现在每天都收到几乎50封邮件询问.NET的未来以及与其它技术相比,它有什么样的优势等.所以在这里,我将介绍我个人对这项技术未来发展的看法.<br/><br/>我将从开发者的期望开始并以公司(软件工业企业)的视点结束.<br/><br/>好了!<br/><b><br/>当一个开发者开始开发一个软件的时候,他所要求或需要的是:</b><br/><br/>1.适当的编程语言知识来将商业逻辑写成程序<br/>2.数据库知识来储存他的数据<br/>3.在分布式环境中将商业逻辑连接到数据库的工具<br/>4.懂得如何将应用程序打包<br/>5.如果需要在客户端提供用户透明性则需要开发web解决方案<br/>6.希望得到一些组件来复用他辛勤劳动的结果或其他人高效的解决办法<br/>7.希望能够通过脚本或服务器端的逻辑来完成更新客户端的任务<br/>8.希望能够授权一个团体来重用你的组件以便促进你的业务或工作<br/>9.希望提供一个简洁的用户界面<br/>10.希望避免建立一个你已经作过的web页面的麻烦<br/><br/>还有很多...(我无法包括或讨论所有的方面因为所有这些东西实际上随个人的不同而不同)<br/><br/>但我认为上面提到的10点应该是所有认真的开发者都要考虑的.所以从技术上讲,在.NET到来以前,我们知道的对这些问题的解决办法是:**这里我假设你们希望从列出了所有可能选项的列表中选择一个而且我只会提供这些流行技术的名字.<br/><br/>1.适当的编程语言知识来将商业逻辑写成程序:C,C++,和JAVA.<br/>2.数据库:ORACLE,SOL Server 等.<br/>3.在分布式环境中将商业逻辑连接到数据库组件的工具:CORBA, RMI, DCOM等<br/>4.为分发应用程序打包:安装程序(独立于环境),二进制文件而后最终注册组件<br/>5.通过(显示)提供在线解决方案:HTML, DHTML, CSS, 和XML等.<br/>6.希望使用软件重用机制:Java Beans, COM等<br/>7.客户端更新:Java Script, JScript, Applets 等和服务器端逻辑: Perl, ASP, PHP 等.<br/>8.组件发售:进行物理拷贝和注册组件或完全通过服务器访问<br/>9.简洁的用户界面:VB, VC++, GTK 等<br/>10.可重用web组件:目前工业界还没有任何一个流行的软件被经常使用.<br/><br/>例如我曾为我的开发环境使用:C++, SQL Server, DCOM, HTML, COM, JScript, ASP,服务器和客户端注册实用程序, VC++, GTK+ (在Linux上) 和 XML .所以我所遇到的问题是我需要花费很长的时间来学会这些技术而且几乎每次我都怀疑这些技术能否普及或者能否生存下去.我并不是说所有的开发者都要一下子学会这所有的技术但可以肯定的是,如果你要设计新的和有创意的东西那么你就必须对上面我们讨论的每一点中的至少一项有很好的了解而且做到这一点的人的确是这个工业的领头人.<br/><br/>但是对于.NET,微软在一个软件包里依靠几种拥有明显界线的技术集成了几乎所有的东西.意味着你拥有了所有的东西但不会把它们混淆起来.<br/><br/>因此如果你开始学习.NET,你所需要学习的一切是:<br/><b>主要技术:C#(VB.NET也是一个好的选择)</b><br/><b>ASP.NET<br/>XML</b>.<br/><br/><b>只有三种....................是的!</b><br/><br/>C#可以用来编写客户端更新的脚本,创建商业逻辑,做服务器端编程,编写Windows应用程序,编写控制台程序,做组件设计,而且它可以将XML作为数据,元数据(自描述的数据),商业逻辑和数据库之间的连接工具,但同时你需要ADO.NET的C#实现,更进一步的是如果你要将东西发布到网上,你需要在服务器端安装ASP.NET,如果要创建可重用的web组件,你需要Web Services的概念,就象VC++开发的Windows Services一样,但是没有了物理上的局限.<br/><br/>只有一种语言,我们能将它用在几乎每一个地方.没有更多的混淆...是的!没有了COM/DCOM里浪费系统主存的组件注册过程也没有了系统上的授权允许过程(除了一些特殊情况).<br/><br/>所以从程序员或开发者的视点来看这是一个高度的成功.<br/><br/>现在让我们从公司的角度来想一想(当然!这里我讨论的是小公司,它们以独立项目的方式工作).例如一个公司招聘了四个VC++程序员因为他们的项目将用VC++开发,但是在后来的6个月里他们获得了一个用VB开发的项目.<br/><br/><b>现在会怎么样呢?</b><br/><br/>他们会要求他们的开发者学习VB开始工作,当然另一种方法是解雇他们而招聘一批VB开发者!<br/>所以这是一个主要问题.<br/><br/>但是对于.NET,由于极好的相互兼容性,你不需要学习一种新的.NET语言因为你可以将一种语言的组件引入到另一种.NET语言中来.<br/><br/>因此对于.NET没有必要将你的VB程序员转变成Managed C++ 程序员或把C#程序员转变成JScript.NET程序员.</p>                </div>                    </div>
10128	 用程序删除已注册的COM+应用程序	delphi  library  file  integer  class  object  	1049245080	742	eastliangliang	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p>使用COM接口<br/>1. 找到接口描述文件COMAdmin_TLB.pas<br/>还是用了个笨办法，新建一个ActiveX Library，再新建一个COM Object，随便起个名字吧。保存。<br/>然后选菜单View-&gt;Type Library，在右边Uses页中点右键，选择查看所有类型库，找到COM+1.0 Admin Type Library，保存。OK，在你的保存目录下有了一个COMAdmin_TLB.pas，拷出来，其它的可以删除啦：）<br/>2. 我们来删除一个COM+应用程序<br/>新建一个Delphi工程，保存。添加我们刚才生成的COMAdmin_TLB.pas，别忘了uses啊：）<br/>在COMAdmin_TLB.pas中一共有三个接口，看名字大概能猜出几分<br/>ICOMAdminCatalog     管理COM+目录的接口<br/>ICatalogObject       COM+对象的接口<br/>ICatalogCollection   COM+对象集合的接口</p><p>procedure TForm1.Button1Click(Sender: TObject);<br/>var<br/>  temp:IDispatch;<br/>  i:integer;<br/>CataColl:ICatalogCollection;<br/>  CataObj:ICatalogObject;<br/>  COMADminCata:ICOMAdminCatalog;<br/>begin<br/> <a>file://先</a>创建一个ICOMAdminCatalog的接口指针，用于<br/> self.COMADminCata := CoCOMAdminCatalog.Create;<br/><a>file://取</a>得ICatalogCollection的接口指针，指向的是COM+应用程序的集合，注意参数是<br/><a>file://字</a>符串，Delphi帮助中有这样一段话：有效的集合依赖于你的COMAdmin Library的<br/><a>file://版</a>本，查看微软的文档来找到在你的COMAdmin Library版本中有效的集合<br/> temp := self.COMADminCata.GetCollection('Applications');<br/>   self.CataColl := Iunknown(temp) as ICataLogCollection;<br/> <a>file://下</a>一句不可少，执行了它才真正读到的数据<br/> self.CataColl.Populate;<br/><a>file://来</a>个循环查找并删除，你可以新建一个叫aaa的COM+应用程序来进行测试，循环次<br/><a>file://数</a>为COM+应用程序的个数 –1，因为我们在循环中删了一个COM+应用程序<br/> for i := 0 to self.CataColl.Count - 2 do<br/>   begin<br/>  <a>file://这</a>是取第I个应用程序集合中的对象<br/>     self.CataObj := Iunknown(self.CataColl.Item[i]) as ICatalogObject;<br/>  <a>file://你</a>可以打出来名字看看和你在组件服务中的是否一样<br/>     showmessage(self.CataObj.Name);<br/>  <a>file://如</a>果对象名字是aaa，那么我们要进行删除啦<br/>     if self.CataObj.Name = 'aaa' then<br/>     begin<br/>        self.CataColl.Remove(i);<br/>   <a>file://下</a>一句有点像提交事务，如果你不写，是不会真正删除的<br/>        self.CataColl.SaveChanges;<br/>     end;<br/>   end;<br/>end;</p><p>使用Delphi控件<br/>无意中点了一下帮助，居然发现Delphi有一个类将这些接口封装了（Delphi就是好，呵呵）。好，我们就用这个控件封装的类来实现删除<br/>类定义在CmAdmCtl中，在主窗体中uses一下即可<br/>对应于前面描述的COM接口，Delphi为我们封装了三个类<br/>TCOMAdminCatalog = class(TOleServer)<br/>TCOMAdminCatalogObject = class(TOleServer)<br/>TCOMAdminCatalogCollection = class(TOleServer)<br/>有了前面的描述，第二个程序好写多了<br/>procedure TForm1.Button2Click(Sender: TObject);<br/>var<br/>  CataColl:TCOMAdminCatalogCollection;<br/>  CataObj:TCOMAdminCatalogObject;<br/>  COMADminCata:TCOMAdminCatalog;<br/>  i:integer;<br/>begin<br/>  COMADminCata := TCOMAdminCatalog.Create(self);<br/>  CataColl := COMADminCata.GetCollection('Applications');<br/>  CataColl.Populate;<br/>  for i := 0 to CataColl.Count - 2 do<br/>  begin<br/>    CataObj := CataColl.Get_Item(i);<br/>    showmessage(CataObj.Name);<br/>    if CataObj.Name = 'aaa' then<br/>    begin<br/>      CataColl.Remove(i);<br/>      CataColl.SaveChanges;<br/>    end;<br/>  end;<br/>  COMADminCata.Free;<br/>end;</p><p>还有很多功能，比如导出应用程序，安装应用程序等等操作，函数名写的很清楚，具体可以看Delphi的帮助<br/></p>                </div>                    </div>
10314	 浅谈在PB中创建数据库的方法	数据库  database  sql server  脚本  string  integer  	994138260	525	nthb2001	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <table align="center" width="680"><tbody><tr><td><h2><font color="#0f3ccd">浅谈在PB中创建数据库的方法</font></h2><br/><b>大连理工大学 李宏</b> </td></tr><tr><td align="right">01-6-25 下午 05:41:21<br/><hr size="1" width="660"/></td></tr></tbody></table><br/><table align="center" width="620"><tbody><tr><td class="a14">当我们把用PowerBuilder(以下简称PB)开发的数据库客户端应用程序交给用户后，还需要在用户的服务器端的数据库系统上进行一系列配置工作，如建立业务数据库和建表、视图、主键、索引等数据对象。只有正确配置了数据库服务器上的数据结构，应用程序才能正常运行。通常由经验丰富的数据库管理员，使用数据库系统提供的工具，手工或通过其他辅助工具，来完成数据库端的配置工作。本文以微软的SQL Server 2000为例，介绍用PB开发一个生成业务数据库及各种业务数据对象的程序，用户只要运行这个程序，就可以建立数据库端的数据结构。 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14"><font size="4"><b>程序功能及结构 </b></font></td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">程序的主要功能是建立客户应用程序运行时需要的业务数据库和在新建立的业务数据库上建立数据对象。 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">程序的输入信息通过4个单行编辑文本框获得： </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">●sle_database：新建立的数据库名称； </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">●sle_datafile：新建数据库所用的数据文件； </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">●sle_logfile：新建数据库所用的日志文件； </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">●sle_script：建立数据库中的数据对象所用的脚本文件。 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">完成程序功能的两个按钮分别为：cb_create 用于建立数据库；cb_table用于在新建的数据库中建立表、主键等数据对象。 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">在两个输出窗口中输出结果：dw_database 用于显示新建的数据库名称及数据文件；dw_objects用于显示通过cb_table按钮建立的数据对象。 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14"><font size="4"><b>具体实现 </b></font></td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">考虑到对于一个特定的应用，在系统分析阶段就已经确定数据库所需要的数据空间、日志空间的大小等一些系统物理信息，不会等到程序运行时由用户确定，所以这些信息不需要用户输入。数据库的名称一般来说也是固定的，用户输入的数据库名称（sle_database），可用来检查数据库系统中是否已经有同名的数据库。数据文件和逻辑文件的物理位置和名称，由用户根据服务器上的磁盘空间空闲情况输入（sle_datafile、sle_logfile），程序中给出了初始值，指定的文件位置是SQL Server通常的数据文件存放位置。 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14"><b>1．建立数据对象的脚本文件（sle_script） </b></td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">该文件是普通的文本文件类型，其内容由建立表、主键等数据对象的数据定义语言（DDL）组成，其语法符合数据库系统的规则。例如，脚本test.sql内容为建立两个带有主键的表： </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">create table xz_tj_all </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">( gxjg char(4) not null, </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">nian smallint not null, </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">yue tinyint not null, </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">bz1 tinyint not null, </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">bz2 tinyint not null, </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">a1 integer , </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">a2 integer , </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">a3 integer , </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">primary key (gxjg, nian, yue, bz1, bz2) </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">) </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">create table xz_tj_4_1 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">( gxjg char(4) not null, </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">nian smallint not null, </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">yue tinyint not null, </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">bz1 tinyint not null, </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">bz2 tinyint not null, </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">a1 integer , </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">primary key (gxjg, nian, yue, bz1, bz2) </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">) </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14"><b>2．窗口的Open事件 </b></td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">应用程序只用到一个窗口（w_create_database），在其Open事件中，对两个全局事务对象进行创建，并利用其中的一个事务对象（tr_sql）与系统数据库(Master)进行连接。此时还没有进行业务数据库的创建工作，业务数据库不存在，所以不能在这里进行与新建业务数据库的连接。w_create_database 的Open事件脚本如下： </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//创建与Master系统数据库相连接的事务对象 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">tr_sql = create transaction </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">tr_sql.DBMS =“MSS Microsoft SQL Server 6.x” </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">tr_sql.DataBase = “Master” </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//数据库系统管理员 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">tr_sql.LogPass = “sa” </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//服务器名 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">tr_sql.ServerName = “station4” </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//系统管理员口令 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">tr_sql.LogId = “sa” </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">tr_sql.AutoCommit = False </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">tr_sql.DBParm = “” </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//连接到Master系统数据库 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">connect using tr_sql; </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">if tr_sql.sqlcode &lt;&gt; 0 then </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">MessageBox (“数据库连接错误”,“不能连接到SQL Server数据库Master。请确认SQL Server数据库是否启动。～n～r” ＋ “错误信息：” ＋ tr_sql.sqlerrtext) </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">return </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">end if </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//从系统表sysdatabases中检索数据库信息 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">dw_database.SetTransObject(tr_sql); </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//创建与新建业务数据库相连接的事务对象 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">tr_newBase = create transaction </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">tr_newBase.DBMS =“MSS Microsoft SQL Server 6.x” </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">tr_newBase.LogPass =“sa” </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">tr_newBase.ServerName =“station4” </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">tr_newBase.LogId =“sa” </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">tr_newBase.AutoCommit = False </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">tr_newBase.DBParm =“” </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14"><b>3．cb_create按钮的单击事件 </b></td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">根据业务需要，这里创建的数据文件和日志文件的初始大小为100MB,最大值为200MB，增量为20MB。按钮cb_create根据输入参数构造动态SQL语句，创建数据库。cb_create的clicked事件脚本如下： </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//数据库名 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">string ls_database </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//数据文件路径及文件名 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">string ls_dataFile </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//日志文件路径及文件名 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">string ls_logFile </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//创建数据库的SQL语句 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">string ls_mySql </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//逻辑数据文件名 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">string ls_logicalFileName </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//逻辑日志文件名 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">string ls_logicalLogName </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">SetPointer(Hourglass!) </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//取得用户输入的数据库名称 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">ls_database = trim(sle_database.text) </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//取得数据文件位置和名称 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">ls_dataFile = trim(sle_dataFile.text) </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//取得日志文件位置和名称 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">ls_logFile = trim(sle_logFile.text) </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">ls_logicalFileName = ls_database ＋ “Arch1” </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">ls_logicalLogName = ls_database ＋ “Archlog1” </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">tr_sql.AutoCommit = True </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//建立数据库的语句 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">ls_mySql=“CREATE DATABASE ”＋ls_database＋“ON”＆ </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">＋“( NAME =”＋ls_logicalFileName＋“,”＆ </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">＋“FILENAME = ‘”＋ls_dataFile＋“',”＆ </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">＋“SIZE = 100MB,”＆ </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">＋“MAXSIZE = 200,”＆ </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">＋“FILEGROWTH = 20)”＆ </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">＋“LOG ON ”＆ </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">＋“( NAME = ”＋ls_logicalLogName＋“,”＆ </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">＋“FILENAME = ‘”＋ls_logFile＋“',”＆ </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">＋“SIZE = 100MB,”＆ </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">＋“MAXSIZE = 200,”＆ </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">＋“FILEGROWTH = 20)” </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">EXECUTE IMMEDIATE :ls_mySql Using tr_sql; </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">tr_sql.AutoCommit = False </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//检索出刚刚建立的数据库 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">dw_database.Retrieve(ls_database) </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">cb_table.Enabled = True </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">SetPointer(Arrow!) </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14"><b>4．cb_table按钮的单击事件 </b></td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">按钮cb_table从指定的脚本文件(sle_script.text)中读取内容，构造动态的SQL语句，创建数据对象。为简化程序，对于脚本文件大于32765字节的情况，本文没做处理，读者可用多次读文件等技术自行处理。 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">cb_table的clicked事件脚本如下： </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//创建数据对象前的时间 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">datetime ldt_create </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//数据库名 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">string ls_database </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//创建数据对象的SQL语句 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">string ls_sql </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//存储脚本文件名 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">string ls_fileName </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//打开文件的文件号 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">int li_fileNo </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//文件长度，读取的文件字节数 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">long ll_fileLength, ll_number </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//取得新建的数据库名称 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">ls_database = trim(sle_database.text) </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">if MessageBox(“请确认”,“将要在”＋ls_database＋“数据库中生成表结构？”, Question!,YesNO!,2) = 2 then </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">return </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">end if </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">SetPointer(HourGlass!) </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//为连接业务数据库的事务对象设置数据库值 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">tr_newBase.DataBase = ls_database </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">connect using tr_newBase; </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">if tr_newBase.sqlcode &lt;&gt; 0 then </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">MessageBox (“数据库连接错误”,“不能连接到SQL Server数据库:” ＋ls_database ＋ “ 。～n～r”＋“错误信息：”＋ tr_newBase.sqlerrtext) </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">return </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">end if </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//取得建立数据对象的时间，并从系统表sysobjects中提取建立的数据对象 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">Select distinct getDate() </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">into :ldt_create </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">from sysobjects </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">using tr_newBase; </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//此数据窗口将显示新建事务对象 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">dw_objects.SetTransObject(tr_newBase) </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//从输入中取得脚本文件名 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">ls_fileName = trim(sle_script.text) </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">ll_fileLength = FileLength(ls_fileName) </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//对大于32765字节的文件不做处理 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">if ll_fileLength &gt; 32765 then </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">MessageBox(“”,“脚本文件太大”) </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">DISCONNECT USING tr_newBase; </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">return </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">elseif ll_fileLength &gt; 0 then </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//读取文件内容，执行动态SQL语句 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">li_fileNo = FileOpen(ls_fileName, StreamMode!) </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">ll_number = FileRead(li_fileNo, ls_sql) </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">if ll_number &gt; 0 and ll_number &lt;= 32765 then </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">tr_newBase.AutoCommit = True </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">EXECUTE IMMEDIATE :ls_sql </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">Usingtr_newBase; </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">tr_newBase.AutoCommit = False </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">end if </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">FileClose(li_fileNO) </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">else //不能正确读取文件信息 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">sle_script.setFocus() </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">sle_script.SelectText(1,len(sle_script.text)) </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">MessageBox(“打开脚本文件出错”,“请输入正确的表结构脚本文件名称”) </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">DISCONNECT USING tr_newBase; </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">return </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">end if </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">//检索刚刚建立的数据对象 </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">dw_objects.Retrieve(ldt_create) </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">DISCONNECT USING tr_newBase; </td></tr></tbody></table><table align="center" width="620"><tbody><tr><td class="a14">SetPointer(Arrow!)</td></tr></tbody></table>                </div>                    </div>
10364	 Hailstorm－冰雹是否来了？	微软  soap  互联网  .net  web服务  产品  	1000823340	1206	ccBoy	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p></p><table align="center" border="0" cellpadding="0" cellspacing="0" width="92%"><tbody><tr><td class="title_1" colspan="3" height="40"><div align="center"><p><font face="宋体" size="2">微软的“冰雹”即将在IT行业落下</font></p></div></td></tr><tr><td width="222"><font face="宋体" size="2">09-17 17:50</font></td><td align="right" width="378"><font face="宋体" size="2">陈志红 毛向辉/(Chinabyte) </font></td></tr><tr><td colspan="3" valign="top"><font face="宋体"><font size="2"></font></font><font class="content"></font><p><font face="宋体" size="2">　　　<strong>引言</strong><br/>　　　微软公司于2001年3月19日宣布了一个筹划已久的战略产品Hailstorm（中文含义"冰雹"）。这个以互联网用户认证为核心的计划发布当周就引起了IT市场的很大反响，微软很多竞争对手又一次发动了公共关系攻势，声明微软的行为加深了其不正当的垄断。半年来，随着反垄断官司的好转，微软继续义无反顾地在这个.Net的基础核心产品计划上添砖加瓦。微软公司在10月25日即将发布的Windows XP中部分集成这个计划的早期版本，而更完善的内容也会在稍晚的PDC（微软专业开发人员大会）上公布给第三方的开发人员。 </font></p><p><font face="宋体" size="2">　　　为什么一个看似简单的产品计划会引起业界如此不安？Hailstorm究竟将对消费者和企业产生如何影响？微软能够确保Hailstorm成功吗？中国的软件和互联网产业如何应对这个计划？本文将针对这些问题做出一个全面分析，希望能够帮助业界加强对微软.Net的进一步理解，并能够做到未雨绸缪。 </font></p><p><font face="宋体"><font size="2">　　　<em>注：阅读本文的读者，最好对微软的.Net策略有一定了解（可以参见2001年ChinaByte专栏天地"解读微软互联网新战略"文章）；如果您是技术策略人员，具备有关SOAP, XML等基础知识可以有助于理解其中的技术思想。本文中"Web服务"一词有专门的含义，其英文Web Service在技术领域表示基于SOAP等技术的网络软件应用部件服务。</em></font></font></p></td></tr></tbody></table><img alt="Hailstorm" border="0" hspace="0" src="http://www.chinabyte.com/20010917/hailst1.jpg"/><p>好几页，我还没有学会如何使用这种的转贴功能(haha) </p><p><a href="http://www.chinabyte.com/20010917/1418867.shtml">1</a> <a href="http://www.chinabyte.com/20010917/1418867_1.shtml">2</a> <a href="http://www.chinabyte.com/20010917/1418867_2.shtml">3</a> <a href="http://www.chinabyte.com/20010917/1418867_3.shtml">4</a> <a href="http://www.chinabyte.com/20010917/1418867_4.shtml">5</a> <a href="http://www.chinabyte.com/20010917/1418867_5.shtml">6</a> <a href="http://www.chinabyte.com/20010917/1418867_6.shtml">7</a> <a href="http://www.chinabyte.com/20010917/1418867_7.shtml">8</a> <a href="http://www.chinabyte.com/20010917/1418867_8.shtml">9</a> <a href="http://www.chinabyte.com/20010917/1418867_9.shtml">10</a>  <a href="http://www.chinabyte.com/20010917/1418867_1.shtml">下一页</a></p>                </div>                    </div>
10440	 Delphi插件（Plug-ins）创建、调试与使用应用程序扩展(一)	delphi  扩展  dll  string  图像处理  测试  	997852920	771	jxd_2001	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p>       有没有使用过Adobe Photoshop？如果用过，你就会对插件的概念比较熟悉。<br/>对外行人来说，插件仅仅是从外部提供给应用程序的代码块而已（举个例子来说，在<br/>一个DLL中）。一个插件和一个普通DLL之间的差异在于插件具有扩展父应用程序功能<br/>的能力。例如，Photoshop本身并不具备进行大量的图像处理功能。插件的加入使其<br/>获得了产生诸如模糊、斑点，以及其他所有风格的奇怪效果，而其中任何一项功能都<br/>不是父应用程序自身所具有的。<br/>对于图像处理程序来说这很不错，可是为什么要花偌大的力气去完成支持插件的商业<br/>应用程序呢？假设，我们举个例子，你的应用程序要产生一些报表。你的客户肯定会<br/>一直要求更新或者增加新的报表。你可以使用一个诸如Report Smith的外部报表生成<br/>器，这是个不怎么样的解决方案，需要发布附加的文件，要对用户进行额外的培训，<br/>等等。你也可以使用QuickReport，不过这会使你身处版本控制的噩梦之中--如果每<br/>改变一次字体你就要Rebuild你的应用程序的话。<br/>         然而，只要你把报表做到插件中，你就可以使用它。需要一个新的报表吗？<br/>没问题，只要安装一个DLL，下次应用程序启动时就会看见它了。另外一个例子是处理<br/>来自外部设备（比如条形码扫描器）的数据的应用程序，为了给用户更多的选择，你<br/>不得不支持半打的各种设备。通过将每种设备接口处理例程写成插件，不用对父应用<br/>程序作任何变动就可以获得最大程度的可伸缩性。</p><p>入门</p><p>        在开始写代码之前最重要的事情就是搞清楚你的应用程序到底需要扩展哪<br/>些功能。这是因为插件是通过一个特定的接口与父应用程序交互的，而这个接口将<br/>根据你的需要来定义。在本文中，我们将建立3个插件，以便展示插件与父应用程<br/>序相交互的几种方式。<br/>        我们将把插件制作成DLL。不过，在做这项工作之前，我们得先制作一个外<br/>壳程序来载入和测试它们。图1显示的是加载了第一个插件以后的测试程序。第一个<br/>插件没有完成什么大不了的功能，实际上，它所做的只是返回一个描述自己的字符<br/>串。不过，它证明了很重要的一点--不管有没有插件应用程序都可以正常运行。<br/>如果没有插件，它就不会出现在已安装的插件列表中，但是应用程序仍然可以正常<br/>的行使功能。</p><p>图1：插件测试外壳程序</p><p>        我们的插件外壳程序与普通应用程序之间的唯一不同就在于工程源文件<br/>中出现在uses子句中的Sharemem单元和加载插件文件的代码。任何在自身与子DLL<br/>之间传递字符串参数的应用程序都需要Sharemem单元，它是DelphiMM.dll（Delphi<br/>提供该文件）的接口。要测试这个外壳，需要将DelphiMM.dll文件从Delphi/Bin<br/>目录复制到path环境变量所包含的路径或者应用程序所在目录中。发布最终版本<br/>时也需要同时分发该文件。<br/>        插件通过LoadPlugins过程载入到这个测试外壳中，这个过程在主窗口<br/>的FormCreate事件中调用，见图2。该过程使用FindFirst和FindNext函数在应用<br/>程序所在目录中查找插件文件。找到一个文件以后，就使用图3所示的LoadPlugins过<br/>程将其载入。<br/>{ 在应用程序目录下查找插件文件 }<br/>procedure TfrmMain.LoadPlugins; <br/>var <br/>  sr:     TSearchRec; <br/>  path:   string;<br/>  Found: Integer; <br/>begin<br/>  path := ExtractFilePath(Application.Exename); <br/>   try<br/>    Found := FindFirst(path + cPLUGIN_MASK, 0, sr); <br/>     while Found = 0 do begin<br/>      LoadPlugin(sr); <br/>      Found := FindNext(sr); <br/>     end;<br/>   finally<br/>    FindClose(sr); <br/>   end;<br/>end;</p><p>图 2： 寻找插件<br/>{ 加载指定的插件 DLL. }<br/>procedure TfrmMain.LoadPlugin(sr: TSearchRec); <br/>var <br/>  Description:   string;<br/>  LibHandle:     Integer; <br/>  DescribeProc: TPluginDescribe; <br/>begin<br/>  LibHandle := LoadLibrary(Pchar(sr.Name)); <br/>   if LibHandle &lt;&gt; 0 then<br/>   begin<br/>    DescribeProc := GetProcAddress(LibHandle, <br/>                                   cPLUGIN_DESCRIBE); <br/>     if Assigned(DescribeProc) then<br/>       begin<br/>        DescribeProc(Description); <br/>        memPlugins.Lines.Add(Description); <br/>       end<br/>     else<br/>       begin<br/>        MessageDlg('File "' + sr.Name +<br/>'" is not a valid plug-in.', <br/>          mtInformation, [mbOK], 0); <br/>       end;<br/>   end<br/>   else<br/>    MessageDlg('An error occurred loading the plug-in "' +<br/>      sr.Name + '".', mtError, [mbOK], 0); <br/>end;</p><p>图 3： 载入插件<br/>        LoadPlugin方法展示了插件机制的核心。首先，插件被写成DLL。其次，<br/>通过LoadLibrary API它被动态的加载。一旦DLL被加载，我们就需要一个访问它<br/>所包含的过程和函数的途径。API调用GetProcAddress提供这种机制，它返回一个<br/>指向所需例程的指针。在我们这个简单的演示中，插件仅仅包含一个名为<br/>DescribePlugin的过程，由常数cPLUGIN_DESCRIBE指定（过程名的大小写非常重<br/>要，传递到GetProcAddress的名称必须与包含在DLL中的例程名称完全一致）。如<br/>果在DLL中没有找到请求的例程，GetProcAddree将返回nil，这样就允许使<br/>用Assigned函数测定返回值。<br/>        为了以一种易用的方式存储指向一个函数的指针，有必要为用到的变量<br/>创建一个特定的类型。注意，GetProcAddress的返回值被存储在一个变量中，<br/>DescribeProc，属于TpluginDescribe类型。下面是它的声明：<br/>type <br/>  TPluginDescribe = procedure(var Desc: string); stdcall;<br/>        由于过程存在于DLL内部，它通过标准调用转换编译所有导出例程，<br/>因此需要使用stdcall指示字。这个过程使用一个var参数，当过程返回的时候它包<br/>含插件的描述。<br/>        要调用刚刚获得的过程，只需要使用保存地址的变量作为过程名，后面跟<br/>上任何参数。就我们的例子而言，声明：<br/>DescribeProc(Description)<br/>将会调用在插件中获得的描述过程，并且用描述插件功能的字符串填充Description<br/>变量。</p><p>构造插件</p><p>        我们已经创建好了父应用程序，现在该轮到创建我们希望加载的插件了。<br/>插件文件是一个标准的Delphi DLL，所以我们从Delphi IDE中创建一个新DLL工程，<br/>保存它。由于导出的插件函数将用到字符串参数，所以要在工程的uses子句中把<br/>Sharemen单元放在最前面。图4列出的就是我们这个简单插件的工程源文件。<br/>uses<br/>  Sharemem, SysUtils, Classes, <br/>  main in 'main.pas'; <br/>  <br/>{$E plg.} <br/>  <br/>exports<br/>  DescribePlugin; <br/>  <br/>begin<br/>  <br/>end.</p><p>图 4： 简单插件的工程源文件<br/>        虽然插件是一个DLL文件，但是没有必要一定要给它一个.DLL的扩展名。<br/>实际上，一个原因就足以让我们有理由改变扩展名：当父应用程序寻找要加载的文<br/>件时，新的扩展名可以作为特定的文件掩模。通过使用别的扩展名（我们的例子使<br/>用了*.plg），你可以在一定程度上确信应用程序只会载入相应的文件。编译指示<br/>字$X可以实现这个改变，也可以通过Project Options对话框的Application页来设<br/>置扩展名。<br/>        第一个例子插件的代码是很简单的。图5显示了包含在一个新单元中的代<br/>码。注意，DescribePlugin原型与外壳应用程序中的TpluginDescribe类型相一致，<br/>使用附加的export保留字指定该过程将被导出。被导出的过程名称也将会出现在主<br/>工程源代码的exports段中（在图4中列出）。<br/>unit main; <br/>  <br/>interface<br/>  <br/>  procedure DescribePlugin(var Desc: string);<br/>     export; stdcall;<br/>  <br/>implementation<br/>  <br/>procedure DescribePlugin(var Desc: string);<br/>begin<br/>  Desc := 'Test plugin v1.00'; <br/>end;<br/>  <br/>end.</p><p>图 5： 例子插件的主程序<br/>        在测试这个插件之前，要先把它复制到主应用程序的路径下。最简单的办法就<br/>是在主目录的子目录下创建插件，然后把输出路径设置为主路径（Project Options对<br/>话框的Directories/Conditionals也可以作这个设置）。</p><p>调试</p><p>        现在介绍一下Delphi 3中一个较好的功能：从IDE中调试DLL的能力。在DLL工<br/>程中可以通过Run paramaters对话框指定某程序为宿主应用程序，这就是指向将调<br/>用DLL的应用程序的路径（在我们这个例子中，就是刚刚创建的测试外壳程序）。然后<br/>你就可以在DLL代码中设置断点并且按F9运行它--就像在一个普通应用程序中做的那<br/>样。Delphi会运行指定的宿主程序，并且，通过编译带有调试信息的DLL，把你指引到<br/>DLL代码内的断点处。</p>                </div>                    </div>
10466	 异形窗体的实现	constructor  integer  delphi  function  forms  interface  	1030612380	810	ultrared	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p>一定有很多人看到过一些奇形怪状的窗体，例如一些屏幕精灵。其实实现起来非常容易，做到三点就好啦。下面我使用Delphi做了一个VCL控件（TBmpShape），你只需要指定一幅图片就可以将窗体变成你的图片的形状。</p><p>1。准备一幅位图图片，一定要BMP格式的</p><p>2。将VCL控件放在你的窗体（FORM）上，注意不能是其他的容器，设置PICTURE属性，指定制作好的图片。</p><p>3。设置图片的背景颜色，必须是你的图片的背景颜色准确值</p><p>4。在本窗体的FormCreate事件中写一行代码</p><p>BmpShape1.Apply;</p><p>做到上面四点就可以了，编译运行你的窗体，是不是不一样啊。</p><p>下面是具体的代码，不是太长吧。</p><p>unit BmpShape;<br/>{<br/>2002/08/22  by ultrared<br/>根据BMP文件创建窗口<br/>注意：<br/>1. BMP文件最左上的一个点颜色作为背景色<br/>2. BmpShape控件只能用在TForm容器上<br/>3. BMP文件可以是256色或者24位色<br/>4。大块背景色必须和背景色绝对相等才能获得正常效果<br/>}<br/>interface</p><p>uses<br/> Forms,Windows, Messages, SysUtils, Classes, Controls, ExtCtrls,Graphics;</p><p>type<br/> TBmpShape = class(TImage)<br/> private<br/>  { Private declarations }<br/>  BackColor:TColor;//背景颜色<br/>  FColorDither:boolean;//是否允许背景颜色有一定的抖动<br/>  function GetRegion:HRGN;//前景图片的区域<br/>  procedure setColorDither(cd:Boolean);<br/> protected<br/>  { Protected declarations }<br/> public<br/>  { Public declarations }<br/>  constructor Create(AOwner:TComponent);override;<br/>  procedure Apply;//使用效果<br/> published<br/>  { Published declarations }<br/>  property Dither:Boolean read FColorDither write setColorDither;<br/> end;</p><p>procedure Register;</p><p>implementation</p><p>procedure Register;<br/>begin<br/> RegisterComponents('Samples', [TBmpShape]);<br/>end;</p><p>procedure TBmpShape.setColorDither(cd:Boolean);<br/>begin<br/> if cd&lt;&gt;FColorDither then<br/>  FColorDither:=cd;<br/>end;</p><p>constructor TBmpShape.Create(AOwner:TComponent);<br/>begin<br/> inherited Create(AOwner);<br/> BackColor:=RGB(0,0,0);<br/> FColorDither:=FALSE;<br/>end;</p><p>//核心子程序，获得BMP图片的前景区域<br/>function TBmpShape.GetRegion:HRGN;<br/>var<br/> i,j:integer;<br/> rgn1,rgn2:HRGN;<br/> StartY:integer;<br/> r,g,b,r1,g1,b1:BYTE;<br/> cc:TColor;<br/>begin<br/> if Picture.Bitmap&lt;&gt;nil then<br/> begin<br/>  BackColor:=Picture.Bitmap.Canvas.Pixels[0,0];<br/>  rgn1:=CreateRectRgn(0,0,0,0);<br/>  for i:=0 to Picture.Bitmap.Width-1 do<br/>  begin<br/>   StartY:=-1;<br/>   for j:=0 to Picture.Bitmap.Height-1 do<br/>   begin<br/>    cc:=Picture.Bitmap.Canvas.Pixels[i,j];<br/>    if FColorDither then<br/>    begin<br/>     //允许和背景有一定的色差<br/>     r:=(cc and $FF0000) shr 16;<br/>     g:=(cc and $FF00) shr 8;<br/>     b:=cc and $FF;<br/>     r1:=(BackColor and $FF0000) shr 16;<br/>     g1:=(BackColor and $FF00) shr 8;<br/>     b1:=BackColor and $FF;<br/>     if (abs(r-r1)&lt;10) and (abs(g-g1)&lt;10) and (abs(b-b1)&lt;10) then<br/>     begin<br/>      if (StartY&gt;=0) and (j&gt;=StartY) then<br/>      begin<br/>       rgn2:=CreateRectRgn(i,StartY,i+1,j);<br/>       CombineRgn(rgn1,rgn1,rgn2,RGN_OR);<br/>       StartY:=-1;<br/>      end;<br/>     end<br/>     else<br/>     begin<br/>      if Starty&lt;0 then<br/>       StartY:=j<br/>      else if j=(Picture.Bitmap.Height-1) then //最下面一个点<br/>      begin<br/>       rgn2:=CreateRectRgn(i,StartY,i+1,j);<br/>       CombineRgn(rgn1,rgn1,rgn2,RGN_OR);<br/>      end;<br/>     end;<br/>    end<br/>    else //不允许色差<br/>    begin<br/>     if cc=BackColor then<br/>     begin<br/>      if (StartY&gt;=0) and (j&gt;=StartY) then<br/>      begin<br/>       rgn2:=CreateRectRgn(i,StartY,i+1,j);<br/>       CombineRgn(rgn1,rgn1,rgn2,RGN_OR);<br/>       StartY:=-1;<br/>      end;<br/>     end<br/>     else<br/>     begin<br/>      if Starty&lt;0 then<br/>       StartY:=j<br/>      else if j=(Picture.Bitmap.Height-1) then //最下面一个点<br/>      begin<br/>       rgn2:=CreateRectRgn(i,StartY,i+1,j);<br/>       CombineRgn(rgn1,rgn1,rgn2,RGN_OR);<br/>      end;<br/>     end;<br/>    end;<br/>   end;<br/>  end;<br/>  result:=rgn1;<br/> end<br/> else<br/>  result:=0;<br/>end;</p><p>procedure TBmpShape.Apply;<br/>begin<br/> if Parent is TForm then<br/> begin<br/>  Left:=0;<br/>  Top:=0;<br/>  Width:=Picture.Bitmap.Width;<br/>  Height:=Picture.Bitmap.Height;<br/>  with (Parent as Tform) do<br/>  begin<br/>   BorderStyle:=bsNone;<br/>   Width:=Self.Width;<br/>   Height:=Self.Height;<br/>  end;<br/>  SetWindowRgn(Parent.Handle,GetRegion,FALSE);<br/> end;<br/>end;</p><p>end.</p>                </div>                    </div>
10614	 砝码称重问题	c  	1016789880	1226	starfish	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p><br/>定理： 由m个数构成的由小到大排列的数列{a(1),a(2),...a(m)}，设A(k)=∑a(i)， 其中i从1到k， 则<br/>a(1) = 1且a(j+1) &lt;= 2A(j) +1， j取1,2,..,m-1     （1式）<br/>是该数列作为砝码序列可称量{0,1,..,Am}范围内的任意整数重量的充要条件。特别的，上式取等号时，该序列是唯一可能的砝码序列，并且有a(j) = 3^(j-1)， 对于j=1,2,..,m</p><p>推论： 重量为n的物体要分成m份重量为整数的物体的序列{a(1),a(2),..a(m)}，设M=∑3^(i-1)，其中i从1到m，则有三种情况：<br/>1） M&lt;n， 无解；<br/>2） M=n，有唯一的解 a(j)=3^(j-1), j=1,2,..m;<br/>3） M&gt;n，可能有多组解，解为满足（1式）并且∑a(i)=n,其中i从1到m，的所有整数序列。</p><p>定理的证明：<br/>（充分性）<br/>用数归法：<br/>当i=1的时候，a(i)=1显然成立；<br/>假设i=k的时候定理充分性成立，即用满足（1）式的前k个砝码可以称量的重量W(k)为满足0&lt;=W(k)&lt;=A(k)的所有整数，则i=k+1时，应可以称量W(k+1),应为0&lt;=W(k+1)&lt;=A(k+1)范围内的所有整数。分段讨论如下：<br/>(a)对于0&lt;=W(k+1)&lt;=A(k)，显然可以由前k个砝码称量；<br/>(b)对于A(k)&lt;W(k+1)&lt;=a(k+1)， 由假设0&lt;=W(k)&lt;=A(k)， 交换左右盘的砝码，可以产生配合砝码a(k+1)使用的负砝码为W(k)' 可以是满足-A(k)&lt;=W(k)'&lt;=0的所有整数。与大砝码a(k+1)一起使用可以得到a(k+1)+W(k)' ，一定可以称量某段连续范围的所有整数，因为a(k+1) &lt;=2A(k)+1， 所以a(k+1)-A(k) &lt;= A(k)+1， 因此a(k+1)+W(k)'产生的下限为a(k+1)-A(k)，上限为a(k+1),所以可以称量A(k)&lt;W(k+1)&lt;=a(k+1)内的所有W(k+1)；<br/>(c)对于a(k+1)&lt;=W(k+1)&lt;=A(k+1)，与(b)同理可以得到称量的上下限分别为：a(k+1)+A(k) = A(k+1)和a(k+1)；<br/>因此当i=k+1的时候定理充分性也成立，由数归法知定理充分性成立。</p><p>（必要性）<br/>i=1时，显然必须有总量为1的砝码；<br/>i&gt;1时，反证之，如果存在某个K，使得（1）不成立，即2A(k)+1&lt;a(k+1)，则重量A(k)+1既不能用前面的k-1个砝码称重，又因为a(k+1)-A(k)&gt;A(k)+1而不能用a(k+1)配合着称重。所以矛盾，因此必要性成立。</p><p>推论也可以用数归法简单的证明，这里我就不证了，打字太累了：）</p><p>根据以上的定理和推论，可以很容易的求出对于重量为任意的n的物体，用m个砝码可以称出来的砝码的方案。当n=∑3^(i-1)， i从1到m的时候，有唯一解a(i)=3^(i-1)，可以改写成a(i)=2(∑aj)+1，其中j从1到i-1，一个循环就直接输出了；当n&gt;∑3^(i-1)的时候无解；当n&lt;∑3^(i-1)的时候只要根据式（1）并保证∑a(i)=n搜索就可以了。可以递归的搜索求解。具体我就不写程序了。</p><p>终于写完了，好累呀~~<br/></p>                </div>                    </div>
10688	 JSP:调用servlet显示图片	servlet  jsp  import  byte  html  class  	1003466160	1013	zou5655	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        JSP: 调用servlet 显示图片<br/><br/><br/>   由于我工作需要，开始学习 java 和 jsp, 这段时间会多写点关于 jsp 的文章,以加强自己对jsp的了解。<br/>这篇文章主要是介绍如何调用 servlet 显示图片，其实也让大家知道如何在向客户端输出二进制数据。<br/><br/>下在这个 1.htm 用来调用servlet<br/><br/><br/>&lt;!------------ 文件 1.htm 开始--------------------&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;&lt;title&gt;用servlet 显示图片&lt;/title&gt;&lt;/head&gt;<br/><br/>&lt;body&gt;<br/> <br/> &lt;img src="http://localhost:8080/servlet/showimage"&gt;  <br/><br/>&lt;/body&gt;<br/>&lt;/html&gt;<br/><br/>&lt;!------------ 文件 1.htm 结束 ----------------&gt;<br/><br/>在Servlet 中,是靠 doGet()、 doPost() 等方法来响应 GET POST 方法的,这里我们响应的是GET,所以定义了一个 doGet() 方法下面是源程序:<br/><br/>//====================== showimage.java 程序开始 ===================================<br/><br/>在html 调用时只<br/>import java.io.*;<br/>import java.text.*;<br/>import java.util.*;<br/>import javax.servlet.*;<br/>import javax.servlet.http.*;<br/><br/>public class showimage extends HttpServlet {<br/><br/>public void doGet(HttpServletRequest req, HttpServletResponse res)<br/>throws ServletException, IOException<br/>{<br/><br/> try{<br/> FileInputStream hFile = new FileInputStream("d://1.gif"); // 以byte流的方式打开文件 d:/1.gif<br/> int i=hFile.available(); //得到文件大小<br/> byte data[]=new byte[i];<br/> hFile.read(data);  //读数据<br/> hFile.close();<br/> res.setContentType("image/*"); //设置返回的文件类型<br/> OutputStream toClient=res.getOutputStream(); //得到向客户端输出二进制数据的对象<br/> toClient.write(data);  //输出数据<br/> toClient.close();<br/> }<br/> catch(IOException e) //错误处理<br/> {<br/>  PrintWriter toClient = res.getWriter(); //得到向客户端输出文本的对象<br/>  res.setContentType("text/html;charset=gb2312");<br/>  toClient.write("无法打开图片!");<br/>  toClient.close();<br/> }<br/><br/> }<br/><br/>}<br/>                </div>                    </div>
10708	 WIN下动态注册码实现方法	winapi  system  null  structure  dll  parameters  	1008997800	1431	zou5655	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p>所谓的动态注册码就是软件在不同的机器运行时注册码将不同。此做法的好处在于不可能以同一注册码注册不同机器上的软件。这样就提高了软件的安全保密性。这种方法已被普遍运用，下面就以俺用C++ Builder写的一个程序为列，介绍一下实现原理。 <br/>WIN下动态注册码实现方法:<br/><br/>作者：病毒 <br/><br/>　　所谓的动态注册码就是软件在不同的机器运行时注册码将不同。此做法的好处在于不可能以同一注册码注册不同机器上的软件。这样就提高了软件的安全保密性。这种方法已被普遍运用，下面就以俺用C++ Builder写的一个程序为列，介绍一下实现原理。 <br/><br/>　　 获取CPU信息用于注册，不同厂商的CPU其信息也将不同，下面只用了一个修订本ID,可以考虑将结构中所有信息做运算。<br/><br/>　　 获取CPU信息用WINAPI的GetSystemInfo函数。 该函数运行后将填充SYSTEM_INFO结构。其结构如下：<br/><br/>VOID GetSystemInfo(<br/><br/>LPSYSTEM_INFO lpSystemInfo // address of system information structure<br/><br/>);<br/><br/>Parameters<br/><br/>lpSystemInfo<br/><br/>Points to a SYSTEM_INFO structure to be filled in by this function.<br/><br/>typedef struct _SYSTEM_INFO { // sinf <br/><br/>union {<br/><br/>DWORD dwOemId;<br/><br/>struct {<br/><br/>WORD wProcessorArchitecture;<br/><br/>WORD wReserved; <br/><br/>};<br/><br/>}; <br/><br/>DWORD dwPageSize; <br/><br/>LPVOID lpMinimumApplicationAddress;<br/><br/>LPVOID lpMaximumApplicationAddress;<br/><br/>DWORD dwActiveProcessorMask;<br/><br/>DWORD dwNumberOfProcessors;<br/><br/>DWORD dwProcessorType;<br/><br/>DWORD dwAllocationGranularity;<br/><br/>WORD wProcessorLevel;<br/><br/>WORD wProcessorRevision; //我们所用到的 <br/><br/>} SYSTEM_INFO; <br/><br/>　　 当硬盘格式化时会随机填写逻辑硬盘的序列号，因是随机填写相同的序列号的可能性微乎其微。再加上CPU信息 和最后对两个值做的运算，这样就可以实现在不同机上得到不同的注册号。用WINAPI的GetVolumeInformation函数得到逻辑序列号，其原形如下：<br/><br/>　　 BOOL GetVolumeInformation(<br/><br/>LPCTSTR lpRootPathName, // address of root directory of the file system LPTSTR lpVolumeNameBuffer, // address of name of the volume<br/><br/>DWORD nVolumeNameSize, // length of lpVolumeNameBuffer <br/><br/>LPDWORD lpVolumeSerialNumber, // address of volume serial number<br/><br/>LPDWORD lpMaximumComponentLength, // address of system's maximum <br/><br/>filename length <br/><br/>LPDWORD lpFileSystemFlags, // address of file system flags<br/><br/>LPTSTR lpFileSystemNameBuffer, // address of name of file system<br/><br/>DWORD nFileSystemNameSize // length of lpFileSystemNameBuffer<br/><br/>); <br/><br/>　　 从上看我们只关心第四个参数返回逻辑硬盘序列号。我们将主功能做成DLL形式在应用程序中调用 这样使用起来即方便，又提高了安全性。具体程序如下：<br/><br/>.H文件<br/><br/>private: // User declarations<br/><br/>DWORD (WINAPI *GetCurrentHostSeriaNumber)(void); //声明函数指针<br/><br/>.CPP文件<br/><br/>HINSTANCE DLLinst=LoadLibrary("GetSeria"); //动态调用DLL文件<br/><br/>if(DLLinst) { GetCurrentHostSeriaNumber=(DWORD(WINAPI *)(void)) GetProcAddress(DLLinst,"GetCurrentHostSeriaNumber"); //获取DLL中的函数 if(GetCurrentHostSeriaNumber) <br/><br/>{<br/><br/>DWORD RegNumber=GetCurrentHostSeriaNumber(); //执行并返回注册码 if(String(RegNumber)==Edit1-&gt;Text) //与输入进行比较<br/><br/>ShowMessage("注册码正确");<br/><br/>else ShowMessage("注册码错误"); <br/><br/>}<br/><br/>else ShowMessage("DLL中函数错误");<br/><br/>} else ShowMessage("GetSeria.dll不在当前目录下"); <br/><br/>.DLL文件<br/><br/>extern "C" __declspec(dllexport) DWORD WINAPI GetCurrentHostSeriaNumber(void); 以标准C方式声明函数调用方法<br/><br/>int WINAPI DllEntryPoint(HINSTANCE, unsigned long , void*)<br/><br/>{<br/><br/>return 1;<br/><br/>}<br/><br/>DWORD WINAPI GetCurrentHostSeriaNumber(void) <br/><br/>{<br/><br/>SYSTEM_INFO info;<br/><br/>DWORD SeriaNumber=NULL;<br/><br/>DWORD Register=NULL; <br/><br/>GetSystemInfo(&amp;info); //调用函数填SYSTEM_INFO结构 GetVolumeInformation("C://",NULL,NULL,&amp;SeriaNumber,NULL,NULL,NULL,NULL)<br/><br/>; //获取C盘序列号 <br/><br/>Register=SeriaNumber+info.wProcessorRevision; <br/><br/>Register=Register^7609926; //相加后最异或运算 <br/><br/>return Registet;<br/><br/>} <br/><br/>　　 此程序虽是一个简单的DEMO，但稍微加工就可以为商品软件所用。再此说一下硬盘序列号分为两中1逻辑磁盘序列号，2物理硬盘 序列号。后者是硬盘出厂时所固定唯一代码，如在DOS下可以直接通过IN，OUT读写端口来获取，但WIN下就须写VXD来实现此操作。 思路和实现方法已经给出。再具体的自己来做吧。 <br/><br/></p>                </div>                    </div>
10970	 Asp.net性能优化总结(二)	性能优化  asp.net  datagrid  sql server  优化  服务器  	1081177260	1286	jxf_yx	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p align="center" class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:-21pt;"><font size="3"><span lang="en-us" xml:lang="en-us"><span><strong>Asp.net性能优化总结</strong></span></span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:-21pt;"><font size="3"><span lang="en-us" xml:lang="en-us"><span>一、</span></span><b><span style="font-family:'宋体';">使用存储过程</span></b><span style="font-family:'宋体';">：</span></font></p><ol style="margin-top:0cm;" type="1"><li class="MsoNormal" style="margin:0cm 0cm 0pt;"><font size="3"><span style="color:#008000;font-family:'宋体';">性能方面：</span><span style="font-family:'宋体';">存储过程提供了许多标准</span><span lang="en-us" xml:lang="en-us">sql</span><span style="font-family:'宋体';">语言中所没有的高级特性。其传递参数和执行逻辑表达式的功能，有助于应用程序设计者处理复杂任务。另外，存储过程存储在本地服务器上，减少了执行该过程所需的网络传输宽带和执行时间。（存储过程已经对</span><span lang="en-us" xml:lang="en-us">sql</span><span style="font-family:'宋体';">语句进行了预编译，所以其执行速度比在程序里执行</span><span lang="en-us" xml:lang="en-us">sql</span><span style="font-family:'宋体';">语句快很多）</span></font> </li><li class="MsoNormal" style="margin:0cm 0cm 0pt;"><span style="font-family:'宋体';"><font size="3">程序结构方面：从程序的可扩展性看，使用存储过程会对程序以后的修改带来方便。比如数据库的结构改变了，只需修改相对应的存储结构，和程序中的调用部分即可。</font></span></li></ol><p class="MsoNormal" style="margin:0cm 0cm 0pt 39pt;"><span style="font-family:'宋体';"><font size="3">这部分不属于本文探讨范围，属于程序结构设计方面。所以不在此展开。</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><font size="3"><span lang="en-us" xml:lang="en-us"><span>   </span>3.<span>  </span></span><span style="font-family:'宋体';">程序安全性：使用存储过程可避免</span><span lang="en-us" xml:lang="en-us"><a href="http://www.spidynamics.com/papers/SQLInjectionWhitePaper.pdf"><span style="text-decoration:none;">SQL Injection</span></a></span><span style="font-family:'宋体';">攻击。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:-21pt;"><font size="3"><span lang="en-us" xml:lang="en-us"><span>二、</span></span><b><span style="font-family:'宋体';">查询语句的优化（针对</span><span lang="en-us" xml:lang="en-us">sql server2000</span></b><b><span style="font-family:'宋体';">）</span></b></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:15.75pt;"><font size="3"><span style="font-family:'宋体';">很多人只为目的写出</span><span lang="en-us" xml:lang="en-us">sql</span><span style="font-family:'宋体';">语句，而不考虑</span><span lang="en-us" xml:lang="en-us">sql</span><span style="font-family:'宋体';">语句的执行效率。在这我只提供一优化表顺序的方法，（</span><span lang="en-us" xml:lang="en-us">sql</span><span style="font-family:'宋体';">语句的优化和原则将会在我的</span><span lang="en-us" xml:lang="en-us">sql server2000</span><span style="font-family:'宋体';">学习笔记中专题讨论）</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><font size="3"><span style="font-family:'宋体';">对</span><span lang="en-us" xml:lang="en-us">sql</span><span style="font-family:'宋体';">语句执行效率可用</span><span lang="en-us" xml:lang="en-us">sql server2000</span><span style="font-family:'宋体';">的查询分析器来查看语句的执行过程。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><font size="3"><span style="font-family:'宋体';">优化表顺序：一般情况下，</span><span lang="en-us" xml:lang="en-us">sqlserver </span><span style="font-family:'宋体';">会对表的连接作出自动优化。例如：</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" style="color:#0000FF;" xml:lang="en-us"><font size="3">select name,no from A &lt;?xml:namespace prefix = o ns = "urn:schemas-microsoft-com:office:office" /&gt;</font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="color:#0000FF;" xml:lang="en-us"><font size="3">join B on A. id=B.id</font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:21pt;"><span lang="en-us" style="color:#0000FF;" xml:lang="en-us"><font size="3">join C on C.id=A.id</font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><span lang="en-us" style="color:#0000FF;" xml:lang="en-us"><font size="3">where name=’wang’</font></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><font size="3"><span style="font-family:'宋体';">尽管</span><span lang="en-us" xml:lang="en-us">A</span><span style="font-family:'宋体';">表在</span><span lang="en-us" xml:lang="en-us">From</span><span style="font-family:'宋体';">中先列出，然后才是</span><span lang="en-us" xml:lang="en-us">B,</span><span style="font-family:'宋体';">最后才是</span><span lang="en-us" xml:lang="en-us">C</span><span style="font-family:'宋体';">。但</span><span lang="en-us" xml:lang="en-us">sql server</span><span style="font-family:'宋体';">可能会首先使用</span><span lang="en-us" xml:lang="en-us">c</span><span style="font-family:'宋体';">表。它的选择原则是相对于该查询限制为单行或少数几行，就可以减少在其他表中查找的总数据量。绝大多数情况下，</span><span lang="en-us" xml:lang="en-us">sql server </span><span style="font-family:'宋体';">会作出最优的选择，但如果你发觉某个复杂的联结查询速度比预计的要慢，就可以使用</span><span lang="en-us" style="color:#0000FF;" xml:lang="en-us">SET FORCEPLAN</span><span style="font-family:'宋体';">语句强制</span><span lang="en-us" xml:lang="en-us">sql server</span><span style="font-family:'宋体';">按照表出现顺序使用表。如上例加上：</span><span lang="en-us" xml:lang="en-us">SET </span>&lt;?xml:namespace prefix = st1 ns = "urn:schemas-microsoft-com:office:smarttags" /&gt;<span lang="en-us" xml:lang="en-us">FORCEPLAN</span><span lang="en-us" xml:lang="en-us"> </span><span lang="en-us" xml:lang="en-us">ON</span><span lang="en-us" xml:lang="en-us">…….SET FORCEPLAN OFF<span>  </span></span><span style="font-family:'宋体';">表的执行顺序将会按照你所写的顺序执行。在查询分析器中查看</span><span lang="en-us" xml:lang="en-us">2</span><span style="font-family:'宋体';">种执行效率，从而选择表的连接顺序。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><font size="3"><span lang="en-us" style="color:#008000;" xml:lang="en-us">*</span><span style="color:#008000;font-family:'宋体';">使用</span><span lang="en-us" style="color:#008000;" xml:lang="en-us">SET FORCEPLAN</span><span style="color:#008000;font-family:'宋体';">选择表联结顺序</span><span lang="en-us" style="color:#008000;" xml:lang="en-us"></span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:-21pt;"><font size="3"><span lang="en-us" xml:lang="en-us"><span>三、</span></span><b><span style="font-family:'宋体';">页面的优化（</span><span lang="en-us" xml:lang="en-us">.aspx</span></b><b><span style="font-family:'宋体';">）</span></b></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;"><font size="3"><span style="font-family:'宋体';">主要针对几个页面属性</span><span lang="en-us" xml:lang="en-us"></span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 39pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us"><span><font size="3">1.</font><span style="font:7pt 'Times New Roman';">       </span></span></span><font size="3"><span lang="en-us" xml:lang="en-us">EnableViewState(</span><span style="font-family:'宋体';">页面的视图状态</span><span lang="en-us" xml:lang="en-us">)</span><span style="font-family:'宋体';">。如果无特殊要求设置为</span><span lang="en-us" xml:lang="en-us">false</span><span style="font-family:'宋体';">。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 39pt;"><span style="font-size:10pt;color:#0000FF;font-family:'宋体';">使用</span><span lang="en-us" style="font-size:10pt;color:#0000FF;" xml:lang="en-us">ViewState </span><span style="font-size:10pt;color:#0000FF;font-family:'宋体';">，每个对象都必须先序列化到</span><span lang="en-us" style="font-size:10pt;color:#0000FF;" xml:lang="en-us"> ViewState </span><span style="font-size:10pt;color:#0000FF;font-family:'宋体';">中，然后再通过回传进行反序列化，因此使用</span><span lang="en-us" style="font-size:10pt;color:#0000FF;" xml:lang="en-us"> ViewState</span><span style="font-size:10pt;color:#0000FF;font-family:'宋体';">是没有代价的。尽量减少使用对象，如果可能，尽量减少放入</span><span lang="en-us" style="font-size:10pt;color:#0000FF;" xml:lang="en-us"> ViewState </span><span style="font-size:10pt;color:#0000FF;font-family:'宋体';">中的对象的数目。下面情况基本上可以禁用</span><span lang="en-us" style="font-size:10pt;color:#0000FF;" xml:lang="en-us">viewstate</span><span style="font-size:10pt;color:#0000FF;font-family:'宋体';">：</span><span lang="en-us" style="font-size:10pt;color:#0000FF;" xml:lang="en-us"></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 38.95pt;"><span style="font-size:9pt;font-family:'宋体';">（</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">1</span><span style="font-size:9pt;font-family:'宋体';">）页面控件</span><span style="font-size:9pt;"> </span><span style="font-size:9pt;font-family:'宋体';">（</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">.ascx</span><span style="font-size:9pt;font-family:'宋体';">）</span><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 38.95pt;"><span style="font-size:9pt;font-family:'宋体';">（</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">2</span><span style="font-size:9pt;font-family:'宋体';">）页面不回传给自身。</span><span style="font-size:9pt;"> </span><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 38.95pt;"><span style="font-size:9pt;font-family:'宋体';">（</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">3</span><span style="font-size:9pt;font-family:'宋体';">）无需对控件的事件处理。</span><span style="font-size:9pt;"> </span><span lang="en-us" style="font-size:9pt;font-family:'宋体';" xml:lang="en-us"></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 38.95pt;"><span style="font-size:9pt;font-family:'宋体';">（</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">4</span><span style="font-size:9pt;font-family:'宋体';">）控件没有动态的或数据绑定的属性值（或对于每个</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">postpack</span><span style="font-size:9pt;font-family:'宋体';">都在代码中处理）</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:45pt;"><span style="font-size:9pt;color:#339966;font-family:'宋体';">单个页面或每个页面都禁用</span><span lang="en-us" style="font-size:9pt;color:#339966;" xml:lang="en-us"> ViewState</span><span style="font-size:9pt;color:#339966;font-family:'宋体';">，如下所示：</span><span lang="en-us" style="font-size:9pt;color:#339966;font-family:'宋体';" xml:lang="en-us"></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:45pt;"><span style="font-size:9pt;color:#339966;font-family:'宋体';">单个页面：</span><span lang="en-us" style="font-size:9pt;color:#339966;" xml:lang="en-us">&lt;%@ Page EnableViewState="False" %&gt; </span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:45pt;"><span style="font-size:9pt;color:#339966;font-family:'宋体';">每个页面：在</span><span lang="en-us" style="font-size:9pt;color:#339966;" xml:lang="en-us"> web.config </span><span style="font-size:9pt;color:#339966;font-family:'宋体';">中</span><span lang="en-us" style="font-size:9pt;color:#339966;" xml:lang="en-us"> &lt;Pages EnableViewState="false" /&gt;</span><span lang="en-us" style="color:#99cc00;" xml:lang="en-us"></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 39pt;"><font size="3"><span lang="en-us" xml:lang="en-us">EnableSessionState</span><span style="font-family:'宋体';">保持默认值即可（如果页面用到</span><span lang="en-us" xml:lang="en-us">sessionstate</span><span style="font-family:'宋体';">它才会占用资源）。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 39pt;"><font size="3"><span lang="en-us" xml:lang="en-us">EnableViewStateMac</span><span style="font-family:'宋体';">如果无安全上的特殊要求，保持默认值。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 39pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us"><span><font size="3">2.</font><span style="font:7pt 'Times New Roman';">       </span></span></span><font size="3"><span lang="en-us" xml:lang="en-us">Pagelayout.</span><span style="font-family:'宋体';">页面布局模型。建议使用</span><span lang="en-us" xml:lang="en-us">Flowlayout(</span><span style="font-family:'宋体';">元素不带绝对定位属性添加</span><span lang="en-us" xml:lang="en-us">).Gridlayout(</span><span style="font-family:'宋体';">绝对定位属性</span><span lang="en-us" xml:lang="en-us">)</span><span style="font-family:'宋体';">由于采用绝对定位，将会比</span><span lang="en-us" xml:lang="en-us">Flowlayout</span><span style="font-family:'宋体';">生产更多的代码，主要是控件的定位信息。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><font size="3"><span lang="en-us" xml:lang="en-us">3</span><span style="font-family:'宋体';">．项目发布的时候切记解除页面的</span><span lang="en-us" xml:lang="en-us">Debug</span><span style="font-family:'宋体';">状态。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><font size="3"><span lang="en-us" xml:lang="en-us">4</span><span style="font-family:'宋体';">．</span><span lang="en-us" xml:lang="en-us">Html</span><span style="font-family:'宋体';">语言的优化。我的建议是熟练掌握</span><span lang="en-us" xml:lang="en-us">Html/JavaScript</span><span style="font-family:'宋体';">，少用</span><span lang="en-us" xml:lang="en-us">vs.net2003</span><span style="font-family:'宋体';">自动生产的代码，它会自动生成一些无用的</span><span lang="en-us" xml:lang="en-us">html</span><span style="font-family:'宋体';">代码。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21pt;"><span lang="en-us" xml:lang="en-us"><font size="3">5.</font></span><span lang="en-us" style="font-size:10pt;color:#FF0000;" xml:lang="en-us"> </span><span lang="en-us" style="font-size:10pt;font-family:'宋体';" xml:lang="en-us">smart navigation设置为true能让用户明显的感觉性能提高。启用此属性后对客户端和服务端影响不大.它能智能涮新需要涮新需涮新的部分.</span><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us"></span></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 21pt;text-indent:-21pt;"><font size="3"><span lang="en-us" xml:lang="en-us"><span>四、</span></span><b><span style="font-family:'宋体';">控件的选择</span></b><span style="font-family:'宋体';">：</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 15.75pt;text-indent:15.75pt;"><font size="3"><span lang="en-us" xml:lang="en-us">Html</span><span style="font-family:'宋体';">控件和服务器控件的选择。服务器控件带来的方便和功能上的实现是</span><span lang="en-us" xml:lang="en-us">html</span><span style="font-family:'宋体';">控件所不能比拟的。但是是以牺牲服务器端的资源来取得的。我个人建议：如果</span><span lang="en-us" xml:lang="en-us">html</span><span style="font-family:'宋体';">控件达不到所要实现的功能，而且和一些脚本语言（如</span><span lang="en-us" xml:lang="en-us">javascrpt/vbscript</span><span style="font-family:'宋体';">）结合也不能实现的话。才会选择服务器控件。选择服务器控件后，也尽量对其控件优化，如取消一些页面状态等（具体看控件的优化）</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:31.5pt;"><span style="font-family:'宋体';"><font size="3">服务器控件的选择：主要针对几个常用数据控件说明一下：</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><font size="3"><span lang="en-us" xml:lang="en-us"><span>      </span>DataGrid</span><span style="font-family:'宋体';">：自带最强大的数据显示控件，内置了对数据的修改、删除、添加、分页等很多实用功能。如果你只需对数据显示的话，尽量不要选择</span><span lang="en-us" xml:lang="en-us">DataGrid</span><span style="font-family:'宋体';">（它把数据都存储在</span><span lang="en-us" xml:lang="en-us">viewstate</span><span style="font-family:'宋体';">中）</span><span lang="en-us" xml:lang="en-us">.</span><span style="font-family:'宋体';">也不要使用自带的分页功能，</span><span lang="en-us" xml:lang="en-us">microsoft</span><span style="font-family:'宋体';">在自动分页的底层做了很多工作，虽然使用方便了，但性能开销大了。（推荐一分页控件：</span><span lang="en-us" xml:lang="en-us"><a href="http://webdiyer.europe.webmatrixhosting.net/default.aspx"><span style="text-decoration:none;">http://webdiyer.europe.webmatrixhosting.net/default.aspx</span></a></span><span style="font-family:'宋体';">）</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><font size="3"><span lang="en-us" xml:lang="en-us"><span>      </span><span>    </span>DataList</span><span style="font-family:'宋体';">：比</span><span lang="en-us" xml:lang="en-us">DataGrid</span><span style="font-family:'宋体';">功能少了很多。但自定义性强了很多。特有的多行数据显示，给我们带来了很多方便。</span><span lang="en-us" xml:lang="en-us">DataGrid</span><span style="font-family:'宋体';">能实现的功能，它基本能实现。所以建议使用它。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><font size="3"><span lang="en-us" xml:lang="en-us"><span>      </span><span>    </span>Repeater</span><span style="font-family:'宋体';">：功能最少，但自定义性非常强。如果只需对数据显示，建议使用。由于减少了很多功能，对服务器的性能带来消耗最小。因此，如果是对数据显示的话，我基本上都是选择</span><span lang="en-us" xml:lang="en-us">Repeater</span><span style="font-family:'宋体';">然后</span><span lang="en-us" xml:lang="en-us">DataList</span><span style="font-family:'宋体';">最后</span><span lang="en-us" xml:lang="en-us">DataGrid</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:15.75pt;"><font size="3"><span lang="en-us" style="color:#008000;" xml:lang="en-us">*</span><span style="color:#008000;font-family:'宋体';">尽量选择</span><span lang="en-us" style="color:#008000;" xml:lang="en-us">html</span><span style="color:#008000;font-family:'宋体';">控件。能在客户端实现的功能就在客户端实现</span><span lang="en-us" style="color:#008000;" xml:lang="en-us">(</span><span style="color:#008000;font-family:'宋体';">熟练掌握</span><span lang="en-us" style="color:#008000;" xml:lang="en-us">javascript)</span><span style="color:#008000;font-family:'宋体';">，减少服务器的压力。数据控件选择顺序：</span><span lang="en-us" style="color:#008000;" xml:lang="en-us">Repeater</span><span style="color:#008000;font-family:'宋体';">、</span><span lang="en-us" style="color:#008000;" xml:lang="en-us">DataList</span><span style="color:#008000;font-family:'宋体';">、</span><span lang="en-us" style="color:#008000;" xml:lang="en-us">DataGrid</span></font></p><p></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;"><span style="font-family:'宋体';"><font size="3">五、<b>服务器控件的优化</b>：</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 39.75pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us"><span><font size="3">1．</font><span style="font:7pt 'Times New Roman';">  </span></span></span><span lang="en-us" xml:lang="en-us"><font size="3">Viewstate</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 39.75pt;"><font size="3"><span style="font-family:'宋体';">控件的</span><span lang="en-us" xml:lang="en-us">viewstate</span><span style="font-family:'宋体';">与页面的</span><span lang="en-us" xml:lang="en-us">viewstate</span><span style="font-family:'宋体';">基本是一致的。用来保存控件的一些状态。</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 39.75pt;"><font size="3"><span style="font-family:'宋体';">处理原则和处理页面的</span><span lang="en-us" xml:lang="en-us">viewstate</span><span style="font-family:'宋体';">一样。有兴趣的可以用</span><span lang="en-us" xml:lang="en-us">Datagrid</span><span style="font-family:'宋体';">绑定数据测试下</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 39.75pt;"><font size="3"><span lang="en-us" xml:lang="en-us">viewstate</span><span style="font-family:'宋体';">保存的数据量有多大，它所保存的数据基本和</span><span lang="en-us" xml:lang="en-us">Datagrid</span><span style="font-family:'宋体';">显示的数据量大小</span></font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 39.75pt;"><span style="font-family:'宋体';"><font size="3">是等同的。</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 39.75pt;text-indent:-18pt;"><span lang="en-us" xml:lang="en-us"><span><font size="3">2．</font><span style="font:7pt 'Times New Roman';">  </span></span></span><span lang="en-us" xml:lang="en-us"><font size="3">Ispostpack</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt 39.75pt;"><span lang="en-us" xml:lang="en-us"></span></p><p><font size="3"> 默认false.需要产生事件的时候才需设置为true.</font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span style="font-family:'宋体';"><font size="3">控件的优化，主要看你对此控件的熟悉情况。对控件内部运作的原理越了解，就会对其作出合适的优化。</font></span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span lang="en-us" xml:lang="en-us"></span></p><p><font size="3"> </font></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span style="font-family:'宋体';"><font size="3">性能优化是</font></span><span style="font-size:10pt;font-family:'宋体';">三两句话说不清的，我所写出的仅仅是冰山一角，性能的优化是靠平时经验的积累和对程序的运作原理的不断认知。</span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span style="font-size:10pt;font-family:'宋体';">如有错误，请提出.由于有些不可抗拒因素.此文,先写到此.有时间再继续补充.</span></p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span lang="en-us" style="font-size:10pt;" xml:lang="en-us"></span></p><p> </p><p class="MsoNormal" style="margin:0cm 0cm 0pt;text-indent:21.75pt;"><span lang="en-us" xml:lang="en-us"></span></p><p><font size="3"> </font></p>                </div>                    </div>
10982	 身份证15位升18位的算法	算法  delphi  integer  string  javascript  insert  	1029201120	5727	pazee	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p><font face="宋体">　　现在新的身份证已经从15位升到了18位了，很多软件都可能用到身份证的输入、校验的工作，关于新身份证的编码似乎文章很少，我在2000年的时候找到了计算机世界的一篇文章，发现现在的身份证校验码居然可能是英文字母x(其实这个X是罗马字母，表示10的意思)，为什么用字母呢？谁知道？ 起码电话上数字键就输不进去新的号码。（现在的办法是使用*替代，好在还有#*2个键，我也做过CTI的，呵呵）,然后我写了个delphi的过程，贴到了“网易”，但是不适用于100岁以上的老人。</font></p><p><font face="宋体">我发现有很多网友问这个问题，所以整理了一下重新贴出来，新瓶装旧酒了。<br/> </font></p><p><font face="宋体">    根据〖中华人民共和国国家标准 GB 11643-1999〗中有关公民身份号码的规定，公民身份号码是特征组合码，由十七位数字本体码和一位数字校验码组成。排列顺序从左至右依次为：六位数字地址码，八位数字出生日期码，三位数字顺序码和一位数字校验码。 </font></p><p><font face="宋体">    地址码表示编码对象常住户口所在县(市、旗、区)的行政区划代码。生日期码表示编码对象出生的年、月、日，其中年份用四位数字表示，年、月、日之间不用分隔符。顺序码表示同一地址码所标识的区域范围内，对同年、月、日出生的人员编定的顺序号。顺序码的奇数分给男性，偶数分给女性。校验码是根据前面十七位数字码，按照ISO 7064:1983.MOD 11-2校验码计算出来的检验码。下面举例说明该计算方法。  </font></p><p><font face="宋体">    15位的身份证编码首先把出生年扩展为4位，简单的就是增加一个19，但是这对于1900年出生的人不使用（这样的寿星不多了）</font></p><p><font face="宋体">    某男性公民身份号码本体码为34052419800101001，首先按照公式⑴计算： </font></p><p><font face="宋体">∑(ai×Wi)(mod 11)……………………………………(1) </font></p><p><font face="宋体">公式(1)中：<br/>i----表示号码字符从由至左包括校验码在内的位置序号；<br/>ai----表示第i位置上的号码字符值；<br/>Wi----示第i位置上的加权因子，其数值依据公式Wi=2（n-1）(mod 11)计算得出。 </font></p><p><font face="宋体">i       18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1 </font></p><p><font face="宋体">ai       3  4  0  5  2  4  1  9  8  0  0  1  0  1  0  0  1 a1 </font></p><p><font face="宋体">Wi       7  9 10  5  8  4  2  1  6  3  7  9 10  5  8  4  2  1 </font></p><p><font face="宋体">ai×Wi  21 36  0 25 16 16  2  9 48  0  0  9  0  5  0  0  2 a1 </font></p><p><font face="宋体">根据公式(1)进行计算： </font></p><p><font face="宋体">∑(ai×Wi) =（21+36+0+25+16+16+2+9+48++0+0+9+0+5+0+0+2) = 189 </font></p><p><font face="宋体">189 ÷ 11 = 17 + 2/11 </font></p><p><font face="宋体">∑(ai×Wi)(mod 11) = 2 </font></p><p><font face="宋体">    然后根据计算的结果，从下面的表中查出相应的校验码，其中X表示计算结果为10： </font></p><p><font face="宋体">∑(ai×WI)(mod 11)   0 1 2 3 4 5 6 7 8 9 10 <br/>校验码字符值ai       1 0 X 9 8 7 6 5 4 3  2<br/>    根据上表，查出计算结果为2的校验码为所以该人员的公民身份号码应该为 34052419800101001X。 </font></p><p><br/><font face="宋体">以下是我的delphi 函数 </font></p><p><font face="宋体">function IDfun(ID: string):string; <br/>const <br/>  W:array [1..18] of integer = (7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2,1); <br/>  A:array [0..10] of char = ('1','0','x','9','8','7','6','5','4','3','2'); <br/>var <br/>  i, j, S: integer; <br/>  NewID: string; <br/>begin <br/>  if Length(ID) &lt;&gt; 15 then <br/>    result:= '' <br/>  else begin <br/>    NewID:= ID; <br/>    Insert('19', NewID, 7); <br/>    S:= 0; <br/>    try <br/>      for i:=1 to 17 do begin <br/>        j:= StrToInt(NewID[i]) * W[i]; <br/>        S:= S + j; <br/>      end; <br/>    except <br/>      result:= ''; <br/>      exit; <br/>    end; <br/>    S:= S mod 11; <br/>    Result:= NewID + A[S]; <br/>  end; <br/>end; </font></p><p><font face="宋体">我曾经把这各算法用php,c++和javascript实现，用在网站和其他的程序上。<br/>我一向觉得给算法比给源代码要好得多，有了上面的算法说明，相信这代码不难变成其他的语言吧。 </font></p><p>有问题请给我mail: <a href="mailto:pazee@21cn.com">pazee@21cn.com</a></p>                </div>                    </div>
11083	 Pb中多用户权限管理实现方案	string  integer  教育  user  c  	991968600	935	netmuse	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p> </p><p>              Pb中多用户权限管理实现方案<br/>         （南京审计学院教育技术中心  210029 丁国勇）<br/>    在pb实现一般管理系统的时候，我们会遇到这样一种情况，作为一个系统，可以分为若干个子系统，有多个操作员对它进行操作，每个操作员对各个子系统的权限不同，甚至在同一子系统中，操作员对各个菜单项的<br/>操作权限也不一样，更细一点，不同的操作员对于同一窗口中某一按钮的操作权限也是不一样的，那么，怎样<br/>较好地实现对不同用户细化到某个按钮的权限控制呢？笔者在进行一个系统的开发过程当中，积累了一些心得，与大家探讨一下。<br/>     首先，怎样使得一个操作员不能对他不具权限的菜单项或按钮进行操作呢，我们当然没有必要为不同的用户制作不同的菜单项或窗口（当然这也不失为一种方法），考虑到菜单项和按钮的Visible和Enabled属性，我们自然想到，设置这两个属性便可以完成上面的要求，比如<br/>m_1.m_2.visible=false   <br/>或者<br/>cb_1.enabled=false<br/>菜单不可见了,操作员自然就不可操作了。<br/>    其次,对于一个多用户的系统，我们自然需要用一个表来存放基本的用户信息，其中要包括用户登录系统的<br/>用户名、密码，如果要进行权限的分级控制，还需要一些字段来存放有关权限的信息，有些成品系统中是这样做的，不过它们将每个需要进行控制的菜单项均用一个字段来表示，这样做不太好，万一设计一个权限控制比较细的系统时，这样做的可行性便不好，其实，对与某个菜单项或其他控件，进行权限控制时，状态只有两个，true or false,完全可以用一位二进制数0或1来表示，我们可以将一个子系统中所有需要进行权限控制的项<br/>组合成一个二进制串，每四个二进制数转化成一个字符（可以是"0","1","2"...."a","b","c","d","e","f")，再保存在表中，这样我们来算一下，如果一个子系统中有64个项需要进行权限控制，则只需要一个 64/4=16 位<br/>的字符类型的字段即可以表示，而不像过去那样需要64个字段来分别标记。<br/>好了，第一步存放的问题解决了，那么怎样根据这样的一个标记权限的字符串来设置各个菜单项或其他控件的<br/>visible 或Enabled属性呢？我注意到，pb中菜单项和其它控件都有一个tag属性,而这个属性我们一般不太会用到它，我们可以用tag属性来存放一个数字，这个数字标示了该控件在权限控制字段的那个二进制串中表示该控件的访问权限的0/1的位置，举个例子，有一个权限控制二进制串'01001111010....',菜单项"打开文件"的tag为7,则在该二进制串中第7位"1"便标记了当前用户对"打开文件"的控制权限为"1".<br/>     当一个用户登录系统时，在通过了密码验证后，将他对该系统的权限控制字段的字符串读到一个全局变量中，将该字符串恢复为0、1串，对于每个需要进行权限控制的项，依次根据其tag记录的相应位置的0或1设置Visible或Enabled属性，便可以完成对权限的管理。<br/>当然，要注意的是，有些控件的权限设置并不是在一进入系统后就进行的，而是推迟到该控件被调用时才进行。<br/>下面给出了一个例子，来说明上面的论述。<br/>有以下3个菜单项和2个按钮需要控制<br/>3个菜单项名称分别为：<br/>m_a.m_h1.m_m1   <br/>m_a.m_h1.m_m2<br/>m_a.m_h1.m_m3<br/>以上3个菜单项的tag设置为 1-3<br/>2个按钮位于两个窗口中<br/>cb_1  位于w_1中<br/>cb_2  位于w_2中<br/>以上2个按钮的tag设置为4,5<br/>这样，需要5位来表示他们的访问权限。<br/>函数getbin用来进行从"0","1"...,"a"..."f"到四位二进制串的转换<br/>getbin(string s_ch) returns string<br/>string s_out,s_temp<br/>integer i_len<br/>integer i<br/>string temp<br/>i_len=len(s_ch)<br/>if i_len=0 or isnull(s_ch) then<br/> s_out="0"<br/>end if<br/> temp=""<br/>s_temp=""<br/>for i=1  to i_len <br/>temp=mid(s_ch,i,1)<br/>choose case lower(temp)<br/> case "a" <br/>  s_temp="1010"<br/> case "b"<br/>  s_temp="1011"<br/> case "c"<br/>  s_temp="1100"<br/> case "d"<br/>  s_temp="1101"<br/> case "e"<br/>  s_temp="1110"<br/> case "f"<br/>  s_temp="1111"<br/> case "0"<br/>  s_temp="0000"<br/> case "1"<br/>  s_temp="0001"<br/> case "2"<br/>  s_temp="0010"<br/> case "3"<br/>  s_temp="0011"<br/> case "4"<br/>  s_temp="0100"<br/> case "5"<br/>  s_temp="0101"<br/> case "6"<br/>  s_temp="0110"<br/> case "7"<br/>  s_temp="0111"<br/> case "8"<br/>  s_temp="1000"<br/> case "9"<br/>  s_temp="1001"<br/> case else<br/>  s_temp="0000"<br/> end choose<br/>s_out=s_out+s_temp<br/>s_temp=""<br/>next<br/>return s_out<br/>定义一个全局变量s_admin用来存放该用户登录后的权限信息：<br/>String s_temp<br/>select rights into :s_temp where user=:username and password=:userpassword;<br/>s_admin=getbin(s_temp)  //<a>s_admin</a>存放的是已经转化好的权限信息。<br/> <br/>定义一个权限函数check来完成从 0、1 到true、false 的转换。<br/>check(string menutag) returns boolean<br/>string s_temp<br/>s_temp=mid(s_admin,integer(menutag),1)   //<a>s_admin</a>为全局变量<br/>if isnull(s_temp) or s_temp="1" then<br/> return true<br/>else<br/> return false<br/>end if<br/>假设w_main为登录后的主窗口，它的菜单为m_a<br/>则在w_main的open事件中这样写：<br/>m_a.m_h1.m_m1.enabled=check(m_a.m_h1.m_m1.tag)<br/>m_a.m_h1.m_m2.enabled=check(m_a.m_h1.m_m2.tag)<br/>m_a.m_h1.m_m3.enabled=check(m_a.m_h1.m_m3.tag)<br/>在w_1的open事件中：<br/>cb_1.enabled=check(cb_1.tag)<br/>同样，在w_2的open事件中<br/>cb_2.enabled=check(cb_2.tag)<br/>这样就可以完成对上述5项的控制。<br/>当然，这种方法在需要控制的项很多时（达到几十项）的效果才比较明显。<br/>以上论述了权限控制的实现，在多用户系统中，还需要有对用户权限的设置功能，这个和上面<br/>时一个相反的过程，相信读者在看完上面的内容之后一定会掌握权限设置的做法，这里就不再冗述了。<br/>以上是笔者在实际开发过程中的一点心得，欢迎与我交流探讨：<a href="mailto:netmuse@njai.edu.cn">netmuse@njai.edu.cn</a></p><p> </p><p> </p><p> </p><p> </p>                </div>                    </div>
11472	 关于WindowsInstaller服务出错解决方法收藏。	installer  windows  microsoft  杀毒软件  脚本  dll  	1076491860	38243	icuc88	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p><font size="2">方法一：</font></p><p><font size="2">卸载，重新安装windows installer服务 </font></p><p><font size="2">一、先用msiexec /unregserver 停掉windows installer服务。 <br/>二、下载InstMsiW.exe，用winrar解压开。进入目录。 <br/>三、右击msi.inf ，点击安装，右击mspatcha.inf ，点击安装。 <br/>四、再用msiexec.exe /regserver 启用服务。 </font></p><p><font size="2">方法二：</font></p><p><font size="2">1.如果曾安装过ACDSee5.0（包括迷你中文版），卸载它。如果还不行就重装Windows<br/>Installer 或者ACDSee 4.0<br/>2.运行cmd，然后运行sfc/scannow检查系统文件<br/>3.运行Services.msc，把Windows Installer 服务设置为手动运行，然后重新运行<br/>4.打开任务管理器，找到并结束ikernel.exe进程，重新安装<br/>5.禁用杀毒软件的实时防护<br/>6.删除 C:/Program Files/Common Files/InstallShield/Engine/6/Intel 32这个文<br/>件夹中的所有文件，然后重启动电脑，重新运行安装程序</font></p><p><font size="2">或者查看下面的网页：</font></p><p><font size="2">安装程序安装出错解决方法之葵花宝典    moonet（翻译）<br/></font><a href="http://www.csdn.net/develop/article/18/18184.shtm"><font size="2">http://www.csdn.net/develop/article/18/18184.shtm</font></a></p><p><br/><font size="2">方法三：</font></p><p><font size="2">这是由于一些软件制作的问题导致windows installer不能正常工作<br/>恢复步骤如下:</font></p><p><font size="2">1.再次安装windows installer2.0,运行instmsiw.exe<br/>如果说"服务已经安装"然后直接退出安装就再跟着做,否则你重装就OK了!</font></p><p><font size="2">2.删除注册表中的[HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services/MSIServer]<br/>然后运行instmsiw.exe</font></p><p><font size="2">3.绝招:<br/>(1) 删除msiserver 服务<br/>运行regedit，删除下面的MSIServer 服务<br/>[HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services/MSIServer]<br/>把下面的内容存为unmsiserver.reg 文件，然后双击左键，把它合并进注册表中<br/>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br/>;unmsiserver.reg<br/>Windows Registry Editor Version 5.00<br/>[-HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services/MSIServer]<br/>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</font></p><p><font size="2">(2) 删除msi 的文件<br/>用下面的脚本存为一个unmsi.inf文件，然后在inf文件上右键单击install，就会删除一些msi的dll，这时windows 的 sfc机制可能警告一些系统文件被修改要求插入win2k的光盘，不理睬它。这个脚本是我从instmsiw.exe中修改得来的。<br/>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br/>;unmsi.inf<br/>;;;;;;;;;;;;;;;;;<br/>[Version]<br/>signature = "$Windows NT$"<br/>Class = %ExceptionClassDesc%<br/>ClassGUID = {F5776D81-AE53-4935-8E84-B0B283D8BCEF}<br/>Provider = %Microsoft%<br/>CatalogFile = msi.cat<br/>ComponentId = {2E742517-5D48-4DBD-BF93-48FDCF36E634} ; GUID assigned to the Windows Installer<br/>DriverVer=03-13-2001, 2.0.2460.1</font></p><p><font size="2">[SourceDisksNames]<br/>1 = %msi_media%</font></p><p><font size="2">[SourceDisksFiles]<br/>msi.dll = 1<br/>msihnd.dll = 1<br/>msimsg.dll = 1<br/>msiexec.exe = 1<br/>msisip.dll = 1</font></p><p><font size="2">[DestinationDirs]<br/>Msi.SystemFiles = 11 ; %windir%/system32<br/>Msi.DllCacheFiles = 11,dllcache ; %windir%/system32/dllcache</font></p><p><font size="2">[DefaultInstall]<br/>DelFiles = Msi.SystemFiles,Msi.DllCacheFiles</font></p><p><font size="2">;<br/>; COPYFLG_REPLACE_BOOT_FILE flag (0x1000) not necessary for<br/>; files in the dllcache<br/>;</font></p><p><font size="2">[Msi.DllCacheFiles]<br/>msi.dll<br/>msihnd.dll<br/>msimsg.dll<br/>msiexec.exe<br/>msisip.dll</font></p><p><font size="2">[Msi.SystemFiles]<br/>msi.dll <br/>msihnd.dll <br/>msimsg.dll <br/>msiexec.exe <br/>msisip.dll </font></p><p><font size="2">[Strings]<br/>Microsoft = "Microsoft Corporation"<br/>msi_media = "Microsoft Windows Installer Distribution Media"<br/>ExceptionClassDesc = "Microsoft Windows Installer"<br/>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</font></p><p><font size="2">(3) 重新启动，按F8键，进入带命令行的安全模式，执行下面的命令<br/>regsvr32 /u %windir%/msi.dll<br/>del %windir%/msi.dll</font></p><p><font size="2">(4) 重启动，运行instmsiw.exe，安装windows installer2.0 ,一切正常了。</font></p><p><font size="2"></font> </p><p> </p>                </div>                    </div>
11476	 WindowsServer2003常见问题（二）	windows  server  terminal  licensing  express  service  	1077015540	2577	icuc88	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <table border="0" cellpadding="0" id="table107" style="border-collapse:collapse;" width="100%"><tbody><tr><td bgcolor="#9ccfff"><p class="font3"><font color="#3366cc" face="Verdana"><b><span style="font-size:9pt;"><a></a>5</span></b></font><b><font face="Verdana"><span style="font-size:9pt;color:#3366cc;">. </span></font><font color="#008000" face="Verdana"><a href="http://support.microsoft.com/default.aspx?scid=%2Fdirectory%2Fworldwide%2Fzh-tw%2Ffaq%2F7803.asp#4" style="text-decoration:none;"><font color="#3366cc" style="font-size:9pt;">如何在Windows 2000網域上指定已安裝Windows Server 2003 Terminal licensing成員伺服器</font></a></font><font color="#3366cc" face="Verdana" style="font-size:9pt;">？</font></b></p></td><td style='background-image:url("/directory/worldwide/zh-tw/images/bw.gif");' width="125"><p class="font3">　</p></td></tr></tbody></table><table border="0" id="table108" style="border-collapse:collapse;" width="100%"><tbody><tr><td><p class="font3"><font color="#0000ff" face="Verdana" style="font-size:9pt;"><b><br/></b></font><font face="Verdana" style="font-size:9pt;">1.在Windows 2000 Terminal Server點選【開始】/【執行】，鍵入"regedit"後按【確定】<br/>2. 請選至下述機碼位置：<br/><br/>HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services/TermService/Paramet<br/>ersNOTE<br/><br/>3. 在工具列上的【編輯】/【新增】/【機碼】。<br/>4. 命名此新機碼為"LicenseServers"，並修改值為&lt;ServerName&gt;(不含中括號)，此ServerName是指Winodows Server 2003 Terminal licensing Server的IP位址或NetBIOS Name。</font></p><p class="font3"><font face="Verdana" style="font-size:9pt;"><a href="http://support.microsoft.com/default.aspx?scid=%2Fdirectory%2Fworldwide%2Fzh-tw%2Ffaq%2F7803.asp#top"></a></font></p></td></tr></tbody></table><table border="0" cellpadding="0" id="table109" style="border-collapse:collapse;" width="100%"><tbody><tr><td bgcolor="#9ccfff"><p class="font3"><font color="#3366cc" face="Verdana"><b><span style="font-size:9pt;"><a></a>6</span></b></font><b><font face="Verdana"><span style="font-size:9pt;color:#3366cc;">. </span></font><font color="#3366cc" face="Verdana" style="font-size:9pt;">為何我的Outlook Express無法驗證Windows Server 2003 POP3 service?</font></b></p></td><td style='background-image:url("/directory/worldwide/zh-tw/images/bw.gif");' width="125"><p class="font3">　</p></td></tr></tbody></table><table border="0" id="table110" style="border-collapse:collapse;" width="100%"><tbody><tr><td><p class="font3"><font face="Verdana" style="font-size:9pt;"><br/>1.設定 Outlook Express 用於電子郵件服務。<br/>2.按一下 【開始】，指向【[所有程式】，然後按一下【[Outlook Express】。<br/>3.在 【工具】 功能表上按一下 【帳戶】。 <br/>4.按一下【[新增】，再按【[郵件】。 <br/>5.遵循 【網際網路連線精靈】中的指示，直到進入 【網際網路郵件登入】頁面。<br/>6.在 【帳戶名稱】 中，輸入您的 POP3 服務使用者名稱，並在後面加上網域名稱，例如 <a href="mailto:someone@example.com">someone@example.com</a>。 <br/>7.在 【密碼】中，輸入與您的 POP3 服務電子郵件帳戶關聯的密碼。 <br/>8.如果您的郵件伺服器已設為需要 SPA，請選取 【使用安全密碼驗證登入 (SPA)】，然後再完成精靈的工作。</font></p><p class="font3">　 </p><p class="font3"><font face="Verdana" style="font-size:9pt;"><a href="http://support.microsoft.com/default.aspx?scid=%2Fdirectory%2Fworldwide%2Fzh-tw%2Ffaq%2F7803.asp#top"></a></font></p></td></tr></tbody></table><table border="0" cellpadding="0" id="table111" style="border-collapse:collapse;" width="100%"><tbody><tr><td bgcolor="#9ccfff"><p class="font3"><font color="#3366cc" face="Verdana"><b><span style="font-size:9pt;"><a></a>7</span></b></font><b><font face="Verdana"><span style="font-size:9pt;color:#3366cc;">. </span></font><font color="#3366cc" face="Verdana" style="font-size:9pt;">預設的Users群組無法使用Terminal登入Windows Server 2003 Terminal Service？</font></b></p></td><td style='background-image:url("/directory/worldwide/zh-tw/images/bw.gif");' width="125"><p class="font3">　</p></td></tr></tbody></table><table border="0" id="table112" style="border-collapse:collapse;" width="100%"><tbody><tr><td><p class="font3"><font face="Verdana" style="font-size:9pt;"><br/>預設上Users群組的成員是不允許使用Terminal登入Terminal Service 2003的機器上，但若您希望所有的使用者皆可使用Terminal的服務，請將Authenticated Users加入"Remote desktop users"群組即可。<br/>或也可直接使用批次檔執行下述內容即可讓一般使用者可利用Terminal登入。<br/><br/>批次檔內容：<br/></font><b><font color="#008000" face="Verdana" style="font-size:9pt;"><br/></font></b><font face="Verdana" style="font-size:9pt;">Net localgroup "remote desktop users" "authenticated users" /add<a href="http://support.microsoft.com/default.aspx?scid=%2Fdirectory%2Fworldwide%2Fzh-tw%2Ffaq%2F7803.asp#top"></a></font></p></td></tr></tbody></table><table border="0" cellpadding="0" id="table113" style="border-collapse:collapse;" width="100%"><tbody><tr><td bgcolor="#9ccfff"><p class="font3"><font face="Verdana" style="font-size:9pt;"><b><span style="color:#3366cc;"><a></a>8. </span></b></font><font color="#3366cc" face="Verdana" style="font-size:9pt;"><b>如何安裝遠端桌面網站連線？</b></font></p></td><td style='background-image:url("/directory/worldwide/zh-tw/images/bw.gif");' width="125"><p class="font3">　</p></td></tr></tbody></table><table border="0" id="table114" style="border-collapse:collapse;" width="100%"><tbody><tr><td><p class="font3"><font face="Verdana" style="font-size:9pt;"><br/>1.安裝遠端桌面網站連線。<br/>2.開啟 【控制台】 中的 【新增或移除程式】。 <br/>3.按一下 【新增/移除 Windows 元件】。 <br/>4.按一下 【Application Server】，再按 【詳細資料】。 <br/>5.選取【[網際網路資訊服務 (IIS)】，再按 【詳細資料】。 <br/>6.在 【網際網路資訊服務 (IIS)】 的子元件清單中，選取 【全球資訊網服務】，再按【[詳細資料】。 <br/>7.在 【全球資訊網服務】 的子元件清單中，按一下 【遠端桌面網站連線】 核取方塊。按一下 【確定】，再按一下 【確定】，然後按第三次 【確定】。 <br/>8.在【[Windows 元件精靈】 中按一下 【下一步】。 <br/>9.確認有在【[連線類型:】 方塊中勾選 RDP-Tcp 連線。然後按一【下一步】，開始安裝 【遠端桌面網站連線】。<br/><a href="http://support.microsoft.com/default.aspx?scid=%2Fdirectory%2Fworldwide%2Fzh-tw%2Ffaq%2F7803.asp#top"></a></font></p></td></tr></tbody></table><table border="0" cellpadding="0" id="table115" style="border-collapse:collapse;" width="100%"><tbody><tr><td bgcolor="#9ccfff"><p class="font3"><font face="Verdana" style="font-size:9pt;"><font color="#3366cc"><b><a></a>9</b></font><b><span style="color:#3366cc;">. </span></b></font><font color="#3366cc" face="Verdana" style="font-size:9pt;"><b>在Windows 2000網域中升級Windows Server 2003為網域控制站時發生錯誤？</b></font></p></td><td style='background-image:url("/directory/worldwide/zh-tw/images/bw.gif");' width="125"><p class="font3">　</p></td></tr></tbody></table><table border="0" id="table116" style="border-collapse:collapse;" width="100%"><tbody><tr><td><p class="font3"><font face="Verdana" style="font-size:9pt;"><br/>在包含 Windows 2000 網域控制站的網域上準備升級<br/><br/>1.執行此程序之前，建議您先在執行 Windows 2000 的所有網域控制站上套用 Service Pack 2 或更新的版本。<br/>2.找出作為架構主機的伺服器以及作為基礎結構主機的伺服器 (兩者可能是同一部伺服器)。<br/>3.備份架構主機。您也可以備份其他伺服器，作為升級準備動作的一部份，但請在進行下一個步驟之前才備份架構主機。 <br/>4.中斷架構主機與網路的連線，一直到完成本所有程序之後再重新建立。 <br/>5.在架構主機上，當 Windows 2000 正在執行時，插入 Windows Server 2003, Enterprise Edition 安裝 CD 到光碟機中。 <br/>6.開啟命令提示字元，切換至光碟機，再切換至 CD 上的 /i386 資料夾。 <br/>7.在架構主機上，於命令提示下鍵入 </font></p><p><font face="Verdana" style="font-size:9pt;">adprep /forestprep<br/><br/>8.若架構主機與基礎結構主機分屬兩部不同的電腦，請稍候片刻，讓 adprep /forestprep 將架構主機的變更複寫到基礎結構主機上。您至少要等候 15 分鐘，但若架構主機與基礎結構主機位於不同的站台上，時間可能要更長 (半天至一天)。若試圖在變更複寫完成之前執行基礎結構主機的網域準備工作，Adprep 將出現錯誤訊息，通知您再等候一下。 <br/><a href="http://support.microsoft.com/default.aspx?scid=%2Fdirectory%2Fworldwide%2Fzh-tw%2Ffaq%2F7803.asp#top"></a></font></p></td></tr></tbody></table><table border="0" cellpadding="0" id="table117" style="border-collapse:collapse;" width="100%"><tbody><tr><td bgcolor="#9ccfff"><p class="font3"><font color="#3366cc" face="Verdana" style="font-size:9pt;"><b><a></a></b></font><font face="Verdana" style="font-size:9pt;"><font color="#3366cc"><b>10</b></font><b><span style="color:#3366cc;">. </span></b></font><font color="#3366cc" face="Verdana" style="font-size:9pt;"><b>如何控制終端機伺服器授權的發行？</b></font></p></td><td style='background-image:url("/directory/worldwide/zh-tw/images/bw.gif");' width="125"><p class="font3">　</p></td></tr></tbody></table><table border="0" id="table118" style="border-collapse:collapse;" width="100%"><tbody><tr><td><p class="font3"><font face="Verdana" style="font-size:9pt;"><br/>1.開啟 【群組原則】。 <br/>2.在 【電腦設定】、【系統管理範本]、【Windows 元件】、【終端機服務】、【授權】 中，連按二下 【授權伺服器安全性群組】 設定。 <br/>3.按一下 【已啟用】，再按一下 【確定】。 <br/><br/>註：<br/>若要執行此程序，您必須是本機電腦上的 Administrators 群組成員，或您必須有被委派適當授權。如果電腦加入網域，那麼 Domain Admins 群組的成員可以執行此程序。 <br/>如果此設定的狀態為 [已啟用]，只有您新增到終端機服務電腦安全性群組的電腦會收到授權。預設不會匯入此群組。如果您要這些電腦或群組接收授權，便必須將這些電腦或群組新增到此安全性群組中。對此群組的成員資格所作的任何變更，僅在停止並重新啟動 [終端機伺服器授權] 服務之後才會生效。<br/>如果此設定的狀態既不是 [已停用]，也不是 [尚未設定]，則終端機伺服器授權伺服器會將授權發行給提出要求的任何電腦。[終端機服務電腦] 群組無法以任何方式刪除或變更。此為預設行為。 <br/>使用上述程序可以設定本機「群組原則」物件。若要變更網域或組織單位的原則，您必須使用 Administrator 身分登入網域主控站。然後，您必須透過 [Active Directory 使用者及電腦] 嵌入式管理單元來啟動「群組原則」。</font></p><p class="font3"><font face="Verdana" style="font-size:9pt;"><br/><a href="http://support.microsoft.com/default.aspx?scid=%2Fdirectory%2Fworldwide%2Fzh-tw%2Ffaq%2F7803.asp#top"></a></font></p></td></tr></tbody></table>                </div>                    </div>
11771	 巧用CSS制作树状目录	css  div  javascript  	997680660	774	small_pig	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p>索易电子杂志大多采用树状目录，当鼠标点击主目录时，展开子目录；当再次点击主目录时，则关闭子目录。显得简捷明快，朴实无华。制作这种树状目录的方法较多，最近我利用CSS能方便地控制对象的“显示”和“隐藏”属性原理，也制作一个，我感到用CSS制作这样的树状目录，方法简单，代码也比较少，所以把它写出来，给网友们共亨，以便在需要的时候也可动手做一个。先看下面的示例：当用鼠标在主目录上点一下，就下拉出相应的子目录，再点一下，又恢复原状，其效果与索易电子杂志上的目录效果完全一致。</p><p>　　鼠标点击前的目录</p><p>　　鼠标点击后展开的目录</p><p>　　制作方法：<br/>　　我先把产生这种效果的代码复制如下，然后结合代码讲制作方法：<br/>〈div id="main1" style="color:blue" onclick="document.all.child1.style.display=(document.all.child1.style.display =='none')?'':'none'" 〉<br/>+ 主目录1〈/div〉<br/>〈div id="child1" style="display:none"〉<br/>〈a href="#"〉- 子目录1〈/a〉 〈br〉<br/>〈a href="#"〉- 子目录2〈/a〉 〈br〉<br/>〈a href="#"〉- 子目录3〈/a〉 〈br〉<br/>〈a href="#"〉- 子目录4〈/a〉 <br/>〈/div〉<br/>〈div id="main2" style="color:blue" onclick="document.all.child2.style.display=(document.all.child2.style.display =='none')?'':'none'" 〉<br/>+ 主目录2 〈/div〉<br/>〈div id="child2" style="display:none"〉 <br/>〈a href="#"〉- 子目录1〈/a〉 〈br〉 <br/>〈a href="#"〉- 子目录2〈/a〉 〈br〉<br/>〈a href="#"〉- 子目录3〈/a〉 <br/>〈/div〉<br/>　　注：“ ”表示一个字符空格<br/>　　1、先定义两个DIV，一个用于主目录，取名为：main1；另一个用于相应的子目录，取名为：child1。　　2、在main1的DIV中写上“+ 主目录1”，并在它的上面加载一个鼠标单击事件：onclick 和一小段Javascript程序：document.all.child1.style.display=(document.all.child1.style.display =='none')?'':'none'。这段程序的作用是，当鼠标在main1的DIV上（也就是在“+ 主目录1”上）单击时，如果child1的DIV是隐藏的，让它显示；若是显示的，则让它隐藏。<br/>　　3、在child1的DIV上写上子目录，并把它设置成超级链接，我在上面的示例中是设置了空链接，实际制作时把它改为实链接，以让它指向链接目标。在child1的DIV定义中加上一个CSS：style="display:none"，其目的是使子目录开始时处于隐藏状态。<br/>　　其它目录的制作只是重复上面的三步而已。按F12就可看到效果了。这种方法主要是利用了CSS的显示属性：display，它有一个特点就是当对象被隐藏后，对象所占据的页面空间将自动让出。我们知道CSS还一个属性：visibility也具有显示和隐藏的对象的功能，但不能用来制作上面的树状目录。因为Visibility在隐藏对象后，对象所占据的空间并不释放，也就是当隐藏子目录时，子目录的位置只是一片空白而已位置并没有让出来，因此另一个主目录也就无法靠拢。所以它只能用于那些需要固定页面元素位置的地方。<br/></p>                </div>                    </div>
11918	 VB中删除、替换或者插入内容到文本中某一行,及文本行列的处理实例	vb  integer  string  kill  command  	1074304320	2419	SoHo_Andy	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p><strong><font size="5">VB中删除、替换或者插入内容到文本中某一行</font></strong></p><p><strong><font size="5">及解析文本行列的处理实例</font></strong>      </p><p>     VB操作文本文件的方法很多,下面的例子是我自己作项目或者回答网友提问时做的,很有代表性,希望能够给各位朋友一些启发.</p><p>'功能：删除、替换文本中一行，或者插入内容到文本中某一行<br/>'作者: soho_andy (冰)<br/>'参数：<br/>'strSourceFile  原始文件完整名<br/>'strTargetFile  生成新文件的完整名<br/>'intRow         操作的行数</p><p>Sub 操作文件中一行(strSourceFile As String, strTargetFile As String, intRow As Long)<br/>    Dim filenum         As Integer<br/>    Dim fileContents    As String<br/>    Dim fileInfo()      As String<br/>    Dim i               As Integer<br/>    Dim j               As Integer<br/>    <br/>    filenum = FreeFile<br/>    Open strSourceFile For Binary As #filenum<br/>        fileContents = Space(LOF(filenum))<br/>        Get #filenum, , fileContents<br/>    Close filenum<br/>    fileInfo = Split(fileContents, vbCrLf)<br/>    '取出源文件行数，按照回车换行来分隔成数组<br/>    <br/>    filenum = FreeFile<br/>    If Dir(strTargetFile, vbNormal) &lt;&gt; "" Then<br/>        Kill strTargetFile<br/>    End If<br/>    Dim Filestr() As String<br/>    <br/>    '删除一行代码块<br/>    Open strTargetFile For Append As #filenum<br/>        '循环每一行<br/>        For i = 0 To UBound(fileInfo) - 1<br/>            If i &lt;&gt; intRow - 1 Then<br/>                Print #filenum, fileInfo(i)<br/>            End If<br/>        Next<br/>    Close #filenum<br/>    <br/>    '替换一行代码块<br/>    Open strTargetFile For Append As #filenum<br/>        '循环每一行<br/>        For i = 0 To UBound(fileInfo) - 1<br/>            If i = intRow - 1 Then<br/>                Print #filenum, "你要替换进去的内容"<br/>            End If<br/>        Next<br/>    Close #filenum<br/>    <br/>    '插入一行代码块<br/>    Open strTargetFile For Append As #filenum<br/>        '循环每一行<br/>        For i = 0 To UBound(fileInfo) - 1<br/>            If i = intRow - 1 Then<br/>                Print #filenum, "你要插入到这行的内容"<br/>                Print #filenum, fileInfo(i)           '保留原来的行，位置后移一位<br/>            End If<br/>        Next<br/>    Close #filenum<br/>    <br/>    <br/>    MsgBox "完毕"<br/>End Sub</p><p>'另外一个解决实际问题的例子<br/>'<br/>'网友的要求<br/>'设有文件a.txt，其中存放了两行数据，数据用逗号分隔，现在要读取第一行的奇数位置的数据写入到另一个文本文件（b.txt）的第一行，类似地，把第二行的奇数位置的数据写入到第二行。<br/>'比如:<br/>'文件a.txt如下:<br/>'1，2，3，4，5<br/>'6，7，8，9，10<br/>'操作完成后，文件b.txt应为<br/>'1,3,5<br/>'6,8,10</p><p>'作者: soho_andy (冰)<br/>'参数：<br/>'strSourceFile  原始文件完整名<br/>'strTargetFile  生成新文件的完整名</p><p>Sub 提取奇数位数据(strSourceFile As String, strTargetFile As String)<br/>    Dim filenum         As Integer<br/>    Dim fileContents    As String<br/>    Dim fileInfo()      As String<br/>    Dim i               As Integer<br/>    Dim j               As Integer<br/>    <br/>    Dim tmpDemData As String<br/>    filenum = FreeFile<br/>    Open strSourceFile For Binary As #filenum<br/>        fileContents = Space(LOF(filenum))<br/>        Get #filenum, , fileContents<br/>    Close filenum<br/>    fileInfo = Split(fileContents, vbCrLf)<br/>    '取出源文件行数，按照回车换行来分隔成数组<br/>    <br/>    filenum = FreeFile<br/>    tmpDemData = ""<br/>    If Dir(strTargetFile, vbNormal) &lt;&gt; "" Then<br/>        Kill strTargetFile<br/>    End If<br/>    Dim Filestr() As String</p><p>    Open strTargetFile For Append As #filenum<br/>        '循环每一行<br/>        For i = 0 To UBound(fileInfo) - 1<br/>            Filestr = Split(Trim(fileInfo(i)), ",")  '按照逗号分隔每一行的数据<br/>            tmpDemData = ""<br/>            For j = 0 To UBound(Filestr)<br/>                '判断是否为奇数位<br/>                If (j Mod 2) = 0 Then<br/>                    tmpDemData = tmpDemData &amp; Filestr(j)<br/>                ElseIf j &lt;&gt; 0 And j &lt;&gt; UBound(Filestr) Then<br/>                    tmpDemData = tmpDemData &amp; ","<br/>                End If<br/>            Next<br/>            '保存一行如目标文件<br/>            Print #filenum, tmpDemData<br/>        Next<br/>    Close #filenum<br/>    MsgBox "完毕"<br/>End Sub</p><p>Private Sub Command1_Click()<br/>    提取奇数位数据 "d:/aa.txt", "d:/bb.txt"<br/>End Sub</p><p> </p>                </div>                    </div>
12083	 利用API函数实现图像淡入淡出效果	api  timer  byte  command  vb  编程  	1000112040	1081	firetoucher	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        利用API函数实现图像淡入淡出效果<br/>    一般传统的实现两个PictureBox之间图像的淡入淡出效果都需要使用大量的API函数并进行复杂的调色板以及<br/>绘图设备(Device Context)的操作。但是在Win98、Win2000中，微软提供了支持透明图像拷贝的AlphaBlend函数。<br/>这篇文章就介绍如何通过API函数AlphaBlend实现PictureBox之间图像的淡入淡出效果。AlphaBlend函数的定义在<br/>msimg32.dll中，一般Win98、Win2000都带了这个库，在编程之前你可以先察看一下该文件是否存在。<br/>    打开VB建立一个新工程。选择菜单 Project | Add Module 添加一个模块到工程中，在其中输入以下代码：<br/><br/>Public Type rBlendProps<br/>    tBlendOp As Byte<br/>    tBlendOptions As Byte<br/>    tBlendAmount As Byte<br/>    tAlphaType As Byte<br/>End Type<br/><br/>Public Declare Function AlphaBlend Lib "msimg32" (ByVal hDestDC As Long, _<br/>        ByVal x As Long, ByVal y As Long, ByVal nWidth As Long, _<br/>        ByVal nHeight As Long, ByVal hSrcDC As Long, _<br/>        ByVal xSrc As Long, ByVal ySrc As Long, ByVal widthSrc As Long, _<br/>        ByVal heightSrc As Long, ByVal blendFunct As Long) As Boolean<br/><br/>Public Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" _<br/>        (Destination As Any, Source As Any, ByVal Length As Long)<br/><br/>    大家可以看到，AlphaBlend函数的定义同普通的复制函数Bitblt很相似，只是最后的参数blendFunct定义为一个<br/>rBlendProps结构。那么为什么在函数定义中blendFunct 定义为Long类型呢？因为rBlendProps结构长度是4个字节。<br/>而Long类型变量的长度也是4个字节，那么我们就可以程序中通过API函数CopyMemory将一个rBlendProps结构拷贝到<br/>blendFunct 中。<br/><br/>    在Form1中添加两个PictureBox控件，其中Picture2为源，Picture1为拷贝目标，将两者的ScaleMode都设置为3-Pixel<br/>将两者的AutoRedraw属性都设置为True，然后分别添加图像。在加入一个Timer控件以及一个CommandButton控件，然后<br/>在Form1的代码窗口中添加如下代码：<br/><br/>Dim lTime As Byte<br/><br/>Sub ShowTransparency(cSrc As PictureBox, cDest As PictureBox, _<br/>    ByVal nLevel As Byte)<br/>    Dim LrProps As rBlendProps<br/>    Dim LnBlendPtr As Long<br/>    <br/>    cDest.Cls<br/>    LrProps.tBlendAmount = nLevel<br/>    CopyMemory LnBlendPtr, LrProps, 4<br/>    With cSrc<br/>        AlphaBlend cDest.hDC, 0, 0, .ScaleWidth, .ScaleHeight, _<br/>            .hDC, 0, 0, .ScaleWidth, .ScaleHeight, LnBlendPtr<br/>    End With<br/>    cDest.Refresh<br/>End Sub<br/><br/>Private Sub Command1_Click()   <br/>    lTime = 0<br/>    Timer1.Interval = 100<br/>    Timer1.Enabled = True<br/>End Sub<br/><br/><br/>Private Sub Timer1_Timer()<br/>    lTime = lTime + 1<br/>    ShowTransparency Picture2, Picture1, lTime<br/>    If lTime &gt;= 255 Then<br/>        Timer1.Enabled = False<br/>    End If<br/>    Me.Caption = Str(Int(lTime / 2.55)) + "%"<br/>End Sub<br/><br/>    运行程序，点击Command1，就可以看到Picture2图像拷贝到Picture1上的淡入淡出效果了。<br/>    在结构rBlendProps中，最重要的参数就是tBlendAmount，该值决定了源与目标之间的透明程序。如果为0的话，源完全<br/>透明，如果为255的话，源完全覆盖目标。<br/>    另外AlphaBlend 函数不只用于两个PictureBox之间的拷贝，而且可以在两个Device Context之间的透明拷贝，也就是<br/>说，象窗口等控件之间也可以实现透明效果。不过在编程过程中发现一个问题，不知是否是AlphaBlend的Bug，就是在我写完<br/>程序后，并没有出现透明复制的效果。搞的我以为该函数不起作用，但是当我再打开VB运行上面的程序后，一切有正常了。<br/>我在MSDN上也没有找到相关的Bug列表。<br/>                </div>                    </div>
12093	 GRE计算机专项考试题（96）	buffer  多线程  translation  insert  pascal  reference  	1000273260	1973	firetoucher	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p>根据回忆录入，不好意思，有些csdn的文档中心不兼容。</p><p> </p><p> </p><p> 1. <br/>求f<br/>    </p><p> For I=1 to n<br/>A[I]=a[n+1-I]<br/> 求循环后数组值，每个数都有两个拷贝</p><p>什么叫amdahl（字迹模糊，不确定）法则<br/>Amdahl法则</p><p>在计算机编程的并行处理程序中，少数必需顺序执行的指令是影响性能的一个要素，即使增加新的处理器也不能改善运行速度。这就是Amdahl法则。有人正是在这一点上对并行处理提出了挑战。一部分人认为，并行处理擅长的是那些增加处理器个数就能提高吞吐量和性能的大问题。 </p><p>判断是否<br/>NP<br/>判断C、D等价<br/>判断C是否存在输入使之输入为真<br/>判断C可缩减（是否已经最小化）<br/>        均为NP<br/>RSA是基于整数分解的什么性质：<br/>假如存在整数分解的更好法则，则此方法的安全性下降。(√)<br/>该方法基于一个未被证明的基础：RSA的强度等价于大数分解。<br/>该方法基于整数分解及逆运算的运算量的差别。</p><p>牛顿迭代有效数字位数的增加速度。<br/>给出牛顿公式：……….<br/>每次增加一位<br/>每次增加2位<br/>每次double?  如xn-a=0.001,则xn＋1-a=0.00001(√)</p><p>S→A<br/>A→AA|0<br/>问00000有多少种分析树<br/>   I. 10  II. 14  III. 24  IV.72</p><p>下面哪个不是线性计算的<br/>求连通子图<br/>求双连通子图<br/>求单源点最短路径<br/>求各定点的度<br/>求生成森林</p><p>那些是多线程特点<br/>自己的栈与上下文<br/>自己的地址空间<br/>共享文件与数据</p><p>哪些是专家系统的推理方法<br/>由已知的结论推出事实（向后推）<br/>由已知事实推出结论（向前推）<br/>由已知结论，由用户给出事实，推出矛盾或已知事实。<br/>(II III)</p><p>多线程要调用函数fill填充一块buffer，返回指向buffer的指针，fill放在临界区中，问下面哪个可以保证互斥。 <br/>Buffer是全局变量。<br/>Buffer是调用者的局部变量，把buffer的指针传给fill。<br/>Buffer是filll的局部变量，返回指向buffer的指针。<br/>RISC指令定长:  |opcode|RA|RB|offset|<br/>RA←(RB+offset)<br/> 寄存器数加一倍后，问寻址空间的大小的变化。<br/> I. ×4  II. ×2   III. 不变  IV. 除2  V. 除4</p><p>调用者或被调用者都要保存的寄存器<br/>在RISC机中，保存寄存器值可由调用者或被调用者保存，问下面程序中，哪个寄存器在这两种方法中都被保存。</p><p>给出数学公式，问下面5段程序的哪段符合功能。</p><p>a[i]=(i2+1) mod n<br/>x=seed; y=x; seed是初值<br/>do<br/>  x=a[i];y=a[a[y]]<br/>while x!=y<br/>问<br/>I) 始终中止（√）  II) 和n及seed有关   III) 之和n有关</p><p>问哪个与log n同阶<br/>T[n]=T[n/2]+1<br/> <br/>T[n]=T[n/2]+log n</p><p>RAW读后写，哪个会产生I写数据然后了读<br/>WAW<br/>WAR<br/>流水线机没有数据直接通路（Data forward）<br/>问哪种情况需要停机等待</p><p>流水线在何时检测中断<br/>每个时钟周期<br/>流水线为空<br/>每个转移指令发生的时候</p><p>7个处理器每个可以和相邻元交换，问排序的best lesser live（任何排序方法）最好情况<br/>a) 2  b)3   c)  6  (√)  d) 24 e)42</p><p>Hash线性探测，函数是 i mod 10<br/>给17  28<br/>添Hash表</p><p> 何时为真<br/>当且仅当其中两个变量为真时，为真。</p><p>C++抽象基类，问哪个是不对的（虚基类和抽象类不一样）<br/>Virtual center () = 1/2*( L()+R())<br/>Virtual int L()=…..<br/>Virtual int R()=…<br/>   U()=…<br/>   D()=…<br/>I) 不能生成实例  II)  它的继承类必须保持center的行为。<br/>它的继承类必须定义L….</p><p>Knapsack问题（背包问题）<br/>I）这函数不满足前后断言 II) 满足而且是多项式时间<br/>III) 满足且为指数时间  IV) 此程序不终止</p><p>Krusal是哪种算法的一种<br/>I) 贪心  II） 分枝界限 IV) 二分法</p><p>n(5/4)、nlog n,  n*e16<br/> <br/>哪个增长最慢</p><p>call by value,(考传值)求程序结果<br/>12  3</p><p>call by reference（考引用），求程序结果<br/>31+3</p><p>A=0m1n(m小于等于n), B=0m1n(m大于等于n), B→0B<br/>A＋B是正则的<br/>A∩B是上下文无关的<br/>A，B都是正则的。</p><p>{XX|X∈L}是否也∈L<br/>L是正则<br/>L是上下文无关<br/>L是递推可枚举</p><p> not true (不全，五个选择)<br/>a和b正则，则a∩b正则<br/>a和b上下文无关，则a∩b上下文无关</p><p><br/>若A可数则B可数，若A有限则B有限<br/>若B可数则A可数，若B有限则A有限</p><p>冒泡排序，1……i,排序到i,问A[i]与A[i+1]交换的概率。<br/>a) 1/2  b) i/(i+1)  c) 1/n  d) n/2</p><p>多线程系统如UNIX,NT,VMX,哪些依靠中断<br/>I/O<br/>任务切换<br/>缺页</p><p>缺页的块数比  TLB   缺页   的少（不全）<br/> Translation Lookaside buffer<br/>page fault比cahe missing 少<br/>page fault比TLB missing少</p><p>页表在虚存里，地址转换时最大缺页次数<br/>不缺页<br/>一次<br/>两次<br/>三次<br/>三次以上</p><p>问下列哪个不能用以上形式表示， 表示浮点数  S|E|F<br/>(-1)s(1.F)2e-127<br/>   a) 100   b) 15.5  c) 0.1  d)0.25  e)0.0625</p><p> -14.5   1|1010|1101<br/>把以上浮点数代入数学公式求值</p><p>哪个相对误差大<br/>A*A+B+C   b) A*A-B*C   c) A*A*(B+C)  d) A*A/B*C<br/>SQRT(A*A+B*C)</p><p>链表的两种实现<br/>  两种插入  每插入一个就排序<br/>    把插入的放在一个临时队列里，查找时用merge，再与原来的队列归并。<br/>有n个元素，插入m个元素，最后查找一次，问时间复杂度。<br/>O(m(n+m))</p><p>题同上。问第二种插入法的时间复杂度<br/>O(m+n)log(m+n)<br/>O(m(log(m+n))</p><p>给了两串数列，问第二个数列是第一个数列哪种排序的中间结果。</p><p>表示通用信号灯最少用几个二值信号灯。（n值）<br/>I) log2n II) n  III) n2 IV) n!</p><p>问哪个x是一直被正确加1, P,V均为二值信号灯<br/>（P   X=X+1 V）</p><p>求Feb数列f-f1+t执行的次数<br/>问递归的次数  O(n)</p><p>接上题   f跟n的关系<br/>cn  b) n2</p><p>  main<br/>  P<br/>  Var x<br/>  R<br/>End   {p}<br/>Q<br/>考Pascal调用的嵌套关系。</p><p>接上题   用静态指针要dereference多少次（考静态链）</p><p>完成功能insert(**p X)  C++程序  问哪个错</p><p>利用内存引用技术  废物收集，想完成P=Q、P、Q均为指针<br/>引用什的<br/>（P的引用技术，Q的引用技术＋1）</p><p>长度为5 的有几种<br/> </p><p><br/>接上题  长度为2n+1的有多少种<br/>（指数）</p><p>一个自动机，给出状态转换表。有一个未知状态，要识别一个字符串，问<br/>输入0,转到哪个状态。</p><p>设n&gt;2的有限自动机所接收的最小长度字长度。<br/>i) 1  ii)  1&lt;  &lt;n  iii)  &gt;n   &lt;2n-1  iv)  2n&lt;   &lt;n2</p><p>insert , delete , find<br/>问哪种数据类型实现这三种最快<br/>平衡二叉树</p><p>  E→E*E   E→(E)<br/> E→E+E   算符优先<br/>问以下哪个不对<br/>E*E  *  shift</p><p> "×(P(x)ÇQ(x))与哪个等价<br/>~X(~P(x)È~Q(X))<br/>"×  P(x) Ç Q(x)<br/>"×"y   (P(x) Ç Q(y))</p><p>二叉树，问最少节点数<br/>L是叶子数，S为有单孩子的结点数<br/>            F为有双孩子的节点数<br/>2L－1</p><p>哪个正确<br/>2L-1=</p><p><br/>全对</p><p>E®    FÉE|T<br/>F®<br/>T®not T     问哪个对<br/>I   not左结合<br/>II  É优先级低于not<br/>III  É右结合</p><p>Page变大会导致<br/>内部碎片少<br/>页表entry变少<br/>保护粒度粗</p><p>f(x,y)+f(x,y)使计算时间减半，可以采用以下什么编译优化算法<br/>（消除子表达式）<br/> 选择有   拷贝传播，代码外提等</p><p>动态类型检查，静态类型检查<br/>编译时间长，动态执行时间长<br/>静态全部检查<br/>静态代码长，动态代码短</p><p>  3种操作使P指向R<br/>int  *P<br/>int **Q=&amp;P<br/>int R<br/>*P=R<br/>*Q=&amp;R<br/>Q=*P</p><p>调用必须做的事<br/>保存程序计数器<br/>屏蔽中断<br/>保存寄存器</p><p>  a(b*c)*  不能推出<br/> bb</p><p>以0 1开头and/or 以01结尾有多少种，长度是10的字符串个数</p><p>a和b之差是17 的整数倍<br/>这一关系符合<br/>I) 自反  II)对称  III）传递</p><p>slice   A[100,50] 求A[i,7] （在二维数组中的序号）的地址<br/>address(A[i,j]  -50+50j</p><p>临界区可用于<br/>I/O设备<br/>共享内存</p><p>下面哪个不能加快流水线<br/>展开循环<br/>将程序改为过程调用</p><p> </p>                </div>                    </div>
12111	 LMDS拓宽“最后一公里”	网络  电话  internet  工作  电信  终端  	1019438940	1296	yang_b_f	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                         <p class="MsoNormal" style="margin-left:15.75pt;text-indent:-15.75pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">1．<span style="font:7pt 'Times New Roman';">  </span></span><span style="font-size:12pt;font-family:'黑体';">引言<span lang="en-us" xml:lang="en-us">&lt;?xml:namespace prefix = o ns = "urn:schemas-microsoft-com:office:office" /&gt;</span></span></p><p></p><p class="MsoNormal" style="text-indent:21pt;"><span style="font-family:'宋体';">随着</span><span lang="en-us" xml:lang="en-us">Internet</span><span style="font-family:'宋体';">的高速普及与多媒体技术的飞速发展，用户对带宽的要求越来越高。目前各国的核心网络建设均初具规模，以光缆为主体的主干通信网基本可满足当前通信的需求。而突出的矛盾体现在接入网方面，即用户与核心网络的连接部分。理论上，全光纤接入网络将是比较完美的解决方案。然而，全光纤接入实现上对接入网络的要求过高，即使在发达国家也还远远未能实现。目前只能做到光纤到路边</span><span lang="en-us" xml:lang="en-us">(FTTC)</span><span style="font-family:'宋体';">或者光纤到大楼（</span><span lang="en-us" xml:lang="en-us">FTTF</span><span style="font-family:'宋体';">），并且</span><span lang="en-us" xml:lang="en-us">FTTF</span><span style="font-family:'宋体';">也只是很小的一部分。据最近的统计资料表明，在美国</span><span lang="en-us" xml:lang="en-us">460</span><span style="font-family:'宋体';">万商业大楼中，</span><span lang="en-us" xml:lang="en-us">FTTF</span><span style="font-family:'宋体';">只有</span><span lang="en-us" xml:lang="en-us">1</span><span style="font-family:'宋体';">％。而事实上，商业、企业中约</span><span lang="en-us" xml:lang="en-us">95</span><span style="font-family:'宋体';">％以上的是少于</span><span lang="en-us" xml:lang="en-us">20</span><span style="font-family:'宋体';">个雇员的中、小型企业，向这类中小型用户提供光纤接入，经济上并不合算。目前主要是采用光纤同轴混合模式（</span><span lang="en-us" xml:lang="en-us">HFC</span><span style="font-family:'宋体';">）接入。然而由于价格和法规等因素，使得混合接入实现起来困难重重，并且其带宽依然受限。因此有线接入无论从带宽还是技术上都显得力不从心。由此产生了所谓的“最后一公里（</span><span lang="en-us" xml:lang="en-us">Last-mail</span><span style="font-family:'宋体';">）”问题。</span></p><p class="MsoNormal" style="margin-left:15.75pt;text-indent:-15.75pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">2．<span style="font:7pt 'Times New Roman';">  </span></span><span style="font-size:12pt;font-family:'黑体';">“最后一公里”问题<span lang="en-us" xml:lang="en-us"></span></span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'黑体';" xml:lang="en-us">2.1什么是“最后一公里”问题？</span></p><p></p><p class="MsoNormal" style="text-indent:21pt;"><span style="font-family:'宋体';">“最后一公里（<span lang="en-us" xml:lang="en-us">L</span></span><span lang="en-us" xml:lang="en-us">ast-mile</span><span style="font-family:'宋体';">）”问题的提出是因为光纤网的发展产生的。</span> <span style="font-family:'宋体';">“最后一公里”最早是指电信服务商在公用模拟电话通信网建设中接入工程的入户部分，真正的“最后一公里”是指从光节点到每个用户家庭之间不大于</span><span lang="en-us" xml:lang="en-us">2</span><span style="font-family:'宋体';">公里的距离。由于光纤能够提供极高带宽（目前实用的只有</span><span class="blk141"><span lang="en-us" style="letter-spacing:0pt;" xml:lang="en-us">1</span></span><span class="blk141"><span style="font-family:'宋体';letter-spacing:0pt;">吉赫兹（</span></span><span class="blk141"><span lang="en-us" style="letter-spacing:0pt;" xml:lang="en-us">GHz</span></span><span class="blk141"><span style="font-family:'宋体';letter-spacing:0pt;">）左右，只是它带宽的极小一部分），而传统的电话线带宽只有几十千赫兹（</span></span><span class="blk141"><span lang="en-us" style="letter-spacing:0pt;" xml:lang="en-us">kHz</span></span><span class="blk141"><span style="font-family:'宋体';letter-spacing:0pt;">），因此从光节点到用户终端之间的</span></span><span style="font-family:'宋体';">狭窄信息通道就形成接入网络的“瓶颈”，从而导致信息传输速度缓慢。这就是一直困扰着相当一部分用户和电信运营商的“最后一公里（</span><span lang="en-us" xml:lang="en-us">Last-mail</span><span style="font-family:'宋体';">）”问题，也是通信向宽带、智能、个人化方向发展的主要瓶颈。</span></p><p class="MsoNormal"><span lang="en-us" style="font-family:'黑体';" xml:lang="en-us">2.2 现有接入技术在解决“最后一公里”问题上的局限</span></p><p></p><p class="MsoNormal" style="text-indent:21pt;"><span style="font-family:'宋体';">现有的网络接入有多种实现途径，最常见的是电话线接入，还可以通过有线电视网、卫星通信网等途径接入。电话线接入之所以拥有最广泛的应用范围，关键在于电信系统的电话线路普及。但是它却有着几个极大的问题：</span> </p><p class="MsoNormal" style="margin-left:0cm;text-indent:14.2pt;"><span lang="en-us" xml:lang="en-us">1)<span style="font:7pt 'Times New Roman';">      </span></span><span style="font-family:'宋体';">由于传统电话线路最大只支持</span><span lang="en-us" xml:lang="en-us">64kb/s</span><span style="font-family:'宋体';">的传输速率，加之用户众多，所以线路常常拥挤不堪，速度其慢无比，令人无法忍受。</span></p><p class="MsoNormal" style="margin-left:0cm;text-indent:14.2pt;"><span lang="en-us" xml:lang="en-us">2)<span style="font:7pt 'Times New Roman';">      </span></span><span style="font-family:'宋体';">电话线路是模拟线路，只能传送模拟信号。若要提供数据业务，必须进行</span><span lang="en-us" xml:lang="en-us">A/D</span><span style="font-family:'宋体';">、</span><span lang="en-us" xml:lang="en-us">D/A</span><span style="font-family:'宋体';">转换，这样一来变得很不稳定，经常会出现断线现象。</span></p><p class="MsoNormal" style="text-indent:21.75pt;"><span style="font-family:'宋体';">因此，电话线根本</span><span class="blk141"><span style="font-size:11pt;font-family:'宋体';letter-spacing:0pt;">无法实现宽带接入。</span></span><span style="font-family:'宋体';">目前在国际上普遍采用的宽带接入方案有以下几种：</span><span lang="en-us" xml:lang="en-us"> FTTH</span><span style="font-family:'宋体';">（光纤直接入户）、</span><span lang="en-us" xml:lang="en-us">ADSL</span><span style="font-family:'宋体';">（</span><span style="color:#000000;font-family:'宋体';">非对称数字用户线路）</span><span style="font-family:'宋体';">、</span><span lang="en-us" xml:lang="en-us">Cable Modem</span><span style="font-family:'宋体';">（线缆调制解调器）、局域网接入等技术。在国内，由于光交换设备昂贵和技术等因素造成光纤入户成本极高且劳民伤财；</span><span lang="en-us" xml:lang="en-us"> ADSL</span><span style="font-family:'宋体';">接入方案对线缆质量的要求比较高，也不便于将来的技术升级，且始终未能突破非对称传输的瓶颈；</span><span lang="en-us" xml:lang="en-us">Cable Modem</span><span style="font-family:'宋体';">接入方案是一种在美国普遍采用的宽带接入方案，由于美国人口稀少，居住分散，而</span><span lang="en-us" xml:lang="en-us">Cable Modem</span><span style="font-family:'宋体';">可以完成</span><span lang="en-us" xml:lang="en-us">30-40</span><span style="font-family:'宋体';">公里范围内的宽带接入问题，因此</span><span lang="en-us" xml:lang="en-us">Cable Modem</span><span style="font-family:'宋体';">接入方案是一种比较适合美国国情的技术。然而我国的居住情况却是城市人口密度大，在相对较小的范围内拥有众多的住户，这时的宽带接入是解决“最后一公里”问题，而不是</span><span lang="en-us" xml:lang="en-us">30-40</span><span style="font-family:'宋体';">公里的距离。</span></p><p class="MsoNormal" style="text-indent:21.75pt;"><span style="font-family:'宋体';">因此有线接入在解决“最后一公里”问题时就显得捉襟见肘了。随着无线通信技术的迅速发展，一种提供通信容量接近于光纤，号称为“无线光纤”的新兴无线接入技术异军突起，这就是本地多点分配业务——</span><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">。</span></p><p class="MsoNormal" style="margin-left:15.75pt;text-indent:-15.75pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">3．<span style="font:7pt 'Times New Roman';">  </span></span><span lang="en-us" style="font-size:12pt;font-family:'黑体';" xml:lang="en-us">LMDS</span><span style="font-size:12pt;font-family:'黑体';">技术简析</span></p><p class="MsoNormal" style="text-indent:21.75pt;"><span style="font-family:'宋体';">本地多点分配业务又称为本地多路分配业务<span lang="en-us" xml:lang="en-us">(</span></span><span lang="en-us" xml:lang="en-us">Local Multipoint Distribution Service</span><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">,缩写成</span><span lang="en-us" xml:lang="en-us">LMDS</span><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">)是宽带无线接入系统的代表。</span><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">“本地多点分配业务”中各个词都有其自身的含义。</span></p><p></p><p class="MsoNormal" style="text-indent:21.75pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">“本地（</span><span lang="en-us" xml:lang="en-us">Local</span><span style="font-family:'宋体';">）<span lang="en-us" xml:lang="en-us">”其实就是指单个基站所能够覆盖的范围。</span></span><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">因为受工作频率和电波传播特性的限制，单个基站在城市环境中所覆盖的半径通常小于<span lang="en-us" xml:lang="en-us">5公里；</span></span></p><p></p><p class="MsoNormal" style="text-indent:21.75pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">“多点（</span><span lang="en-us" xml:lang="en-us">Multipoint</span><span style="font-family:'宋体';">）<span lang="en-us" xml:lang="en-us">”是指信号由基站到用户端是以点对多点的方式传送的，而信号由用户端到基站则是以点对点的方式传送；</span></span></p><p></p><p class="MsoNormal" style="text-indent:21.75pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">“分配（</span><span lang="en-us" xml:lang="en-us">Distribution</span><span style="font-family:'宋体';">）<span lang="en-us" xml:lang="en-us">”是指基站将发出的信号（可能同时包括话音、数据及</span></span><span lang="en-us" xml:lang="en-us">Internet</span><span style="font-family:'宋体';">、图像业务）分别分配至各个用户；<span lang="en-us" xml:lang="en-us"></span></span></p><p></p><p class="MsoNormal" style="text-indent:21.75pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">“业务（</span><span lang="en-us" xml:lang="en-us">Service</span><span style="font-family:'宋体';">）<span lang="en-us" xml:lang="en-us">”是指系统运营者与用户之间的业务提供与使用关系，即用户从</span></span><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">网络所能得到的业务完全取决于运营者对业务的选择。<span lang="en-us" xml:lang="en-us"></span></span></p><p></p><p class="MsoNormal" style="text-indent:21.75pt;"><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">以广播方式提供高速率、大容量、点对多点的高可靠性全双工的宽带无线接入，利用无线信道代替有线电缆，以无线通信方式解决从数据骨干网、本地交换机到用户之间的接入问题，通过地面转接站而不是卫星来转发数据。它基于毫米波技术提供业务，工作在</span><span lang="en-us" xml:lang="en-us">28GHz</span><span style="font-family:'宋体';">附近频段（</span><span lang="en-us" xml:lang="en-us">80</span><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">%左右的国家将</span><span lang="en-us" xml:lang="en-us">27.5GHz</span><span style="font-family:'宋体';">～</span><span lang="en-us" xml:lang="en-us">29.5GHz</span><span style="font-family:'宋体';">定义为</span><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">的频段）。</span><span style="font-family:'宋体';">可用的带宽达到<span lang="en-us" xml:lang="en-us">1GHz以上，几乎可以提供任何种类的业务，并支持</span></span><span lang="en-us" xml:lang="en-us">ATM</span><span style="font-family:'宋体';">、</span><span lang="en-us" xml:lang="en-us">TCP</span><span style="font-family:'宋体';">／</span><span lang="en-us" xml:lang="en-us">IP</span><span style="font-family:'宋体';">和</span><span lang="en-us" xml:lang="en-us">MPEG-2</span><span style="font-family:'宋体';">等标准，</span><span style="font-family:'宋体';">具有很高的可靠性。</span><span style="font-family:'宋体';">由于</span><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">具有更高带宽和双向数据传输的特点，可提供多种宽带交互式数据及多媒体业务，克服传统的本地环路瓶颈，满足用户对高速数据和图像通信日益增长的需求，</span><span style="font-family:'宋体';">被誉为是空中的</span><span lang="en-us" xml:lang="en-us">ATM</span><span style="font-family:'宋体';">及</span><span lang="en-us" xml:lang="en-us">IP</span><span style="font-family:'宋体';">的延伸，</span><span style="font-family:'宋体';">因此是解决通信网接入问题的利器。</span><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us"></span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">3.1<span>  </span></span><span lang="en-us" style="font-family:'黑体';" xml:lang="en-us">LMDS的工作原理</span><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us"></span></p><p></p><p class="MsoNormal" style="text-indent:21pt;">&lt;?xml:namespace prefix = v ns = "urn:schemas-microsoft-com:vml" /&gt;</p><table cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><div><p class="MsoNormal"><span style="font-size:9pt;font-family:'宋体';">中频信号</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p></p></div></td></tr></tbody></table><table cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><div><p class="MsoNormal"><span style="font-size:9pt;font-family:'宋体';">中</span><span style="font-size:9pt;"> <span> </span></span><span style="font-size:9pt;font-family:'宋体';">频</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:'宋体';">载波源</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p></p></div></td></tr></tbody></table><table cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><div><p class="MsoNormal"><span style="font-size:9pt;font-family:'宋体';">中</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"><span>  </span></span><span style="font-size:9pt;font-family:'宋体';">频</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:'宋体';">调制器</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p></p></div></td></tr></tbody></table><table cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><div><p class="MsoNormal"><span style="font-size:9pt;font-family:'宋体';">功率</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:'宋体';">中放</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p></p></div></td></tr></tbody></table><table cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><div><p class="MsoNormal"><span style="font-size:9pt;font-family:'宋体';">微</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"><span>  </span></span><span style="font-size:9pt;font-family:'宋体';">波</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:'宋体';">上变频</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p></p></div></td></tr></tbody></table><table cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><div><p class="MsoNormal"><span style="font-size:9pt;font-family:'宋体';">微波功放</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p></p></div></td></tr></tbody></table><table cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><div><p class="MsoNormal"><span style="font-size:9pt;font-family:'宋体';">微</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"><span>  </span></span><span style="font-size:9pt;font-family:'宋体';">波</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:'宋体';">滤波器</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p></p></div></td></tr></tbody></table><table cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><div><p class="MsoNormal"><span style="font-size:9pt;font-family:'宋体';">天线</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p></p><p class="MsoNormal"><span style="font-size:9pt;font-family:'宋体';">振子</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p></p></div></td></tr></tbody></table><table cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><div><p class="MsoNormal"><span style="font-size:9pt;font-family:'宋体';">码型变换</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p></p></div></td></tr></tbody></table><table cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><div><p class="MsoNormal"><span style="font-size:9pt;font-family:'宋体';">微波本振</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p></p></div></td></tr></tbody></table><table cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><div><p class="MsoNormal"><span style="font-size:9pt;font-family:'宋体';">终端设备信号</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p></p></div></td></tr></tbody></table><table cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><div><p class="MsoNormal"><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">LMDS</span><span style="font-size:9pt;font-family:'宋体';">室内单元</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p></p></div></td></tr></tbody></table><table cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><div><p class="MsoNormal" style="text-indent:9pt;"><span lang="en-us" style="font-size:9pt;" xml:lang="en-us">LMDS</span><span style="font-size:9pt;font-family:'宋体';">室外单元</span><span lang="en-us" style="font-size:9pt;" xml:lang="en-us"></span></p><p></p></div></td></tr></tbody></table><table cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><div><p align="center" class="MsoNormal" style="text-align:center;"><span style="font-family:'黑体';">图<span lang="en-us" xml:lang="en-us">1<span>  </span>LMDS设备发信原理框图</span></span></p><p></p></div></td></tr></tbody></table>&lt;?xml:namespace prefix = w ns = "urn:schemas-microsoft-com:office:word" /&gt;<br clear="all"/><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">采用一种类似于蜂窝状的服务区结构，将一个需要提供业务的地区划分为若干个服务区。每个服务区内设基站，基站设备经点到多点的无线链路与服务区内的远端站（用户端）进行通信。</span><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">设备发信原理如图<span lang="en-us" xml:lang="en-us">1所示。</span></span><p></p><p class="MsoNormal" style="text-indent:21pt;"><span style="font-family:'宋体';">基站和远端站之间下行复用方式为时分复用（</span><span lang="en-us" xml:lang="en-us">TDM</span><span style="font-family:'宋体';">）或频分复用（</span><span lang="en-us" xml:lang="en-us">FDM</span><span style="font-family:'宋体';">），上行为时分多址接入（</span><span lang="en-us" xml:lang="en-us">TDMA</span><span style="font-family:'宋体';">）或频分多址接入（</span><span lang="en-us" xml:lang="en-us">FDMA</span><span style="font-family:'宋体';">），也可以采用码分多址（</span><span lang="en-us" xml:lang="en-us">CDMA</span><span style="font-family:'宋体';">）接入。射频调制方式为正交相移键控（</span><span lang="en-us" xml:lang="en-us">QPSK</span><span style="font-family:'宋体';">）或正交幅度调制（</span><span lang="en-us" xml:lang="en-us">QAM</span><span style="font-family:'宋体';">）。基站和远端站又分别分为室内单元和室外单元两部分。室内单元提供与业务相关的部分（如业务的适配和汇聚），将来自终端设备的信号经过码型变换后，在中频调制器中对中频载波进行调制，以获得中频调制信号；室外单元提供基站和远端站之间的射频传输功能，包括射频收发器和射频天线两部分。射频收发器将来自室内单元的中频信号进行上变频，调制到射频频带，通过微波滤波器输出射频信号到射频天线进行发射。由于无线信道中存在多径效应以及随机干扰，使得无线信道的传输性能比较恶劣，所以发送端一般采用</span><span lang="en-us" xml:lang="en-us">RS</span><span style="font-family:'宋体';">编码加交织的方式，提高系统的纠错性能。</span></p><p class="MsoNormal"><span lang="en-us" xml:lang="en-us">3</span><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">.</span><span lang="en-us" xml:lang="en-us">2</span><span lang="en-us" style="font-family:'黑体';" xml:lang="en-us"><span>  </span>LMDS系统结构</span></p><p class="MsoNormal" style="text-indent:21pt;"><span style="z-index:7;"></span></p><table cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><div class="shape" style="padding-right:7.2pt;padding-left:7.2pt;padding-bottom:3.6pt;padding-top:3.6pt;"><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p></div></td></tr></tbody></table><table cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><div><p class="MsoNormal" style="text-indent:21pt;"><span style="font-family:'黑体';">图<span lang="en-us" xml:lang="en-us">2<span>   </span>LMDS系统组成</span></span></p><p></p></div></td></tr></tbody></table><table cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><div><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us"></span></p></div></td></tr></tbody></table><table cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><div><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p></div></td></tr></tbody></table><table cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><div><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p></div></td></tr></tbody></table><br clear="all"/><span style="z-index:5;"></span><table cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><div class="shape" style="padding-right:7.2pt;padding-left:7.2pt;padding-bottom:3.6pt;padding-top:3.6pt;"><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p></div></td></tr></tbody></table><span style="z-index:4;"></span><table cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><div class="shape" style="padding-right:7.2pt;padding-left:7.2pt;padding-bottom:3.6pt;padding-top:3.6pt;"><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p></div></td></tr></tbody></table><span style="font-family:'宋体';">一般地，</span><span style="font-family:'宋体';">一个完善的</span><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">系统由电信骨干网、基站、远端站和网管系统</span><span lang="en-us" xml:lang="en-us">(NOC</span><span lang="en-us" xml:lang="en-us">)</span><span style="font-family:'宋体';">四部分构成。</span><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">系统组成如图<span lang="en-us" xml:lang="en-us">2所示。</span></span><p></p><p class="MsoNormal" style="margin-left:0cm;text-indent:14.2pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">1)<span style="font:7pt 'Times New Roman';">     </span></span><span style="z-index:3;"></span></p><table cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><div class="shape" style="padding-right:7.2pt;padding-left:7.2pt;padding-bottom:3.6pt;padding-top:3.6pt;"><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p></div></td></tr></tbody></table><span style="z-index:2;"></span><table cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><div class="shape" style="padding-right:7.2pt;padding-left:7.2pt;padding-bottom:3.6pt;padding-top:3.6pt;"><p class="MsoNormal"><span lang="en-us" xml:lang="en-us"> </span></p><p></p></div></td></tr></tbody></table><span style="font-family:'宋体';">基础骨干网又称为核心网络。为了使</span><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">系统能够提供多样化的综合业务，此骨干网络可以由光纤传输网、</span><span lang="en-us" xml:lang="en-us">ATM</span><span style="font-family:'宋体';">交换机、</span><span lang="en-us" xml:lang="en-us">IP</span><span style="font-family:'宋体';">交换机或</span><span lang="en-us" xml:lang="en-us">IP+ATM</span><span style="font-family:'宋体';">架构而成的核心交换平台以及与</span><span lang="en-us" xml:lang="en-us">Internet</span><span style="font-family:'宋体';">、公共电话网（</span><span lang="en-us" xml:lang="en-us">PSTN</span><span style="font-family:'宋体';">）的互连模块等组成。</span><span style="font-family:'宋体';">各个</span><span style="font-family:'宋体';">基站的数据送入骨干网络，完成话音交换、</span><span lang="en-us" xml:lang="en-us">ATM</span><span style="font-family:'宋体';">交换和</span><span lang="en-us" xml:lang="en-us">IP</span><span style="font-family:'宋体';">交换等，并连入国际出口。<span lang="en-us" xml:lang="en-us"> </span></span><p></p><p class="MsoNormal" style="margin-left:0cm;text-indent:14.2pt;"><span lang="en-us" xml:lang="en-us">2)<span style="font:7pt 'Times New Roman';">      </span></span><span style="font-family:'宋体';">基站设备由多个扇区设备组成。每个扇区分室外单元（</span><span lang="en-us" xml:lang="en-us">ODU</span><span style="font-family:'宋体';">）和室内单位（</span><span lang="en-us" xml:lang="en-us">IDU</span><span style="font-family:'宋体';">）两部分。室外单元包括天线、微波收发模块；室内单元包括调制解调模块、网络接口模块。其中网络接口模块提供与电信骨干网的接口，如</span><span lang="en-us" xml:lang="en-us">ATM</span><span style="font-family:'宋体';">、</span><span lang="en-us" xml:lang="en-us">IP</span><span style="font-family:'宋体';">、</span><span lang="en-us" xml:lang="en-us">Frame Relay</span><span style="font-family:'宋体';">（帧中继）、</span><span lang="en-us" xml:lang="en-us">PSTN</span><span style="font-family:'宋体';">、</span><span lang="en-us" xml:lang="en-us">ISDN</span><span style="font-family:'宋体';">等，并</span><span style="font-family:'宋体';">实现信号在骨干网络与无线传输之间的转换。</span></p><p class="MsoNormal" style="text-indent:21pt;"><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">系统的基站采用多扇区覆盖，使用在一定角度范围内聚焦的喇叭天线来覆盖用户端设备。</span><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">系统根据采用天线的不同，可划分为</span><span lang="en-us" xml:lang="en-us">15</span><span style="font-family:'宋体';">度、</span><span lang="en-us" xml:lang="en-us">22.5</span><span style="font-family:'宋体';">度、</span><span lang="en-us" xml:lang="en-us">30</span><span style="font-family:'宋体';">度、</span><span lang="en-us" xml:lang="en-us">45</span><span style="font-family:'宋体';">度、</span><span lang="en-us" xml:lang="en-us">60</span><span style="font-family:'宋体';">度、</span><span lang="en-us" xml:lang="en-us">90</span><span style="font-family:'宋体';">度的扇区，即最少</span><span lang="en-us" xml:lang="en-us">4</span><span style="font-family:'宋体';">个扇区，最多可达</span><span lang="en-us" xml:lang="en-us">24</span><span style="font-family:'宋体';">个扇区。基站室内单元将来自各扇区不同用户的上行业务进行汇聚复用，提交至不同的业务结点，而后由网络接口模块完成用户业务的接入服务。</span></p><p class="MsoNormal" style="margin-left:0cm;text-indent:14.2pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">3)<span style="font:7pt 'Times New Roman';">     </span></span><span style="font-family:'宋体';">远端站</span><span lang="en-us" xml:lang="en-us">(</span><span style="font-family:'宋体';">也称为用户终端</span><span lang="en-us" xml:lang="en-us">)</span><span style="font-family:'宋体';">设在用户驻地，可以是小区或家庭用户。同样由室外单元（</span><span lang="en-us" xml:lang="en-us">ODU</span><span style="font-family:'宋体';">）和室内单元（</span><span lang="en-us" xml:lang="en-us">IDU</span><span style="font-family:'宋体';">）组成。室外单元包括</span><span style="font-family:'宋体';">定向天线</span><span style="font-family:'宋体';">、微波收发模块；室内单元包括调制解调模块、网络接口模块（</span><span lang="en-us" xml:lang="en-us">NIU</span><span style="font-family:'宋体';">）。室外单元的定向天线定向地接受来自本扇区基站天线的信号，室内单元将来自用户驻地网的业务适配、汇聚，而后通过中频电缆传送到室外单元，并通过无线链路传送到基站；在相反的方向，室内单元从下行业务中提取本站业务，分送给用户。</span><span style="font-family:'宋体';">网络接口模块为各种用户业务提供接口，并完成复用／解复用功能。<span lang="en-us" xml:lang="en-us"></span></span></p><p></p><p class="MsoNormal" style="margin-left:0cm;text-indent:14.2pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">4)<span style="font:7pt 'Times New Roman';">     </span></span><span style="font-family:'宋体';">网管系统是整个</span><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">系统的监控中心，</span><span style="font-family:'宋体';">负责完成告警与故障诊断、网络配置、系统计费、性能分析和安全管理等功能。<span lang="en-us" xml:lang="en-us"></span></span></p><p></p><p class="MsoNormal"><span lang="en-us" xml:lang="en-us">3.3 </span><span lang="en-us" style="font-family:'黑体';" xml:lang="en-us"><span> </span>LMDS提供的业务</span></p><p class="MsoNormal" style="text-indent:21pt;"><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">的宽带特性，决定它几乎可以提供任何种类的业务，包括话音、数据和图像等。</span><span style="font-family:'宋体';">同时还可以提供承载业务，如蜂窝系统或</span><span lang="en-us" xml:lang="en-us">PCS</span><span style="font-family:'宋体';">／</span><span lang="en-us" xml:lang="en-us">PCN</span><span style="font-family:'宋体';">基站之间的传输等。</span><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us"></span></p><p></p><p class="MsoNormal" style="margin-left:0cm;text-indent:14.2pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">1)<span style="font:7pt 'Times New Roman';">     </span></span><span style="font-family:'宋体';">话音业务<span lang="en-us" xml:lang="en-us"><span>  </span></span></span><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">系统是一种高容量的点对多点微波传输技术，</span><span style="font-family:'宋体';">可提供高质量的话音服务，而且没有时延。系统可提供标准接口，如<span lang="en-us" xml:lang="en-us">RJ-11、</span></span><span lang="en-us" xml:lang="en-us">10Base-T</span><span style="font-family:'宋体';">等</span><span style="font-family:'宋体';">。<span lang="en-us" xml:lang="en-us"></span></span></p><p></p><p class="MsoNormal" style="margin-left:0cm;text-indent:14.2pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">2)<span style="font:7pt 'Times New Roman';">     </span></span><span style="font-family:'宋体';">数据业务</span><span lang="en-us" xml:lang="en-us"><span>  </span>LMDS</span><span style="font-family:'宋体';">系统的数据业务包括低、中、高速</span><span lang="en-us" xml:lang="en-us">3</span><span style="font-family:'宋体';">档。低速数据业务，</span><span lang="en-us" xml:lang="en-us">1.2</span><span style="font-family:'宋体';">～</span><span lang="en-us" xml:lang="en-us">9.6kb/s</span><span style="font-family:'宋体';">，能处理开放协议的数据，网络允许从本地接入点接到增值业务网；中速数据业务，</span><span lang="en-us" xml:lang="en-us">9.6kb</span><span style="font-family:'宋体';">／</span><span lang="en-us" xml:lang="en-us">s</span><span style="font-family:'宋体';">～</span><span lang="en-us" xml:lang="en-us">2Mb/s</span><span style="font-family:'宋体';">，这样的数据接口通常是增值网络本地接点；高速数据业务，</span><span lang="en-us" xml:lang="en-us">2</span><span style="font-family:'宋体';">～</span><span lang="en-us" xml:lang="en-us">155Mb</span><span style="font-family:'宋体';">／</span><span lang="en-us" xml:lang="en-us">s</span><span style="font-family:'宋体';">，</span><span lang="en-us" xml:lang="en-us">BER</span><span style="font-family:'宋体';">低于</span><span lang="en-us" xml:lang="en-us">10</span><sup><span style="font-family:'宋体';">－</span><span lang="en-us" xml:lang="en-us">9</span></sup><span style="font-family:'宋体';">。提供这样的数据业务必须有以太网和光纤分布数据接口。</span><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us"></span></p><p></p><p class="MsoNormal" style="margin-left:0cm;text-indent:14.2pt;"><span lang="en-us" xml:lang="en-us">3)<span style="font:7pt 'Times New Roman';">      </span></span><span style="font-family:'宋体';">图像业务</span> <span lang="en-us" xml:lang="en-us"><span> </span>LMDS</span><span style="font-family:'宋体';">可支持模拟和数字图像业务，如远程医疗、高速会议电视、远程教育、远程商业及用户电视、视频点播（</span><span lang="en-us" xml:lang="en-us">VOD</span><span style="font-family:'宋体';">）等。可提供的图像信道包括</span><span lang="en-us" xml:lang="en-us">150</span><span style="font-family:'宋体';">条远程节目、</span><span lang="en-us" xml:lang="en-us">10</span><span style="font-family:'宋体';">条本地节目。系统的信号可以从卫星来，也可以是本地制作的；可以是加密的，也可以是未加密的。</span></p><p class="MsoNormal"><span lang="en-us" xml:lang="en-us">3.4<span>  </span></span><span lang="en-us" style="font-family:'黑体';" xml:lang="en-us">LMDS系统的优势</span></p><p></p><p class="MsoNormal" style="text-indent:26.25pt;"><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">本质上是一种固定宽带无线接入技术，因此它具有宽带和无线接入这两方面的优势，具体体现在：<span lang="en-us" xml:lang="en-us"></span></span></p><p></p><p class="MsoNormal" style="margin-left:0cm;text-indent:14.2pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">1)<span style="font:7pt 'Times New Roman';">     </span></span><span style="font-family:'宋体';">工作频带宽，可提供宽带接入。目前，各国分配的</span><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">工作频带带宽可达</span><span lang="en-us" xml:lang="en-us">1GHz</span><span style="font-family:'宋体';">，比蜂窝通信系统（</span><span lang="en-us" xml:lang="en-us">50MHz</span><span style="font-family:'宋体';">）、</span><span lang="en-us" xml:lang="en-us">PCS</span><span style="font-family:'宋体';">系统（</span><span lang="en-us" xml:lang="en-us">140MHz</span><span style="font-family:'宋体';">）、</span><span lang="en-us" xml:lang="en-us">MMDS</span><span style="font-family:'宋体';">系统（</span><span lang="en-us" xml:lang="en-us">140MHz</span><span style="font-family:'宋体';">）等的带宽高得多，可支持的用户接入数据速率高达</span><span lang="en-us" xml:lang="en-us">155Mb/s</span><span style="font-family:'宋体';">，能够满足用户对通信带宽日益增长的需求。<span lang="en-us" xml:lang="en-us"></span></span></p><p></p><p class="MsoNormal" style="margin-left:0cm;text-indent:14.2pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">2)<span style="font:7pt 'Times New Roman';">     </span></span><span style="font-family:'宋体';">频率复用度高、系统容量大。</span><span style="font-family:'宋体';">多扇区基站可以更有效地利用频谱，进一步扩大系统容量。如果采用极化复用，可以进一步增加系统容量。</span><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">基站的容量很可能超过其覆盖区内可能的用户业务总量，因此，</span><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">系统很可能是一个<span lang="en-us" xml:lang="en-us">“范围”受限系统而不是“容量”受限系统。所以</span></span><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">系统特别适于在高密度用户地区使用。</span><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us"></span></p><p></p><p class="MsoNormal" style="margin-left:0cm;text-indent:14.2pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">3)<span style="font:7pt 'Times New Roman';">     </span></span><span style="font-family:'宋体';">系统扩容灵活。当用户增加时，可以通过增加每扇区的载波数量或者采用角度更小的扇区天线来细化扇区，也可以将两种手段结合，都可大幅度提高系统容量。</span><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us"></span></p><p></p><p class="MsoNormal" style="margin-left:0cm;text-indent:14.2pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">4)<span style="font:7pt 'Times New Roman';">     </span></span><span style="font-family:'宋体';">具有毫米波通信的优点。毫米波通信方向性好，性能稳定，受外界干扰较小。由于工作在毫米波波段，天线口径及射频前端设备体积可以做得很小，减少了设备的复杂性，这对用户端尤为重要。<span lang="en-us" xml:lang="en-us"></span></span></p><p></p><p class="MsoNormal" style="margin-left:0cm;text-indent:14.2pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">5)<span style="font:7pt 'Times New Roman';">     </span></span><span style="font-family:'宋体';">具有无线通信系统一般具有的优势。如建设成本低、启动资金较小、建设周期短、投资回收快、网络运行和维护费用低等特点。<span lang="en-us" xml:lang="en-us"></span></span></p><p></p><p class="MsoNormal"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">3.5<span>  </span></span><span lang="en-us" style="font-family:'黑体';" xml:lang="en-us">LMDS系统的局限性</span><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us"></span></p><p></p><p class="MsoNormal" style="text-indent:21pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us"><span> </span></span><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">工作在毫米波频段<span lang="en-us" xml:lang="en-us">,使它具有毫米波通信所固有的一些局限：</span></span></p><p></p><p class="MsoNormal" style="margin-left:0cm;text-indent:21pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">1)<span style="font:7pt 'Times New Roman';">     </span></span><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">服务区覆盖范围较小，不适合远程用户使用。毫米波在自由空间传播损耗很大。在实际的传输中还要受到反射、折射、散射和吸收等因素的影响，使得传播损耗更大。因此，</span><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">的典型覆盖半径为<span lang="en-us" xml:lang="en-us">3～5公里。</span></span></p><p></p><p class="MsoNormal" style="margin-left:0cm;text-indent:21pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">2)<span style="font:7pt 'Times New Roman';">     </span></span><span style="font-family:'宋体';">需要视距传输。毫米波波长较短，只适合视距传输。为了避开新的高层建筑可能要频繁调整置于楼顶或者塔顶的</span><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">收发设备，这必将增加网络维护的费用。<span lang="en-us" xml:lang="en-us"></span></span></p><p></p><p class="MsoNormal" style="margin-left:0cm;text-indent:21pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">3)<span style="font:7pt 'Times New Roman';">     </span></span><span style="font-family:'宋体';">由于工作频率高，通信质量受雨、雪等天气影响较大，严重时会导致通信中断。<span lang="en-us" xml:lang="en-us"></span></span></p><p></p><p class="MsoNormal" style="margin-left:0cm;text-indent:21pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">4)<span style="font:7pt 'Times New Roman';">     </span></span><span style="font-family:'宋体';">高频段的基站设备相对比较复杂，价格较贵，所以在用户少时，每个用户的平均成本较高。<span lang="en-us" xml:lang="en-us"></span></span></p><p></p><p class="MsoNormal" style="margin-left:0cm;text-indent:21pt;"><span lang="en-us" xml:lang="en-us">5)<span style="font:7pt 'Times New Roman';">      </span></span><span style="font-family:'宋体';">技术仍不完善。目前提供</span><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">网络设备的厂家相当有限，设备性能也存在欠缺。并且国际上尚无统一的</span><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">空中接口标准，使得不同厂商的设备互联互通存在不少问题。</span></p><p class="MsoNormal" style="margin-left:15.75pt;text-indent:-15.75pt;"><span lang="en-us" style="font-family:'宋体';" xml:lang="en-us">4．<span style="font:7pt 'Times New Roman';">  </span></span><span style="font-size:12pt;font-family:'黑体';">结束语<span lang="en-us" xml:lang="en-us"></span></span></p><p></p><p class="MsoNormal" style="text-indent:24pt;"><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">是一种崭新的宽带无线接入技术，虽然还有一些相关的技术问题没有得到很好地解决，国际上也没有统一的标准和规范。但是因它具有大容量、多业务、易建设、见效快等诸多优势，所以引起了国内外众多电信运营商的广泛关注。在光纤入户一时不能实现的情况下，</span><span lang="en-us" xml:lang="en-us">LMDS</span><span style="font-family:'宋体';">无疑是解决“最后一公里”问题的一个较好的方案。</span></p>                </div>                    </div>
12242	 用推送技术动态更新页面内容	applet  javascript  web服务  浏览器  服务器  html  	998041020	1911	muwenyi	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p> </p>用推送技术动态更新页面内容<br/><font class="content"><font class="name01">（松下客　2001年06月06日 21:15）</font><br/><br/></font><h3><b>一、什么是动态内容</b></h3><p class="content">大多数热门Web网站都从在线广告业务获利。Web页面中的广告空间是有限的，为了让广告投资物有所值，广告客户不仅必须在很小的广告空间内塞入大量的信息，而且还要保证广告能够吸引用户的注意力。在当前的大多数网站上，放入Web页面的横幅广告一般由服务器在构造页面的同时生成，我们无法把新的广告动态地插入到已经发送出去的页面。 如果要显示新的广告，唯一的办法就是重新刷新页面。我们可以用编程的方法刷新页面，例如：</p><p class="content"></p><ul class="content"><li>使用浏览器窗口对象的setTimeOut函数定期地刷新页面。但是，用这种方法刷新广告时，用户会很明显地感到页面刷新过程；同时，要确定一个合适的刷新频率也很困难。 </li><li>把页面的过期时间设置为数秒时间，使得无论何时输入焦点转到该页面（即浏览器被激活）时，浏览器就会重新下载该页面。</li></ul><p class="content">一些大型网站，如yahoo.com和msn.com，都已经采用了这些技术。这两种方法都有各自的优点和缺点。在只使用Java的情况下，我们完全可以通过网络编程和一些界面编程工作实现横幅广告的刷新系统，但必须解决下载时间过长和刷新延迟的问题。</p><h3><b>二、用Java实现内容推送</b> </h3><p class="content">结合JavaScript帧间通信和一个管理网络通信的Java Applet，我们能够用推送技术解决这个问题。在这样一个系统中，Java Applet的任务是连接服务器并监听内容更新。一旦接收到了新的内容，Applet就构造出显示这些新内容的HTML代码，调用一个JavaScript函数并把包含新内容的HTML传递给JavaScript函数。JavaScript函数运用DHTML和DOM技术，把页面中一个&lt;div&gt;标记的内容用参数中传入的新内容替换。由于浏览器安全的限制，Applet所打开的Socket端口只能连接到下载该Applet的服务器。</p><p class="content">Web服务器只在80端口监听连接请求。因此，除了Web服务器之外，我们还需要一个接受Applet的Socket连接请求的网络应用服务。这个网络应用服务定时地查询数据库，把改动数据发布（推送）到所有已经连接的Applet。由于运用了隐藏帧和JavaScript的帧间通信功能，我们能够从用户面前隐藏大多数JavaScript逻辑。</p><p class="content">在这整个处理过程中，最困难的任务是Java Applet与JavaScript代码之间的通信。Netscape提供了一个称为netscape.javascript.JSObject的类。要使用这个对象，请加入一个包含特殊“MAYSCRIPT”属性的Applet标记：</p><p class="content"></p><table bgcolor="#e9e9e9" border="1" cellpadding="5" cellspacing="0" style="border-bottom-color:#000000;border-collapse:collapse;border-right-color:#000000;" width="80%"><tbody><tr><td><pre></pre><p class="content">&lt;APPLET code="MyApplet.class" height=1 width=1 MAYSCRIPT&gt;</p></td></tr></tbody></table><p class="content">JSObject的方法允许Applet与文档对象交互以及调用JavaScript命令。例如，把下面的代码放入Applet，我们就能够访问窗口对象：</p><p class="content"></p><table bgcolor="#e9e9e9" border="1" cellpadding="5" cellspacing="0" style="border-bottom-color:#000000;border-collapse:collapse;border-right-color:#000000;" width="80%"><tbody><tr><td><pre></pre><p class="content">import netscape.javascript.*; public class MyApplet extends java.applet.Applet{ private JSObject mainwin; public void init(){ mainwin = JSObject.getWindow(this); } }</p></td></tr></tbody></table><p class="content">获得JSObject引用后，我们就能够访问文档窗口对象，并通过JSObject的eval()方法调用JavaScript函数。</p><h3><b>三、用DHTML更新页面</b> </h3><p class="content">在把来自Applet的新内容写入文档时，为了不影响原来已经存在的内容，我们可以使用HTML的&lt;div&gt;&lt;/div&gt;标记。这个标记在IE和Netscape中是不同的。</p><p class="content">　　对于IE以及Netscape 6，这个HTML标记是：</p><p class="content"></p><table bgcolor="#e9e9e9" border="1" cellpadding="5" cellspacing="0" style="border-collapse:collapse;" width="80%"><tbody><tr><td><pre></pre><p class="content">// 所有要更新的内容必须用id标识 &lt;div id="iexplorer" width=700px &gt;&lt;/div&gt;</p></td></tr></tbody></table><p class="content">　　对于Netscape 4.x版本，这个HTML标记是：</p><p class="content"></p><table bgcolor="#e9e9e9" border="1" cellpadding="5" cellspacing="0" style="border-collapse:collapse;" width="80%"><tbody><tr><td><pre></pre><p class="content">&lt;DATA&gt;&lt;layer id="netscapev" &gt;&lt;/layer&gt;&lt;/DATA&gt;</p></td></tr></tbody></table><p class="content">　　虽然我们可以通过引用适当的ID，从Applet直接更新HTML内容，但为了清楚起见，我们将把更新HTML代码的程序逻辑放入JavaScript函数。下面的JavaScript代码把浏览器的类型保存到ie变量：</p><p class="content"></p><table bgcolor="#e9e9e9" border="1" cellpadding="5" cellspacing="0" style="border-collapse:collapse;" width="80%"><tbody><tr><td><pre></pre><p class="content">applnname=navigator.appName; if(applnname=="Microsoft Internet Explorer") { ie=true; } else { ie=false; }</p></td></tr></tbody></table><p class="content">Applet从新数据构造出HTML代码，把它保存到JavaScript变量content，然后调用assignData()方法。内容数据可以是从纯HTML到XML到二进制数据的任何东西。</p><p class="content"></p><table bgcolor="#e9e9e9" border="1" cellpadding="5" cellspacing="0" style="border-collapse:collapse;" width="80%"><tbody><tr><td><pre></pre><p class="content">// 根据浏览器类型调用合适的方法 function assignData() { if(ie) {explore();} else {navig(); } }</p></td></tr></tbody></table><p class="content">如果浏览器是IE或者Netscape 6，Applet调用explore()方法：</p><p class="content"></p><table bgcolor="#e9e9e9" border="1" cellpadding="5" cellspacing="0" style="border-collapse:collapse;" width="80%"><tbody><tr><td><pre></pre><p class="content">//content是一个javascript变量，它以HTML格式描述了需要 //显示的新数据 function explore() { iexplorer.innerHTML=content; }</p></td></tr></tbody></table><p class="content">　　如果浏览器是Netscape 4.0或者更高版本，Applet调用navig()方法：</p><p class="content"></p><table bgcolor="#e9e9e9" border="1" cellpadding="5" cellspacing="0" style="border-collapse:collapse;" width="80%"><tbody><tr><td><pre></pre><p class="content">function navig() { document.netscapev.document.write('&lt;DATA&gt;' + content + '&lt;/DATA&gt;'); document.netscapev.document.close(); }</p></td></tr></tbody></table><h3><b>四、通信过程</b> </h3><p class="content">在服务器端，一个ImageAppliation.java类的实例响应Socket连接请求，并为每一个新的连接请求创建一个新的线程。为了简化代码，每一个线程只检查数据文件是否改变。如果数据文件已经改变，则线程读取文件内容，并把新的数据发送给已经连接的Applet（示例应用把整个文件发送给Applet）。</p><p class="content">在客户端，一个隐藏帧包含了ImageApplet.java这个Applet，因此用浏览器的查看HTML源代码功能是无法看到Applet标记的。Applet实现了连接服务器（下载该Applet的源服务器）的功能，并实现了一个简单的通信协议。建立与服务器的连接之后，Applet接收来自服务器的数据，构造出HTML代码，并调用JavaScript函数把数据传入文档：</p><p class="content"></p><table bgcolor="#e9e9e9" border="1" cellpadding="5" cellspacing="0" style="border-collapse:collapse;" width="80%"><tbody><tr><td><pre></pre><p class="content">public void upDateHTML(String str){ //data是表单的名字， //quote是一个JavaScript变量 //str是新构造出来的HTML代码 mainwin.eval("document.data.quote.value='" + str + "'"); mainwin.eval("javascript:assignData()"); return; }</p></td></tr></tbody></table><p class="content">netscape.javascript.JSObject完成Applet到JavaScript的通信，不同版本的客户端浏览器需要不同的版本。你可以下载得到为Netscape提供的压缩类文件<a href="http://www.ccidnet.com/tech/web/2001/06/06/%20http:/developer.netscape.com/software/jdk/download.html%20">java40.jar</a>。IE已经带有JSObject类，但有点难找。你可以搜索$windows$/Java/Packages目录寻找包含JSObject类的ZIP文件。</p><p class="content">服务器把ImageArrayElement.java类的实例通过toString()方法串行化成为字符串发送给Applet。服务器从数据文件构造出各个对象，调用toString()方法，连接得到代表所有对象的字符串，最后发送结果字符串。而在另一端，Applet接收并解析这个字符串，重新构造出各个ImageArrayElement对象。这里之所以用一个长字符串的形式发送数据，是因为这种方法只需要很简单的处理过程，使得用户能够以接近实时的速度立即得知数据的变化；但是，我们也可以用另外一种方法，即以向量的形式发送对象。</p><p class="content">在一个正式运行的应用中，你一般应该让新数据插入当前页面的过程透明。但在示例应用中，为了让程序运行过程更加直观，它将在新内容到达的时候提示用户。</p><p class="content">推送技术最主要的优点就是应用服务器只把那些改变的数据发送到网络，从而使得延迟减到了最少。由于这个Applet负责完成的工作非常少（不涉及用户界面，这部分工作由浏览器负责），所以Applet体积很小，装载速度非常快。</p><h3><b>五、如何运行本文实例</b></h3><p class="content">要测试本文示例应用，你的机器上必须安装有Web服务器和JDK 1.7或更高版本。</p><p class="content">安装要点：</p><p class="content"></p><ul class="content"><li>解开ZIP压缩文件并安装到Web服务器默认根目录。 </li><li>对于IIS服务器，默认根目录是Inetput/wwwroot </li><li>对于jsdk2.1所带的免费服务器，默认目录是&lt;安装目录&gt;/webpages </li><li>解开压缩文件之后，所有文件都将安装到&lt;Web服务器根&gt;/exp/目录。 </li><li>把下面几行代码加入默认页面。每一种服务器都有自己的默认页面，IIS的默认页面是“default.htm”，请参见Web服务器文档了解具体说明：</li></ul><p class="content"></p><table bgcolor="#e9e9e9" border="1" cellpadding="5" cellspacing="0" style="border-collapse:collapse;" width="80%"><tbody><tr><td bgcolor="#e9e9e9" rowspan="5"><pre></pre><p class="content">&lt;ul&gt;&lt;li&gt; &lt;a href="/exp/ImageMain.htm"&gt; Java based dynamic Ad-Banner&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;</p></td></tr></tbody></table><p class="content">运行应用的步骤：</p><p class="content"></p><ul class="content"><li>打开一个DOS窗口，进入&lt;默认Web目录&gt;/exp，执行“java ImageApplication”。系统将显示“Server started listening at port 6011”。注意确保classpath环境变量指向了当前工作目录。 </li><li>启动Web服务器。 </li><li>打开浏览器输入下面的URL：http://localhost:8080。该URL将打开Web服务器的默认页面，它应该有一个“Java based dynamic Ad-Banner”链接。点击这个链接就启动了本文的示例应用。 </li><li>用Notepad打开“/exp/images.txt”文件，复制并粘贴一行内容，保存文件。你可以立即看到系统显示一个JavaScript窗口提示内容更新。关闭JavaScript窗口，页面将显示新的内容。</li></ul><ul class="content"><li><a href="http://home.netscape.com/eng/mozilla/3.0/handbook/plugins/doc/netscape.javascript.JSObject.html">Documentation for the Class netscape.javascript.JSObject</a> </li><li><a href="http://java.sun.com/products/plugin/1.3/docs/jsobject.html">How Java-to-Javascript Communication Works</a> </li><li><a href="http://www.netscape.com/">Netscape</a> </li><li><a href="http://msdn.microsoft.com/ie/">Internet Explorer</a></li></ul><p class="content">　　请从<a href="http://www.ccidnet.com/tech/web/2001/06/06/image/UpdatingWebContentWithJava_code.zip">这里</a>下载本文实例的完整代码，411 KB。</p><p>责任编辑:小李(<a href="mailto:lisz@staff.ccidnet.com">lisz@staff.ccidnet.com</a>)</p>                </div>                    </div>
12345	 C#介绍	c#  语言  微软  java  c++  .net  	1001291220	1480	ysli	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p>翻译整理 毛竹 南海<br/>    C#介绍<br/>    最近微软宣布了它的最新编程语言C#，这是一种面向对象的编程语言，它将作为Visual Studio中的一部分推出。C#（发音为“C-Sharp”）既保持了C++中熟悉的语法，并且还包含了大量的高效代码和面向对象特性。据微软产品经理透露，C#语言将在保持C/C++灵活性的基础上为程序员带来更高效的RAD开发方式。它不仅能用于WEB服务程序的开发，并且还能开发强大的系统级程序。</p><p>    微软还没有正式宣布这一新语言技术，该技术将以测试形式出现在微软打算在7月中旬在专业开发会议上分发的Visual Studio 7中。Visual Studio 7将于明年某个时候正式发售。</p><p>    Layman介绍说C#包含使XML编程更为轻松的技术。微软将使它的下一代工具软件、操作系统和应用支持XML技术。</p><p>    新的编程语言还将包含虚拟机设备。微软官员已经公开表示C#技术和该公司去年开发的 Java竞争技术Cool没有关联。微软官员拒绝回答是否计划在Visual Studio 7中提供微软设计的视窗版Java Visual J++的某个版本。</p><p>    C#的特性</p><p>    现在，微软仍在一边继续反驳其竞争对手Sun控告它改变了Java语言的诉讼，一边在对美国反垄断指控顽抗到底，但与此同时，微软的天才程序员们也在技术上进行着一场补救的措施。那就是他们已经开发出来的C#语言，这是一种非常类似于Java的语言，微软深知即便是微软阵营中也有着相当一部分人喜欢Java语言，所以这次干脆就用C#来满足他们的愿望，这是一种非常完美的语言，适用于各种操作系统，并且与Windows紧密地结合在一起。</p><p>    微软表示这种新的程序设计语言并不针对Java，但它将是C++的革新。而这正是Java所追求的两个主要目标之一（另一目标当然就是可移植性）。微软一直梦想着能开发出能与Java在Windows NT系统上抗衡的语言。C#的自动内存管理以及和Java一样都使用的C语言语法，似乎让这个理想成为现实。</p><p>    微软称C#是由C和C++派生而来的一种“简单、流行、面向对象、类型安全”的程序设计语言，C#意在综合Visual Basic的高效率和C++的强大功能。但这种说法是否准确呢？由于C#的结构很像Visual Basic的ActiveX，它显然是冲着RAD开发者来的。但同时，“C#提供了C++的强大功能”这种说法也稍嫌夸张，将来很可能变成空头支票。</p><p>    对某一对象接口的更新，微软称之为“继承”，当然“继承”是就“对象”而言的。但是，虽然“对象”这个词我们经常碰到，却很少有人真正理解了它的含义。微软的用户，甚至它自己的员工都经常把“对象”和“接口”弄混。所以微软干脆就用接口来定义各种对象，结果导致了“面向对象编程”（OOP）被微软弄得乱七八糟。现在，微软又在大踏步地前进了（虽然它内心还是很小心），它把它建立在接口基础上的“对象”集成到了开发工具里。不过它走得实在过了头，它甚至把对另一对象接口的更新称之为“继承”。</p><p>    这个“继承”给程序员们带来的好处就是语言无关——只要接口维持其兼容性，用Visual Basic写成的对象在C#和C++中也可以良好地运行。但此特性是以真正的OOP技术和平台的可移植性为代价的。每个对象都被编译和注册到Windows子系统，只要你能访问这个子系统，你就能访问这个对象。来吧！欢迎来到.NET和NGWS的世界！——Windows平台从来没有完完全全地让人产生这样完整的依赖性。他们的动机当然要遭到全世界对微软有偏见的人的怀疑，当然，完全依靠此技术的C#也不例外。</p><p>    事实上，C#将是完全依靠Windows的最完美的产物。那些困绕Java SDK, MFC 和SET的数据库已成为过去。你想放入C#的任何东西（无论何种语言），只要在Windows的.NET子系统下建立和包装的都可以使用Windows的运行库。</p><p>    用MSIL进入.NET</p><p>    当人们访问Usenet或一些新闻组时，会有一些诸如新语言和平台有效性之类的问题。什么时间和努力能解决这些问题呢？当然，如没有牢固的事实和有说服力的证据，即使是最有帮助的响应者，权威机构也会对他的断言持保留意见。我没有参加今年的专业开发者会议（PDC），因此我的发现都是基于那些与会者的反馈。</p><p>    人们对微软过去几周的大肆宣传，最基本的错误理解就是C#只是Visual C++的改进版本。完全不是这么回事。C#和Java没有直接联系。它的特征设定是从Java获得的灵感。它的语法同Java一样，源自C和C++，但它的执行是完全新的，只依靠.NET结构。</p><p>    C#也并非字节码（bytecode）。微软一位员工罗伯特.舒密特详细描述道：“C#编译程序产生的是‘微软中间语言’（MSIL）……但虚拟机或其他类似的技术则不能用于解释这种中间语言（IL）。相反地，每当应用程序载入或JIT编译程序需要编译它时，IL就会被转换成本地代码。一旦这种转换完成，可以执行的代码实际上是本地代码。”实质上，虽然这种方案有点像Java程序通过一个JIL编译程序，但这里最终的JIT编译是100%的本地代码，而Java的JIT产生的结果是不同的。</p><p>    C#的弱点</p><p>    这个方案也暴露了微软对C#和.NET介绍中的一些有趣的漏洞。MSIL是.NET提供的一个新特性，允许很流行的程序设计语言编译到一个单独的公用语言。（.NET支持的语言种类是相当惊人的）。这些语言都要服从一种叫“通用语言规范（CLS）”的构架。微软称之为“CLS兼容语言和类库之间可互操作的通用语言”。</p><p>    编译所有的语言到一个单一的公用语言上，能让“继承”通过多重语言真正执行。这轻而易举的扫除了C#可能遇到的错误概念。.NET组件使用COM的IDispatch，它只允许接口执行。它比先前C#被评定为一种OOP语言的看法容易接受得多。它在程序设计上或许像Java一样是面向对象的。</p><p>    但不幸的是CLS这种包括MSIL的共享语言基础，只让RAD开发者受益，而损害了硬件的核心开发者，有人认为创造一种新程序设计语言的目的就是有能力充分运用它和服务于可微调的执行能力，这一点在CLS世界里是做不到的。老实说，加速充分利用从来不是许多语言的唯一目标。许多语言的唯一目标（最瞩目的是像Visual Basic和Java的RAD语言）是加速和美化开发和展开能力，而不仅仅是运行时刻的速度。</p><p>    舒密特文章中所提到的确实包含了相关和值得注意的评论：你可以用C++指定.NET，并在你的代码中运用所有C++特性。同时，因为.NET在运行时刻不能检验C++代码是否安全，此语言并不遵从CLS规范，里面所书写的程序也受到限制。作为应对，微软往Visual C++里添加非标准管理的扩展。用这些扩展写的代码能符合CLS规范。</p><p>    C#将把微软领向何方就一目了然了。因为所有项目编写会只依靠MSIL和CLS JIT编译程序。这样C#或任何MSIL前端语言比Java任何时候都快。但很不幸，程序设计和编译程序级的优化不能在非微软的平台上充分利用，想在非Windows平台上展开.NET，再充分运用它们也是不现实的。</p><p>    JAVA是C#的竞争对手</p><p>    尽管.NET是微软一手缔造的，它并不是只能在Windows上使用。微软准备尽力为那些COM对象提供传统帮助（所有的OLE， ActiveX等等在下一代Viual Studio推出后，都将成为一个legacy平台）。但.NET不会围绕COM建造。新平台无疑将补充COM，并与它几乎天衣无缝地配合，但一点也不会依靠COM。这表明这种结构本身能够Macintosh, UNIX. BeOX展开。这样命名，是因为除了CLS构架是平台独立的，C#将用到的和所有遵从CLS的数据库也是平台独立的。也就是说，它们都是遵从CLS的，如果一个本机MSIL编译程序在平台上有效，那么它们能在运行时刻为任何结构进行编译。微软也积极争取被ECMA标准接纳，他们先前的Javascript已被接纳。 当Visual Studio. NET推出时，开发团体肯定会有不同的反应。"微软又开发了一个新平台"，这已吓倒那些本来对微软平台统治忧心忡忡的人了。然而更重要的是C#或.NET战略不会对原始C++构成太大威胁，那么有理由推论C#和.NET将是Java的有力竞争者。考虑相反方面：Java VM靠翻译字节码来运行应用程序。CLS在运行时刻本机编译。Java平台只支持Java语言。.NET只支持MSIL，但一些无限制的高级语言如C#，Visual Basic,甚至Eiffel和COBOL都能启动MSIL。Java运用执行转接提供真正的OOP技术。MSIL，C#也是如此。在Java平台，简单地移动平级文件，项目就可以展开为产品目录。据说，.NET平台的项目也可轻松展开而不像以registry-happy Com为基础的项目。或许Java平台真正的优势只在于政治上的正确性--它不是微软搞出来的，且目前有成千上万的执着的宗教追随者。</p><p>    作者的看法</p><p>    具有讽刺意味的是，虽然我很了解Java和C#，我仍被冠以高级Visual Basic程序设计师的称号。人们会认为我这样一个VB设计师将是反对微软的偏执狂。但我也得面对现实。老实说：VB是一个RAD开发工具。别只顾着精美，别记着真正的对象。迅速得到结果才是重中之重。在商业世界里，纯粹的技术和结果不总是能相吻合的，短期结果往往胜过长期生产力。这是不幸的，但在许多公司中，这却是事实。这些公司就是C#的主要用户。我会使用C#吗？当然会用！我现在使用Visual Basic，但转入C#有何不好？我更欣赏Java和OOP语言的精美，但因为我进行的所有项目中，短期成果一直胜过长期成果，我已没有时间去考虑替换Windows平台。但如从纯技术和信仰角度来说，Java和C++的程序设计师就有足够理由关注C#，这是微软维持垄断的又一招。</p><p>    最后，C#是好还是不好？那么，因为这里的“继承”指对接口界面的再执行，所以，它不是真正的OOP。如果你是微软，亦或如果你依靠微软技术而不准备切换平台，那C#是很棒的，并将为VB程序设计师们搬运Java和C++上的技巧提供很好的基础（因为语法是共享的）。但因为微软将全力推出C#，所以，Java和C++的拥护者们肯定会设计出新的语言，予以还击。同时，C#不一定可转移到其他平台，也不能真正体现OOP的价值，甚至对OOP的初学者有害无益。</p><p> </p><p><br/> </p>                </div>                    </div>
12487	 将文件通过http的post方法上传到服务器	string  button  import  exception  input  web服务  	1048734060	5126	zlyperson	1	<div class="article_content csdn-tracking-statistics tracking-click" data-dsm="post" data-mod="popu_519" id="article_content">                            <div class="htmledit_views">                        <p> 这实际上是模仿浏览器的post行为，问题的提出是本人在做一个企业内部网络的项目的时候，该企业网络与Internet是通过一台HP-UNIX的服务器连接的，项目需要经常从互联网传送一些文本文件到内部网络的一台Web服务器，我们只能够通过那台HP-UNIX的主机进去，当时内网的Web服务器用的是DotNet框架，很容易的写好了文件上传的Web界面。这就麻烦了，我不能够用浏览器直接访问该文件上传页面，所以就只好用Java写了个模仿浏览器上传文件的程序。<br/>环境：<br/>内网Web服务器：Windows2000+DotNet Framework1.0<br/>外网主机：HP-UNIX(具体什么版本号忘记了）、jdk1.4<br/> 首先、我们解决容易的问题，我们知道asp.net的文件上传功能封装得非常完美。很轻松我们就写好了如下上传页面(命名为TestFileManager.aspx)：</p><p>&lt;%@ Page Language="c#" CodePage="936" %&gt;<br/>&lt;%@ import Namespace="System" %&gt;<br/>&lt;%@ import Namespace="System.IO" %&gt;</p><p>&lt;script runat="server"&gt;<br/> void Page_Load(Object sender, EventArgs e) {<br/> }<br/> void Button1_Click(Object sender, EventArgs e) {<br/>  //判断选取对话框选取的文件长度是否为0<br/>  Label1.Text="Clicked";<br/>  //因为我的项目中用的只是xml文件，所以有此判断<br/>  if (uploadfile1.PostedFile.ContentLength != 0 &amp;&amp; uploadfile1.PostedFile.FileName.ToLower().EndsWith(".xml")) {<br/>   try{<br/>    string strFileName = uploadfile1.PostedFile.FileName;<br/>    string[] strTemp = strFileName.Split(new char[]{'//'});<br/>    strFileName = "C://"+strTemp[strTemp.Length-1];<br/>    uploadfile1.PostedFile.SaveAs(strFileName);<br/>    Label1.Text="测试文件" + strFileName + "上传成功! ";<br/>            }<br/>            catch (Exception exp)<br/>            {<br/>    Label1.Text = exp.StackTrace;<br/>            }<br/>  }<br/> }<br/>&lt;/script&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/> &lt;title&gt;逻辑层测试管理&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>    &lt;form method="post" enctype="multipart/form-data" runat="server"&gt;<br/>        &lt;p&gt;<br/>            &lt;input id="uploadfile1" type="file" size="49" runat="server" /&gt;<br/>            &lt;asp:Button id="Button1" onclick="Button1_Click" runat="server" Text="上传"&gt;&lt;/asp:Button&gt;<br/>        &lt;/p&gt;<br/>        &lt;p&gt;<br/>            &lt;asp:Label id="Label1" runat="server" Width="459px"&gt;&lt;/asp:Label&gt;<br/>        &lt;/p&gt;<br/>        &lt;!-- Insert content here --&gt;<br/>    &lt;/form&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</p><p><br/>这个上传页面应该没什么好说的了，我们看看它将产生的html页面内容：<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>    &lt;title&gt;逻辑层测试管理&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>    &lt;form name="_ctl0" method="post" action="TestFileManager.aspx" id="_ctl0" enctype="multipart/form-data"&gt;<br/>&lt;input type="hidden" name="__VIEWSTATE" value="dDwyNTIzNjA5NDU7Oz7rsE3eBYzQHDVtl+aTn96MvQW6PQ==" /&gt;</p><p>        &lt;p&gt;<br/>            &lt;input name="uploadfile1" id="uploadfile1" type="file" size="49" /&gt;<br/>            &lt;input type="submit" name="Button1" value="?" id="Button1" /&gt;<br/>        &lt;/p&gt;<br/>        &lt;p&gt;<br/>            &lt;span id="Label1" style="width:459px;"&gt;&lt;/span&gt;<br/>        &lt;/p&gt;<br/>        &lt;!-- Insert content here --&gt;<br/>    &lt;/form&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</p><p>上面有一段&lt;input type="hidden" name="__VIEWSTATE" value="dDwyNTIzNjA5NDU7Oz7rsE3eBYzQHDVtl+aTn96MvQW6PQ==" /&gt;这是它产生的相当于Session的一个值，这个值将对我们的上传程序产生比较大的影响。<br/>接着我们来写Java上传的程序，这里要说明一点，我没有用j2se的网络包，并不是现有的网络包不行，因为当时我正好在玩sun的BRAZIL PROJECT（<a href="http://www.sun.com/2000-0822/brazil/">http://www.sun.com/2000-0822/brazil/</a>），感觉挺精巧的，所以就用上了brazil的网络功能。</p><p>import java.io.*;<br/>import org.w3c.dom.*;<br/>import org.xml.sax.*;<br/>import javax.xml.parsers.*;<br/>import sunlabs.brazil.util.*;<br/>import sunlabs.brazil.util.http.*;<br/>/**<br/> * 该类实现上传xml测试文件到逻辑层<br/> * <br/> */<br/>public class TestFileManager {<br/> /**<br/>  * 提取XML一个节点的属性值<br/>  * @node XML节点对象<br/>  * @strName 属性名称<br/>  * @return 节点的属性值<br/>  */<br/> private static String getNodeAttributeValue(Node node, String strName) {<br/>  NamedNodeMap nmap = node.getAttributes();<br/>  Node tmpnode = nmap.getNamedItem(strName);<br/>  String rtStr = "";<br/>  if ( tmpnode != null ) {<br/>   rtStr = tmpnode.getNodeValue().trim();<br/>  }<br/>  return rtStr;<br/> }</p><p> public static void main(String[] args){<br/>  if ( args.length &lt; 1 ) {<br/>   System.out.println("Usage: java TestFileManager xmlfilelist");<br/>   System.exit(0);<br/>  }<br/>  try {<br/>   HttpRequest request = new HttpRequest("<a href="http://192.9.200.108/OnlineService/TestFileManager.aspx">http://192.9.200.108:80/OnlineService/TestFileManager.aspx</a>");<br/>   request.setMethod("GET");<br/>   request.setRequestHeader("Cache-Control", "no-cache");<br/>   request.setRequestHeader("Connection", "Keep-Alive");<br/>   request.setRequestHeader("Accept", "image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */*");<br/>   request.setRequestHeader("Accept-Encoding", "gzip, deflate");<br/>   request.setRequestHeader("Accept-Language", "en-au");<br/>   request.setRequestHeader("Referer", "<a href="http://rookie/OnlineService/TestFileManager.aspx">http://rookie/OnlineService/TestFileManager.aspx</a>");<br/>   request.setRequestHeader("User-Agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; .NET CLR 1.0.3215; .NET CLR 1.0.3705)");<br/>   <br/>   request.connect();<br/>   String strCookie = request.getResponseHeader("Set-Cookie");<br/>   strCookie = strCookie.substring(0,strCookie.indexOf(";"));<br/>   <br/>   DocumentBuilderFactory dbfactory = DocumentBuilderFactory.newInstance();<br/>   DocumentBuilder parser =dbfactory.newDocumentBuilder();<br/>   String strTemp = request.getContent();<br/>   </p><p>   Document xmldoc = parser.parse(new InputSource(new StringReader(strTemp)));<br/>   NodeList nlist = xmldoc.getElementsByTagName("input");<br/>   Node node;<br/>   String strName = "";<br/>   String strValue = "";<br/>   for ( int i = 0; i &lt; nlist.getLength(); i++) {<br/>    node = nlist.item(i);<br/>    strName = getNodeAttributeValue(node,"name");<br/>    if ( strName.equals("__VIEWSTATE") ) {<br/>     strValue = getNodeAttributeValue(node,"value");<br/>     break;<br/>    }<br/>   }<br/>   request.close();<br/>   request = null;</p><p>   String strBoundary = null;<br/>   String strFileName = null;<br/>   BufferedInputStream bis = null;<br/>   byte[] data = null;<br/>   for ( int i=0; i&lt;args.length;i++ ) {<br/>    try {<br/>     strBoundary = new String(""+(Math.random()+Math.random())).substring(2);<br/>     strFileName = args[i];<br/>     bis = new BufferedInputStream(new FileInputStream(strFileName));<br/>     data = new byte[bis.available()];<br/>     bis.read(data, 0, data.length);<br/>     bis.close();<br/>     System.out.println("上传文件 " + strFileName + "...");</p><p>     request = new HttpRequest("<a href="http://192.9.200.108/OnlineService/TestFileManager.aspx">http://192.9.200.108:80/OnlineService/TestFileManager.aspx</a>");<br/>     request.setMethod("POST");<br/>     request.setRequestHeader("Cache-Control", "no-cache");<br/>     request.setRequestHeader("Connection", "Keep-Alive");<br/>     request.setRequestHeader("Content-Type", "multipart/form-data; boundary=---------------------------"+strBoundary);<br/>     request.setRequestHeader("Accept", "image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */*");<br/>     request.setRequestHeader("Accept-Encoding", "gzip, deflate");<br/>     request.setRequestHeader("Accept-Language", "en-au");<br/>     request.setRequestHeader("Cookie", strCookie);<br/>     request.setRequestHeader("Host", "rookie");<br/>     request.setRequestHeader("Referer", "<a href="http://rookie/OnlineService/TestFileManager.aspx">http://rookie/OnlineService/TestFileManager.aspx</a>");<br/>     request.setRequestHeader("User-Agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; .NET CLR 1.0.3215; .NET CLR 1.0.3705)");<br/>     DataOutputStream dos = new DataOutputStream(request.getOutputStream());<br/>     dos.writeBytes("-----------------------------"+strBoundary);<br/>     dos.writeBytes("/r/nContent-Disposition: form-data; name=/"__VIEWSTATE/"");<br/>     dos.writeBytes("/r/n/r/n"+strValue);<br/>     dos.writeBytes("/r/n-----------------------------"+strBoundary);<br/>     dos.writeBytes("/r/nContent-Disposition: form-data; name=/"uploadfile1/"; filename=/"" + strFileName + "/"");<br/>     dos.writeBytes("/r/nContent-Type: text/xml");<br/>     dos.writeBytes("/r/n/r/n");<br/>     dos.writeBytes(new String(data));<br/>          dos.writeBytes("/r/n-----------------------------"+strBoundary);<br/>     dos.writeBytes("/r/nContent-Disposition: form-data; name=/"Button1/"");<br/>     dos.writeBytes("/r/n上传");<br/>     dos.writeBytes("/r/n-----------------------------"+strBoundary+"--");<br/>     dos.writeBytes("/r/n");<br/>     dos.close();<br/>     request.connect();</p><p>     request.close();<br/>     request = null;<br/>     System.out.println("文件 " + strFileName + " 上传成功.");<br/>    } catch (FileNotFoundException e) {<br/>     System.out.println("文件 " + strFileName + " 未找到.");<br/>    } catch (Exception e) {<br/>     e.printStackTrace();<br/>    }<br/>   }<br/>  } catch (Exception e) {<br/>   e.printStackTrace();<br/>  }<br/> }<br/>}</p><p>下面我详细讲解main方法中的具体过程<br/>首先创建一个到服务器http的请求<br/>HttpRequest request = new HttpRequest("<a href="http://192.9.200.108/OnlineService/TestFileManager.aspx">http://192.9.200.108:80/OnlineService/TestFileManager.aspx</a>");<br/>第一次使用的是GET方式<br/>request.setMethod("GET");<br/>紧接着进行一些请求的属性设置<br/>request.setRequestHeader("Cache-Control", "no-cache");<br/>这里保持连接，因为后面还要发送数据到服务器呢<br/>request.setRequestHeader("Connection", "Keep-Alive");<br/>下面是一些无关紧要的属性设置了。<br/>request.setRequestHeader("Accept", "image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */*");<br/>request.setRequestHeader("Accept-Encoding", "gzip, deflate");<br/>request.setRequestHeader("Accept-Language", "en-au");<br/>request.setRequestHeader("Referer", "<a href="http://rookie/OnlineService/TestFileManager.aspx">http://rookie/OnlineService/TestFileManager.aspx</a>");<br/>request.setRequestHeader("User-Agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; .NET CLR 1.0.3215; .NET CLR 1.0.3705)");</p><p>构造好了连接请求，然后连接<br/>request.connect();</p><p>紧接着提取Cookie值，在后文的post中可以用到。<br/>String strCookie = request.getResponseHeader("Set-Cookie");<br/>strCookie = strCookie.substring(0,strCookie.indexOf(";"));</p><p>下面通过循环查找，提取__VIEWSTATE的值，这个值是不能捏造的，每个新的get取得的是不一样的。<br/>for ( int i = 0; i &lt; nlist.getLength(); i++) {<br/> node = nlist.item(i);<br/> strName = getNodeAttributeValue(node,"name");<br/> if ( strName.equals("__VIEWSTATE") ) {<br/>  strValue = getNodeAttributeValue(node,"value");<br/>  break;<br/> }<br/>}</p><p>往服务器组织发送数据<br/>DataOutputStream dos = new DataOutputStream(request.getOutputStream());<br/>dos.writeBytes("-----------------------------"+strBoundary);//这是每个要被发送数据间的间隔<br/>dos.writeBytes("/r/nContent-Disposition: form-data; name=/"__VIEWSTATE/"");<br/>dos.writeBytes("/r/n/r/n"+strValue);<br/>dos.writeBytes("/r/n-----------------------------"+strBoundary);<br/>这里面是发送文件的部分<br/>dos.writeBytes("/r/nContent-Disposition: form-data; name=/"uploadfile1/"; filename=/"" + strFileName + "/"");<br/>dos.writeBytes("/r/nContent-Type: text/xml");<br/>dos.writeBytes("/r/n/r/n");<br/>dos.writeBytes(new String(data));<br/>dos.writeBytes("/r/n-----------------------------"+strBoundary);<br/>dos.writeBytes("/r/nContent-Disposition: form-data; name=/"Button1/"");<br/>dos.writeBytes("/r/n上传");<br/>dos.writeBytes("/r/n-----------------------------"+strBoundary+"--");<br/>dos.writeBytes("/r/n");<br/>dos.close();<br/>最后发送，也就是执行连接的操作。最后把上面程序部署到HP-UNIX上面，就可以上传文件到我的逻辑层了。以上的过程用j2se的net包也可以实现的，改一改类和方法就是了。<br/>本文叙述的是文本文件的上传方式，对于二进制的文件则需要对文件数据进行编码，一般使用base64的编码。基本步骤是相同的，只要在组织文件数据的时候对文件内容编码并指明编码方式就可以了。<br/>文中不详处，请email:zlyperson@163.net</p>                </div>                    </div>
